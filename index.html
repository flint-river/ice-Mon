<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Airport Deicing Monitor - Top 100</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a2e;
            color: #eee;
            min-height: 100vh;
            padding: 15px;
        }
        
        .container {
            max-width: 800px;
            margin: 0 auto;
        }
        
        header {
            text-align: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid #333;
        }
        
        h1 {
            font-size: 22px;
            margin-bottom: 8px;
            color: #fff;
        }
        
        .subtitle {
            color: #4a90d9;
            font-size: 13px;
            margin-bottom: 5px;
        }
        
        .timestamp {
            color: #888;
            font-size: 12px;
        }
        
        .timezone-box {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 8px;
            margin: 15px 0;
            padding: 12px;
            background: #252540;
            border-radius: 8px;
        }
        
        .tz-item {
            text-align: center;
            padding: 4px 12px;
            min-width: 70px;
        }
        
        .tz-item .tz-time {
            font-family: 'Courier New', monospace;
            font-size: 18px;
            font-weight: bold;
            color: #fff;
        }
        
        .tz-item .tz-label {
            font-size: 10px;
            color: #888;
            text-transform: uppercase;
            margin-top: 2px;
        }
        
        .tz-item.zulu .tz-time {
            color: #4a90d9;
        }
        
        .tz-item.zulu .tz-label {
            color: #4a90d9;
        }
        
        .controls {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        
        .search-box {
            display: flex;
            gap: 8px;
            width: 100%;
            max-width: 400px;
            margin-bottom: 10px;
        }
        
        .search-box input {
            flex: 1;
            background: #252540;
            color: #fff;
            border: 1px solid #444;
            padding: 12px;
            border-radius: 6px;
            font-size: 14px;
        }
        
        .search-box input::placeholder {
            color: #666;
        }
        
        .search-box button {
            padding: 12px 16px;
            font-size: 14px;
        }
        
        .filter-buttons {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
            justify-content: center;
            margin-bottom: 15px;
        }
        
        .filter-btn {
            background: #252540;
            color: #888;
            border: 1px solid #444;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            cursor: pointer;
        }
        
        .filter-btn.active {
            background: #4a90d9;
            color: white;
            border-color: #4a90d9;
        }
        
        .filter-btn:hover {
            border-color: #666;
        }
        
        .section-controls {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-bottom: 15px;
        }
        
        .section-controls button {
            background: #2a2a4a;
            border: 1px solid #444;
            color: #888;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
        }
        
        .section-controls button:hover {
            background: #3a3a5a;
            color: #fff;
        }
        
        button {
            background: #4a90d9;
            color: white;
            border: none;
            padding: 14px 28px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 500;
            touch-action: manipulation;
        }
        
        button:disabled {
            background: #555;
        }
        
        .auto-refresh {
            display: flex;
            align-items: center;
            gap: 8px;
            color: #888;
            font-size: 14px;
        }
        
        .auto-refresh select {
            background: #252540;
            color: #fff;
            border: 1px solid #444;
            padding: 12px;
            border-radius: 6px;
            font-size: 16px;
        }
        
        .summary {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-bottom: 25px;
        }
        
        .summary-card {
            background: #252540;
            padding: 15px;
            border-radius: 10px;
            text-align: center;
        }
        
        .summary-card .count {
            font-size: 32px;
            font-weight: bold;
            margin-bottom: 3px;
        }
        
        .summary-card .label {
            font-size: 11px;
            color: #888;
            text-transform: uppercase;
        }
        
        .summary-card.active { border-left: 4px solid #e74c3c; }
        .summary-card.active .count { color: #e74c3c; }
        
        .summary-card.likely { border-left: 4px solid #f39c12; }
        .summary-card.likely .count { color: #f39c12; }
        
        .summary-card.possible { border-left: 4px solid #f1c40f; }
        .summary-card.possible .count { color: #f1c40f; }
        
        .summary-card.none { border-left: 4px solid #2ecc71; }
        .summary-card.none .count { color: #2ecc71; }
        
        .summary-card.residual { border-left: 4px solid #9b59b6; }
        .summary-card.residual .count { color: #9b59b6; }
        
        .section {
            margin-bottom: 25px;
        }
        
        .section-header {
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 1px solid #333;
        }
        
        .section-header h2 {
            font-size: 16px;
            font-weight: 600;
        }
        
        .airport-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .airport-card {
            background: #252540;
            padding: 12px 15px;
            border-radius: 8px;
            cursor: pointer;
            transition: background 0.2s;
            text-decoration: none;
            color: inherit;
            display: block;
        }
        
        .airport-card:hover {
            background: #333355;
        }
        
        .airport-main {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .airport-card .left {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .airport-card .icao {
            font-family: 'Courier New', monospace;
            font-weight: bold;
            font-size: 14px;
            background: #1a1a2e;
            padding: 6px 8px;
            border-radius: 4px;
        }
        
        .airport-card .name {
            font-weight: 500;
            font-size: 14px;
        }
        
        .airport-card .name a {
            color: #7db8eb;
            text-decoration: none;
        }
        
        .airport-card .name a:hover {
            text-decoration: underline;
        }
        
        .airport-card .notam-link {
            margin-left: 8px;
            font-size: 14px;
            opacity: 0.6;
            text-decoration: none;
        }
        
        .airport-card .notam-link:hover {
            opacity: 1;
            text-decoration: none;
        }
        
        .airport-card .weather {
            font-size: 11px;
            color: #888;
            margin-top: 2px;
        }
        
        .airport-card .right {
            text-align: right;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .airport-card .temp {
            text-align: right;
        }
        
        .airport-card .temp-value {
            font-size: 18px;
            font-weight: bold;
        }
        
        .airport-card .temp-f {
            font-size: 11px;
            color: #888;
        }
        
        .trend {
            font-size: 20px;
            font-weight: bold;
        }
        
        .trend.warming { color: #e74c3c; }
        .trend.cooling { color: #3498db; }
        .trend.steady { color: #888; }
        
        .obs-time {
            font-size: 10px;
            color: #888;
            margin-top: 4px;
        }
        
        .obs-time.stale {
            color: #e74c3c;
        }
        
        .flight-rules {
            font-size: 9px;
            padding: 2px 5px;
            border-radius: 3px;
            display: inline-block;
            margin-top: 3px;
        }
        
        .fr-vfr { background: #2ecc71; color: #000; }
        .fr-mvfr { background: #3498db; color: #fff; }
        .fr-ifr { background: #e74c3c; color: #fff; }
        .fr-lifr { background: #9b59b6; color: #fff; }
        
        .history {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid #333;
            display: none;
        }
        
        .history.show {
            display: block;
        }
        
        .history-title {
            font-size: 11px;
            color: #888;
            margin-bottom: 8px;
            text-transform: uppercase;
        }
        
        .history-row {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            padding: 4px 0;
            border-bottom: 1px solid #1a1a2e;
        }
        
        .history-row .time {
            color: #888;
            min-width: 80px;
        }
        
        .history-row .temp {
            font-weight: bold;
            min-width: 100px;
        }
        
        .history-row .wx {
            color: #aaa;
            flex: 1;
            text-align: right;
        }
        
        .loading, .error {
            text-align: center;
            padding: 40px 20px;
        }
        
        .loading .spinner {
            width: 36px;
            height: 36px;
            border: 3px solid #333;
            border-top-color: #4a90d9;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        .error {
            background: #3d1f1f;
            border-radius: 8px;
            color: #ff6b6b;
        }
        
        .error button {
            margin-top: 15px;
            background: #c0392b;
        }
        
        footer {
            text-align: center;
            margin-top: 30px;
            padding-top: 15px;
            border-top: 1px solid #333;
            color: #555;
            font-size: 11px;
        }
        
        .status-msg {
            text-align: center;
            padding: 10px;
            margin-bottom: 15px;
            border-radius: 6px;
            font-size: 13px;
        }
        
        .status-msg.info { background: #1a3a5c; color: #7db8eb; }

        .expand-hint {
            font-size: 10px;
            color: #666;
            margin-top: 4px;
        }
        
        .residual-badge {
            background: #9b59b6;
            color: white;
            font-size: 9px;
            padding: 2px 6px;
            border-radius: 3px;
            margin-left: 8px;
            display: inline-block;
        }
        
        .recent-frozen-note {
            font-size: 10px;
            color: #9b59b6;
            margin-top: 3px;
        }
        
        .badges {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            margin-top: 4px;
        }
        
        .badge {
            font-size: 9px;
            padding: 2px 6px;
            border-radius: 3px;
            display: inline-block;
        }
        
        .badge-hub {
            background: #2c3e50;
            color: #bdc3c7;
        }
        
        .badge-rush {
            background: #d35400;
            color: white;
        }
        
        .badge-gdp {
            background: #c0392b;
            color: white;
            animation: pulse 2s infinite;
        }
        
        .badge-gs {
            background: #8e44ad;
            color: white;
            animation: pulse 1.5s infinite;
        }
        
        .badge-delay {
            background: #e67e22;
            color: white;
        }
        
        .badge-constraint {
            background: #b8860b;
            color: white;
        }
        
        .badge-closure {
            background: #8b4513;
            color: white;
        }
        
        .badge-planned {
            background: #2e8b8b;
            color: white;
        }
        
        .badge-deicing {
            background: #1e90ff;
            color: white;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        
        .traffic-section {
            background: #2d1f1f;
            border: 1px solid #5c3a3a;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 20px;
        }
        
        .traffic-section h3 {
            font-size: 14px;
            color: #e74c3c;
            margin-bottom: 10px;
        }
        
        /* Collapsible section styles */
        .collapsible-section {
            margin-bottom: 15px;
        }
        
        .section-header {
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 12px;
            border-radius: 8px 8px 0 0;
            user-select: none;
        }
        
        .section-header:hover {
            filter: brightness(1.1);
        }
        
        .section-header h3 {
            margin: 0;
            font-size: 14px;
        }
        
        .section-toggle {
            font-size: 12px;
            opacity: 0.7;
        }
        
        .section-content {
            padding: 10px 12px;
            border-radius: 0 0 8px 8px;
        }
        
        .section-content.collapsed {
            display: none;
        }
        
        .collapsible-section.collapsed .section-header {
            border-radius: 8px;
        }
        
        /* Section color themes */
        .section-traffic .section-header { background: #2d1f1f; border: 1px solid #5c3a3a; border-bottom: none; }
        .section-traffic .section-header h3 { color: #e74c3c; }
        .section-traffic .section-content { background: #2d1f1f; border: 1px solid #5c3a3a; border-top: none; }
        .section-traffic.collapsed .section-header { border-bottom: 1px solid #5c3a3a; }
        
        .section-deicing .section-header { background: #1f2d3d; border: 1px solid #3a68a0; border-bottom: none; }
        .section-deicing .section-header h3 { color: #1e90ff; }
        .section-deicing .section-content { background: #1f2d3d; border: 1px solid #3a68a0; border-top: none; }
        .section-deicing.collapsed .section-header { border-bottom: 1px solid #3a68a0; }
        
        .section-constraint .section-header { background: #2d2d1f; border: 1px solid #5c5c3a; border-bottom: none; }
        .section-constraint .section-header h3 { color: #e7c43c; }
        .section-constraint .section-content { background: #2d2d1f; border: 1px solid #5c5c3a; border-top: none; }
        .section-constraint.collapsed .section-header { border-bottom: 1px solid #5c5c3a; }
        
        .section-planned .section-header { background: #1f2d2d; border: 1px solid #3a5c5c; border-bottom: none; }
        .section-planned .section-header h3 { color: #3ce7e7; }
        .section-planned .section-content { background: #1f2d2d; border: 1px solid #3a5c5c; border-top: none; }
        .section-planned.collapsed .section-header { border-bottom: 1px solid #3a5c5c; }
        
        .section-closure .section-header { background: #2d251f; border: 1px solid #5c4a3a; border-bottom: none; }
        .section-closure .section-header h3 { color: #e79c3c; }
        .section-closure .section-content { background: #2d251f; border: 1px solid #5c4a3a; border-top: none; }
        .section-closure.collapsed .section-header { border-bottom: 1px solid #5c4a3a; }
        
        .section-runway .section-header { background: #2d2d1f; border: 1px solid #8b6914; border-bottom: none; }
        .section-runway .section-header h3 { color: #ffa500; }
        .section-runway .section-content { background: #2d2d1f; border: 1px solid #8b6914; border-top: none; }
        .section-runway.collapsed .section-header { border-bottom: 1px solid #8b6914; }
        
        .section-taf .section-header { background: #1f2d3d; border: 1px solid #3a5068; border-bottom: none; }
        .section-taf .section-header h3 { color: #4a90d9; }
        .section-taf .section-content { background: #1f2d3d; border: 1px solid #3a5068; border-top: none; }
        .section-taf.collapsed .section-header { border-bottom: 1px solid #3a5068; }
        
        .section-pirep .section-header { background: #2d1f2d; border: 1px solid #5c3a5c; border-bottom: none; }
        .section-pirep .section-header h3 { color: #d94a90; }
        .section-pirep .section-content { background: #2d1f2d; border: 1px solid #5c3a5c; border-top: none; }
        .section-pirep.collapsed .section-header { border-bottom: 1px solid #5c3a5c; }
        
        .section-airmet .section-header { background: #1f2d2d; border: 1px solid #3a5c5c; border-bottom: none; }
        .section-airmet .section-header h3 { color: #4ad9d9; }
        .section-airmet .section-content { background: #1f2d2d; border: 1px solid #3a5c5c; border-top: none; }
        .section-airmet.collapsed .section-header { border-bottom: 1px solid #3a5c5c; }
        
        .traffic-item {
            font-size: 12px;
            padding: 6px 0;
            border-bottom: 1px solid #3d2a2a;
        }
        
        .traffic-item:last-child {
            border-bottom: none;
        }
        
        .traffic-item .airport {
            font-weight: bold;
            color: #fff;
        }
        
        .traffic-item .program {
            color: #e74c3c;
        }
        
        .traffic-item .reason {
            color: #888;
            font-size: 11px;
        }
        
        .constraint-section {
            background: #2d2d1f;
            border: 1px solid #5c5c3a;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 15px;
        }
        
        .constraint-section h3 {
            font-size: 14px;
            color: #e7c43c;
            margin-bottom: 10px;
        }
        
        .constraint-item {
            font-size: 12px;
            padding: 6px 0;
            border-bottom: 1px solid #3d3d2a;
        }
        
        .constraint-item:last-child {
            border-bottom: none;
        }
        
        .constraint-item .airport {
            font-weight: bold;
            color: #fff;
        }
        
        .constraint-item .constraint-type {
            color: #e7c43c;
        }
        
        .planned-section {
            background: #1f2d2d;
            border: 1px solid #3a5c5c;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 15px;
        }
        
        .planned-section h3 {
            font-size: 14px;
            color: #3ce7e7;
            margin-bottom: 10px;
        }
        
        .planned-item {
            font-size: 12px;
            padding: 6px 0;
            border-bottom: 1px solid #2a3d3d;
            color: #aaa;
        }
        
        .planned-item:last-child {
            border-bottom: none;
        }
        
        .planned-item .airport {
            font-weight: bold;
            color: #fff;
        }
        
        .closure-section {
            background: #2d251f;
            border: 1px solid #5c4a3a;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 15px;
        }
        
        .closure-section h3 {
            font-size: 14px;
            color: #e79c3c;
            margin-bottom: 10px;
        }
        
        .closure-item {
            font-size: 12px;
            padding: 6px 0;
            border-bottom: 1px solid #3d352a;
            color: #aaa;
        }
        
        .closure-item:last-child {
            border-bottom: none;
        }
        
        .closure-item .airport {
            font-weight: bold;
            color: #fff;
        }
        
        .deicing-section {
            background: #1f2d3d;
            border: 1px solid #3a68a0;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 15px;
        }
        
        .deicing-section h3 {
            font-size: 14px;
            color: #1e90ff;
            margin-bottom: 10px;
        }
        
        .deicing-item {
            font-size: 12px;
            padding: 6px 0;
            border-bottom: 1px solid #2a3d5d;
            color: #aaa;
        }
        
        .deicing-item:last-child {
            border-bottom: none;
        }
        
        .deicing-item .airport {
            font-weight: bold;
            color: #fff;
        }
        
        .forecast-section {
            background: #1f2d3d;
            border: 1px solid #3a5068;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 15px;
        }
        
        .forecast-section h3 {
            font-size: 14px;
            color: #4a90d9;
            margin-bottom: 10px;
        }
        
        .forecast-section h3[onclick]:hover {
            color: #7db8eb;
        }
        
        .forecast-note {
            font-size: 11px;
            color: #7db8eb;
            padding: 6px 0;
            border-bottom: 1px solid #2a4058;
        }
        
        .forecast-note:last-child {
            border-bottom: none;
        }
        
        .forecast-note .airport {
            font-weight: bold;
            color: #fff;
        }
        
        .forecast-note .time {
            color: #f39c12;
        }
        
        .pirep-section {
            background: #2d2d1f;
            border: 1px solid #5c5c3a;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 15px;
        }
        
        .pirep-section h3 {
            font-size: 14px;
            color: #f1c40f;
            margin-bottom: 10px;
        }
        
        .pirep-item {
            font-size: 11px;
            color: #ddd;
            padding: 6px 0;
            border-bottom: 1px solid #3d3d2a;
        }
        
        .pirep-item:last-child {
            border-bottom: none;
        }
        
        .pirep-item .intensity {
            font-weight: bold;
            padding: 1px 5px;
            border-radius: 3px;
            margin-right: 5px;
        }
        
        .pirep-item .intensity.light { background: #27ae60; color: #fff; }
        .pirep-item .intensity.moderate { background: #f39c12; color: #000; }
        .pirep-item .intensity.severe { background: #e74c3c; color: #fff; }
        
        .airmet-section {
            background: #2d1f2d;
            border: 1px solid #5c3a5c;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 15px;
        }
        
        .airmet-section h3 {
            font-size: 14px;
            color: #9b59b6;
            margin-bottom: 10px;
        }
        
        .airmet-item {
            font-size: 11px;
            color: #ddd;
            padding: 6px 0;
            border-bottom: 1px solid #3d2a3d;
        }
        
        .airmet-item:last-child {
            border-bottom: none;
        }
        
        .badge-frost {
            background: #2980b9;
            color: white;
        }
        
        .badge-taf-sn {
            background: #8e44ad;
            color: white;
        }
        
        .wind-info {
            font-size: 11px;
            color: #3498db;
            margin-top: 2px;
        }
        
        .wind-info.gusty {
            color: #e67e22;
        }
        
        .wind-info.strong {
            color: #e74c3c;
        }
        
        .vis-info {
            font-size: 10px;
            color: #888;
        }
        
        .vis-info.low {
            color: #e74c3c;
        }
        
        .hot-estimate {
            font-size: 10px;
            color: #1abc9c;
            margin-top: 3px;
            padding: 3px 6px;
            background: #1a3d3d;
            border-radius: 4px;
            display: inline-block;
        }
        
        .hot-estimate.short {
            background: #3d2a1a;
            color: #e67e22;
        }
        
        .hot-estimate.expired {
            background: #3d1a1a;
            color: #e74c3c;
        }
        
        .runway-status {
            font-size: 10px;
            margin-top: 4px;
            padding: 4px 8px;
            border-radius: 4px;
        }
        
        .runway-status.good {
            background: #1a3d1a;
            color: #2ecc71;
        }
        
        .runway-status.limited {
            background: #3d3d1a;
            color: #f1c40f;
        }
        
        .runway-status.critical {
            background: #3d1a1a;
            color: #e74c3c;
            animation: pulse 2s infinite;
        }
        
        .braking-action {
            font-size: 9px;
            padding: 2px 5px;
            border-radius: 3px;
            margin-left: 4px;
        }
        
        .braking-good { background: #27ae60; color: white; }
        .braking-fair { background: #f39c12; color: black; }
        .braking-poor { background: #e67e22; color: white; }
        .braking-nil { background: #c0392b; color: white; }
        
        .notam-section {
            background: #2d2a1f;
            border: 1px solid #5c563a;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 15px;
        }
        
        .notam-section h3 {
            font-size: 14px;
            color: #f39c12;
            margin-bottom: 10px;
        }
        
        .notam-item {
            font-size: 11px;
            padding: 6px 0;
            border-bottom: 1px solid #3d3a2a;
        }
        
        .notam-item:last-child {
            border-bottom: none;
        }
        
        .taf-forecast {
            font-size: 10px;
            color: #9b59b6;
            margin-top: 3px;
        }
        
        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .data-panel {
            background: #252540;
            border-radius: 8px;
            padding: 12px;
        }
        
        .data-panel h3 {
            font-size: 13px;
            margin-bottom: 10px;
            padding-bottom: 8px;
            border-bottom: 1px solid #333;
        }
        
        .data-panel.pireps h3 { color: #f1c40f; }
        .data-panel.airmets h3 { color: #9b59b6; }
        .data-panel.freezing h3 { color: #1abc9c; }
        
        .data-panel h3[onclick]:hover {
            opacity: 0.8;
        }
        
        .compact-list {
            font-size: 11px;
            max-height: 150px;
            overflow-y: auto;
        }
        
        .compact-list .item {
            padding: 4px 0;
            border-bottom: 1px solid #1a1a2e;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>‚úàÔ∏è Airport Deicing Monitor</h1>
            <div class="subtitle">Top 100 US Airports ‚Ä¢ Last 6 METARs</div>
            <div class="timestamp" id="timestamp">Loading...</div>
        </header>
        
        <div class="timezone-box" id="timezoneBox">
            <div class="tz-item zulu">
                <div class="tz-time" id="tz-zulu">--:--</div>
                <div class="tz-label">Zulu</div>
            </div>
            <div class="tz-item">
                <div class="tz-time" id="tz-eastern">--:--</div>
                <div class="tz-label">Eastern</div>
            </div>
            <div class="tz-item">
                <div class="tz-time" id="tz-central">--:--</div>
                <div class="tz-label">Central</div>
            </div>
            <div class="tz-item">
                <div class="tz-time" id="tz-mountain">--:--</div>
                <div class="tz-label">Mountain</div>
            </div>
            <div class="tz-item">
                <div class="tz-time" id="tz-pacific">--:--</div>
                <div class="tz-label">Pacific</div>
            </div>
        </div>
        
        <div class="controls">
            <div class="search-box">
                <input type="text" id="searchInput" placeholder="Search airport (KORD, Chicago...)" oninput="filterAirports()" onkeydown="if(event.key==='Enter')filterAirports()">
                <button onclick="clearSearch()">‚úï</button>
            </div>
        </div>
        
        <div class="filter-buttons">
            <button class="filter-btn active" data-region="all" onclick="setRegionFilter('all')">All</button>
            <button class="filter-btn" data-region="northeast" onclick="setRegionFilter('northeast')">Northeast</button>
            <button class="filter-btn" data-region="midwest" onclick="setRegionFilter('midwest')">Midwest</button>
            <button class="filter-btn" data-region="south" onclick="setRegionFilter('south')">South</button>
            <button class="filter-btn" data-region="west" onclick="setRegionFilter('west')">West</button>
        </div>
        
        <div class="section-controls">
            <button onclick="expandAllSections()">üìÇ Expand All</button>
            <button onclick="collapseAllSections()">üìÅ Collapse All</button>
        </div>
        
        <div class="controls">
            <button id="refreshBtn" onclick="fetchData()">üîÑ Refresh</button>
            <div class="auto-refresh">
                <span>Auto:</span>
                <select id="autoRefresh" onchange="setAutoRefresh()">
                    <option value="0">Off</option>
                    <option value="5">5m</option>
                    <option value="15">15m</option>
                    <option value="30" selected>30m</option>
                </select>
            </div>
        </div>
        
        <div id="content">
            <div class="loading">
                <div class="spinner"></div>
                <div>Fetching METAR data for 100 airports...</div>
            </div>
        </div>
        
        <footer>
            Data: Aviation Weather Center<br>
            Tap airport to see history ‚Ä¢ Tap city name to open full METAR
        </footer>
    </div>

    <script>
        // Top 100 US airports by passenger volume
        const AIRPORTS = [
            // Top 50
            'KATL', 'KLAX', 'KORD', 'KDFW', 'KDEN', 'KJFK', 'KSFO', 'KLAS', 'KMCO', 'KSEA',
            'KMIA', 'KPHX', 'KEWR', 'KIAH', 'KBOS', 'KMSP', 'KDTW', 'KFLL', 'KPHL', 'KLGA',
            'KBWI', 'KSLC', 'KDCA', 'KSAN', 'KTPA', 'KAUS', 'KIAD', 'KMDW', 'KHNL', 'KSTL',
            'KBNA', 'KOAK', 'KSMF', 'KSJC', 'KRDU', 'KMCI', 'KCLE', 'KPIT', 'KCLT', 'KPDX',
            'KIND', 'KCVG', 'KMSY', 'KSAT', 'KMKE', 'KBUF', 'KPBI', 'KABQ', 'KONT', 'KRSW',
            // 51-75
            'KBUR', 'KOMA', 'KRIC', 'KBDL', 'KSNA', 'KJAN', 'KCHS', 'KJAX', 'KORF', 'KANC',
            'KLIT', 'KELP', 'KTUS', 'KOKC', 'KTUL', 'KGRR', 'KDSM', 'KDAY', 'KSYR', 'KPVD',
            'KALB', 'KGSO', 'KPWM', 'KBTV', 'KROC',
            // 76-100
            'KBHM', 'KLEX', 'KSDF', 'KCMH', 'KCOS', 'KBOI', 'KFSD', 'KICT', 'KMSN', 'KLBB',
            'KFAR', 'KBIS', 'KDLH', 'KERI', 'KBGR', 'KAVL', 'KMYR', 'KSAV', 'KPNS', 'KFWA',
            'KLNK', 'KSGF', 'KXNA', 'KCRP', 'KABI'
        ];

        const AIRPORT_NAMES = {
            // Top 50
            'KATL': 'Atlanta', 'KLAX': 'Los Angeles', 'KORD': 'Chicago ORD',
            'KDFW': 'Dallas/Fort Worth', 'KDEN': 'Denver', 'KJFK': 'New York JFK',
            'KSFO': 'San Francisco', 'KLAS': 'Las Vegas', 'KMCO': 'Orlando',
            'KSEA': 'Seattle', 'KMIA': 'Miami', 'KPHX': 'Phoenix', 'KEWR': 'Newark',
            'KIAH': 'Houston IAH', 'KBOS': 'Boston', 'KMSP': 'Minneapolis',
            'KDTW': 'Detroit', 'KFLL': 'Fort Lauderdale', 'KPHL': 'Philadelphia',
            'KLGA': 'New York LGA', 'KBWI': 'Baltimore', 'KSLC': 'Salt Lake City',
            'KDCA': 'Washington DCA', 'KSAN': 'San Diego', 'KTPA': 'Tampa',
            'KAUS': 'Austin', 'KIAD': 'Washington IAD', 'KMDW': 'Chicago MDW',
            'KHNL': 'Honolulu', 'KSTL': 'St. Louis', 'KBNA': 'Nashville',
            'KOAK': 'Oakland', 'KSMF': 'Sacramento', 'KSJC': 'San Jose',
            'KRDU': 'Raleigh-Durham', 'KMCI': 'Kansas City', 'KCLE': 'Cleveland',
            'KPIT': 'Pittsburgh', 'KCLT': 'Charlotte', 'KPDX': 'Portland OR',
            'KIND': 'Indianapolis', 'KCVG': 'Cincinnati', 'KMSY': 'New Orleans',
            'KSAT': 'San Antonio', 'KMKE': 'Milwaukee', 'KBUF': 'Buffalo',
            'KPBI': 'West Palm Beach', 'KABQ': 'Albuquerque', 'KONT': 'Ontario CA',
            'KRSW': 'Fort Myers',
            // 51-75
            'KBUR': 'Burbank', 'KOMA': 'Omaha', 'KRIC': 'Richmond',
            'KBDL': 'Hartford', 'KSNA': 'Orange County', 'KJAN': 'Jackson MS',
            'KCHS': 'Charleston', 'KJAX': 'Jacksonville', 'KORF': 'Norfolk',
            'KANC': 'Anchorage', 'KLIT': 'Little Rock', 'KELP': 'El Paso',
            'KTUS': 'Tucson', 'KOKC': 'Oklahoma City', 'KTUL': 'Tulsa',
            'KGRR': 'Grand Rapids', 'KDSM': 'Des Moines', 'KDAY': 'Dayton',
            'KSYR': 'Syracuse', 'KPVD': 'Providence', 'KALB': 'Albany',
            'KGSO': 'Greensboro', 'KPWM': 'Portland ME', 'KBTV': 'Burlington VT',
            'KROC': 'Rochester',
            // 76-100
            'KBHM': 'Birmingham', 'KLEX': 'Lexington', 'KSDF': 'Louisville',
            'KCMH': 'Columbus OH', 'KCOS': 'Colorado Springs', 'KBOI': 'Boise',
            'KFSD': 'Sioux Falls', 'KICT': 'Wichita', 'KMSN': 'Madison',
            'KLBB': 'Lubbock', 'KFAR': 'Fargo', 'KBIS': 'Bismarck',
            'KDLH': 'Duluth', 'KERI': 'Erie', 'KBGR': 'Bangor',
            'KAVL': 'Asheville', 'KMYR': 'Myrtle Beach', 'KSAV': 'Savannah',
            'KPNS': 'Pensacola', 'KFWA': 'Fort Wayne', 'KLNK': 'Lincoln',
            'KSGF': 'Springfield MO', 'KXNA': 'NW Arkansas', 'KCRP': 'Corpus Christi',
            'KABI': 'Abilene'
        };

        // Timezone offsets from UTC (standard time - will need DST adjustment)
        const AIRPORT_TIMEZONES = {
            // Eastern (-5 standard, -4 DST)
            'KATL': 'America/New_York', 'KJFK': 'America/New_York', 'KMCO': 'America/New_York',
            'KMIA': 'America/New_York', 'KEWR': 'America/New_York', 'KBOS': 'America/New_York',
            'KDTW': 'America/New_York', 'KFLL': 'America/New_York', 'KPHL': 'America/New_York',
            'KLGA': 'America/New_York', 'KBWI': 'America/New_York', 'KDCA': 'America/New_York',
            'KTPA': 'America/New_York', 'KIAD': 'America/New_York', 'KRDU': 'America/New_York',
            'KCLE': 'America/New_York', 'KPIT': 'America/New_York', 'KCLT': 'America/New_York',
            'KIND': 'America/New_York', 'KCVG': 'America/New_York', 'KBUF': 'America/New_York',
            'KPBI': 'America/New_York', 'KRSW': 'America/New_York', 'KRIC': 'America/New_York',
            'KBDL': 'America/New_York', 'KCHS': 'America/New_York', 'KJAX': 'America/New_York',
            'KORF': 'America/New_York', 'KDAY': 'America/New_York', 'KSYR': 'America/New_York',
            'KPVD': 'America/New_York', 'KALB': 'America/New_York', 'KGSO': 'America/New_York',
            'KROC': 'America/New_York', 'KBHM': 'America/New_York', 'KLEX': 'America/New_York',
            'KSDF': 'America/New_York', 'KCMH': 'America/New_York', 'KERI': 'America/New_York',
            'KBGR': 'America/New_York', 'KAVL': 'America/New_York', 'KMYR': 'America/New_York',
            'KSAV': 'America/New_York', 'KPNS': 'America/New_York', 'KFWA': 'America/New_York',
            'KPWM': 'America/New_York', 'KBTV': 'America/New_York',
            // Central (-6 standard, -5 DST)
            'KORD': 'America/Chicago', 'KDFW': 'America/Chicago', 'KIAH': 'America/Chicago',
            'KMSP': 'America/Chicago', 'KMDW': 'America/Chicago', 'KSTL': 'America/Chicago',
            'KBNA': 'America/Chicago', 'KMCI': 'America/Chicago', 'KMSY': 'America/Chicago',
            'KSAT': 'America/Chicago', 'KMKE': 'America/Chicago', 'KAUS': 'America/Chicago',
            'KOMA': 'America/Chicago', 'KJAN': 'America/Chicago', 'KLIT': 'America/Chicago',
            'KELP': 'America/Chicago', 'KOKC': 'America/Chicago', 'KTUL': 'America/Chicago',
            'KGRR': 'America/Chicago', 'KDSM': 'America/Chicago', 'KFSD': 'America/Chicago',
            'KICT': 'America/Chicago', 'KMSN': 'America/Chicago', 'KLBB': 'America/Chicago',
            'KFAR': 'America/Chicago', 'KBIS': 'America/Chicago', 'KDLH': 'America/Chicago',
            'KLNK': 'America/Chicago', 'KSGF': 'America/Chicago', 'KXNA': 'America/Chicago',
            'KCRP': 'America/Chicago', 'KABI': 'America/Chicago',
            // Mountain (-7 standard, -6 DST)
            'KDEN': 'America/Denver', 'KPHX': 'America/Phoenix', 'KSLC': 'America/Denver',
            'KABQ': 'America/Denver', 'KTUS': 'America/Denver', 'KCOS': 'America/Denver',
            'KBOI': 'America/Boise',
            // Pacific (-8 standard, -7 DST)
            'KLAX': 'America/Los_Angeles', 'KSFO': 'America/Los_Angeles', 'KLAS': 'America/Los_Angeles',
            'KSEA': 'America/Los_Angeles', 'KSAN': 'America/Los_Angeles', 'KPDX': 'America/Los_Angeles',
            'KOAK': 'America/Los_Angeles', 'KSMF': 'America/Los_Angeles', 'KSJC': 'America/Los_Angeles',
            'KONT': 'America/Los_Angeles', 'KBUR': 'America/Los_Angeles', 'KSNA': 'America/Los_Angeles',
            // Alaska/Hawaii
            'KANC': 'America/Anchorage', 'KHNL': 'Pacific/Honolulu'
        };

        // Major airline hubs
        const HUB_AIRPORTS = {
            'KATL': ['Delta'],
            'KLAX': ['American', 'Delta', 'United'],
            'KORD': ['American', 'United'],
            'KDFW': ['American'],
            'KDEN': ['United', 'Southwest', 'Frontier'],
            'KJFK': ['JetBlue', 'Delta'],
            'KSFO': ['United'],
            'KLAS': ['Southwest', 'Spirit'],
            'KMCO': ['Southwest', 'JetBlue'],
            'KSEA': ['Alaska', 'Delta'],
            'KMIA': ['American'],
            'KPHX': ['American', 'Southwest'],
            'KEWR': ['United'],
            'KIAH': ['United'],
            'KBOS': ['JetBlue'],
            'KMSP': ['Delta', 'Sun Country'],
            'KDTW': ['Delta'],
            'KCLT': ['American'],
            'KSLC': ['Delta'],
            'KBWI': ['Southwest'],
            'KMDW': ['Southwest'],
            'KBNA': ['Southwest'],
            'KAUS': ['Southwest'],
            'KFLL': ['Spirit', 'JetBlue']
        };

        // Traffic management data
        let trafficPrograms = {};
        
        // Additional aviation data
        let tafData = {};
        let pirepData = [];
        let airmetData = [];
        let freezingLevelData = null;
        let notamData = {};
        let currentSearchTerm = '';
        let currentRegionFilter = 'all';

        // Runways >= 5000ft per airport (approximate data for top 100)
        const RUNWAY_DATA = {
            'KATL': 5, 'KLAX': 4, 'KORD': 8, 'KDFW': 7, 'KDEN': 6, 'KJFK': 4, 'KSFO': 4, 'KLAS': 4, 'KMCO': 4, 'KSEA': 3,
            'KMIA': 4, 'KPHX': 3, 'KEWR': 3, 'KIAH': 5, 'KBOS': 4, 'KMSP': 4, 'KDTW': 6, 'KFLL': 2, 'KPHL': 4, 'KLGA': 2,
            'KBWI': 3, 'KSLC': 4, 'KDCA': 3, 'KSAN': 1, 'KTPA': 3, 'KAUS': 2, 'KIAD': 4, 'KMDW': 5, 'KHNL': 4, 'KSTL': 4,
            'KBNA': 4, 'KOAK': 4, 'KSMF': 2, 'KSJC': 2, 'KRDU': 3, 'KMCI': 3, 'KCLE': 3, 'KPIT': 4, 'KCLT': 4, 'KPDX': 3,
            'KIND': 3, 'KCVG': 4, 'KMSY': 2, 'KSAT': 3, 'KMKE': 5, 'KBUF': 2, 'KPBI': 3, 'KABQ': 3, 'KONT': 2, 'KRSW': 2,
            'KBUR': 1, 'KOMA': 3, 'KRIC': 2, 'KBDL': 2, 'KSNA': 1, 'KJAN': 2, 'KCHS': 2, 'KJAX': 2, 'KORF': 2, 'KANC': 3,
            'KLIT': 2, 'KELP': 3, 'KTUS': 3, 'KOKC': 3, 'KTUL': 3, 'KGRR': 2, 'KDSM': 2, 'KDAY': 3, 'KSYR': 2, 'KPVD': 2,
            'KALB': 2, 'KGSO': 2, 'KPWM': 2, 'KBTV': 2, 'KROC': 2, 'KBHM': 3, 'KLEX': 2, 'KSDF': 3, 'KCMH': 3, 'KCOS': 3,
            'KBOI': 2, 'KFSD': 2, 'KICT': 3, 'KMSN': 2, 'KLBB': 2, 'KFAR': 2, 'KBIS': 2, 'KDLH': 2, 'KERI': 2, 'KBGR': 2,
            'KAVL': 1, 'KMYR': 2, 'KSAV': 2, 'KPNS': 2, 'KFWA': 2, 'KLNK': 2, 'KSGF': 2, 'KXNA': 2, 'KCRP': 2, 'KABI': 2
        };

        // Regional groupings
        const AIRPORT_REGIONS = {
            northeast: ['KJFK', 'KEWR', 'KLGA', 'KBOS', 'KPHL', 'KBWI', 'KDCA', 'KIAD', 'KBUF', 'KBDL', 'KSYR', 'KPVD', 'KALB', 'KPWM', 'KBTV', 'KROC', 'KERI', 'KBGR', 'KPIT'],
            midwest: ['KORD', 'KMDW', 'KDTW', 'KMSP', 'KCLE', 'KIND', 'KCVG', 'KMKE', 'KSTL', 'KMCI', 'KOMA', 'KGRR', 'KDSM', 'KDAY', 'KCMH', 'KFSD', 'KICT', 'KMSN', 'KFAR', 'KBIS', 'KDLH', 'KFWA', 'KLNK', 'KSGF'],
            south: ['KATL', 'KMIA', 'KFLL', 'KTPA', 'KMCO', 'KIAH', 'KDFW', 'KAUS', 'KSAT', 'KMSY', 'KBNA', 'KCLT', 'KRDU', 'KRIC', 'KJAN', 'KCHS', 'KJAX', 'KORF', 'KLIT', 'KELP', 'KOKC', 'KTUL', 'KGSO', 'KBHM', 'KLEX', 'KSDF', 'KAVL', 'KMYR', 'KSAV', 'KPNS', 'KXNA', 'KCRP', 'KABI', 'KPBI', 'KRSW', 'KLBB'],
            west: ['KLAX', 'KSFO', 'KLAS', 'KSEA', 'KPHX', 'KDEN', 'KSLC', 'KSAN', 'KPDX', 'KOAK', 'KSMF', 'KSJC', 'KABQ', 'KONT', 'KBUR', 'KSNA', 'KTUS', 'KCOS', 'KBOI', 'KANC', 'KHNL']
        };

        const FROZEN_PRECIP = ['SN', 'FZRA', 'FZFG', 'FZDZ', 'PL', 'GR', 'GS', 'IC', 'SG'];
        const ALL_PRECIP = [...FROZEN_PRECIP, 'RA', 'DZ', 'SHRA', 'TSRA', 'SHSN'];

        let refreshInterval = null;

        const CORS_PROXIES = [
            (url) => `https://api.allorigins.win/raw?url=${encodeURIComponent(url)}`,
            (url) => `https://corsproxy.io/?${encodeURIComponent(url)}`,
            (url) => url
        ];

        function parseMetar(metar) {
            if (!metar || metar.length < 10) return null;

            const result = {
                raw: metar,
                icao: null,
                temp_c: null,
                weather: [],
                visibility: 10,
                visibility_text: '',
                ceiling: null,
                flight_rules: 'VFR',
                frozen_precip: false,
                has_precip: false,
                has_moisture: false,
                obs_time: null,
                wind_dir: null,
                wind_speed: null,
                wind_gust: null,
                wind_variable: false
            };

            const icaoMatch = metar.match(/\b(K[A-Z]{3})\b/);
            if (icaoMatch) result.icao = icaoMatch[1];
            else return null;

            // Extract observation time (format: 031852Z = day 03, 18:52 UTC)
            const timeMatch = metar.match(/\b(\d{2})(\d{2})(\d{2})Z\b/);
            if (timeMatch) {
                const day = parseInt(timeMatch[1]);
                const hour = parseInt(timeMatch[2]);
                const min = parseInt(timeMatch[3]);
                const now = new Date();
                const obsDate = new Date(Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), day, hour, min));
                // Handle month rollover
                if (obsDate > now) {
                    obsDate.setUTCMonth(obsDate.getUTCMonth() - 1);
                }
                result.obs_time = obsDate;
            }

            // Extract wind data (format: 27015G25KT or VRB05KT)
            const windMatch = metar.match(/\b(VRB|\d{3})(\d{2,3})(G(\d{2,3}))?KT\b/);
            if (windMatch) {
                if (windMatch[1] === 'VRB') {
                    result.wind_variable = true;
                    result.wind_dir = 'VRB';
                } else {
                    result.wind_dir = parseInt(windMatch[1]);
                }
                result.wind_speed = parseInt(windMatch[2]);
                if (windMatch[4]) {
                    result.wind_gust = parseInt(windMatch[4]);
                }
            }

            const tempMatch = metar.match(/\s(M?\d{2})\/(M?\d{2})\s/);
            if (tempMatch) {
                const tempStr = tempMatch[1];
                result.temp_c = tempStr.startsWith('M') ? -parseInt(tempStr.slice(1)) : parseInt(tempStr);
            }

            // Parse visibility with text
            const visMatch = metar.match(/\s(\d+)\s?SM\b/);
            const visFracMatch = metar.match(/\s(\d+)?\s?(\d\/\d+)\s?SM\b/);
            const visP6Match = metar.match(/\bP6SM\b/);
            
            if (visP6Match) {
                result.visibility = 7;
                result.visibility_text = 'P6SM';
            } else if (visFracMatch) {
                const whole = visFracMatch[1] ? parseInt(visFracMatch[1]) : 0;
                const frac = visFracMatch[2];
                const [num, den] = frac.split('/').map(Number);
                result.visibility = whole + (num / den);
                result.visibility_text = visFracMatch[0].trim();
            } else if (visMatch) {
                result.visibility = parseInt(visMatch[1]);
                result.visibility_text = visMatch[1] + 'SM';
            }

            for (const code of ALL_PRECIP) {
                if (metar.includes(code)) {
                    result.weather.push(code);
                    result.has_precip = true;
                    if (FROZEN_PRECIP.includes(code)) result.frozen_precip = true;
                }
            }

            if (metar.match(/\sBR\b/) || metar.match(/\sFG\b/)) {
                result.has_moisture = true;
                if (metar.includes(' BR')) result.weather.push('BR');
                if (metar.includes(' FG')) result.weather.push('FG');
            }

            const cloudMatches = metar.matchAll(/(BKN|OVC)(\d{3})/g);
            for (const match of cloudMatches) {
                const alt = parseInt(match[2]) * 100;
                if (result.ceiling === null || alt < result.ceiling) {
                    result.ceiling = alt;
                }
            }

            const vis = result.visibility;
            const ceil = result.ceiling;
            if ((ceil !== null && ceil < 500) || vis < 1) result.flight_rules = 'LIFR';
            else if ((ceil !== null && ceil < 1000) || vis < 3) result.flight_rules = 'IFR';
            else if ((ceil !== null && ceil < 3000) || vis < 5) result.flight_rules = 'MVFR';

            return result;
        }

        function categorize(parsed) {
            if (parsed.temp_c === null) return 'unknown';
            
            const temp = parsed.temp_c;
            
            if (temp <= 0 && parsed.frozen_precip) return 'active';
            if (parsed.weather.includes('FZRA') || parsed.weather.includes('FZDZ')) return 'active';
            
            // Check for residual - recent frozen precip in history but not current
            if (temp <= 3 && !parsed.frozen_precip && parsed.had_recent_frozen) return 'residual';
            
            if (temp <= 0 && parsed.has_precip) return 'likely';
            if (temp <= 0 && parsed.has_moisture) return 'likely';
            if (temp <= 0) return 'possible';
            if (temp <= 3 && parsed.has_precip) return 'marginal';
            return 'none';
        }
        
        function checkRecentFrozen(history) {
            if (!history || history.length < 2) return { hadFrozen: false, lastFrozenTime: null, frozenTypes: [] };
            
            // Skip the first (current) observation, check the rest
            const pastObs = history.slice(1);
            const frozenTypes = new Set();
            let lastFrozenTime = null;
            
            for (const obs of pastObs) {
                for (const wx of obs.weather) {
                    if (FROZEN_PRECIP.includes(wx)) {
                        frozenTypes.add(wx);
                        if (!lastFrozenTime && obs.obs_time) {
                            lastFrozenTime = obs.obs_time;
                        }
                    }
                }
            }
            
            return {
                hadFrozen: frozenTypes.size > 0,
                lastFrozenTime: lastFrozenTime,
                frozenTypes: Array.from(frozenTypes)
            };
        }

        function getLocalTime(icao) {
            const tz = AIRPORT_TIMEZONES[icao];
            if (!tz) return null;
            
            try {
                const now = new Date();
                const localTime = new Date(now.toLocaleString('en-US', { timeZone: tz }));
                return localTime;
            } catch (e) {
                return null;
            }
        }

        function getRushStatus(icao) {
            const localTime = getLocalTime(icao);
            if (!localTime) return null;
            
            const hour = localTime.getHours();
            const dayOfWeek = localTime.getDay(); // 0 = Sunday
            
            // Weekends have different patterns
            const isWeekend = dayOfWeek === 0 || dayOfWeek === 6;
            
            if (isWeekend) {
                // Weekend patterns are less pronounced
                if (hour >= 7 && hour < 11) return 'AM RUSH';
                if (hour >= 15 && hour < 19) return 'PM RUSH';
            } else {
                // Weekday patterns
                if (hour >= 6 && hour < 9) return 'AM RUSH';
                if (hour >= 16 && hour < 19) return 'PM RUSH';
            }
            
            return null;
        }

        function getHubInfo(icao) {
            return HUB_AIRPORTS[icao] || null;
        }

        async function fetchTrafficManagement() {
            // FAA Airport Status API
            const url = 'https://nasstatus.faa.gov/api/airport-status-information';
            
            try {
                const text = await tryFetch(url);
                const data = JSON.parse(text);
                
                trafficPrograms = {};
                
                if (data && Array.isArray(data)) {
                    for (const item of data) {
                        const icao = 'K' + item.airportId;
                        if (AIRPORTS.includes(icao)) {
                            const programs = [];
                            
                            // Ground Delay Programs
                            if (item.groundDelay && item.groundDelay.status === true) {
                                programs.push({
                                    type: 'GDP',
                                    avgDelay: item.groundDelay.avgDelay || 'N/A',
                                    reason: item.groundDelay.reason || ''
                                });
                            }
                            
                            // Ground Stops
                            if (item.groundStop && item.groundStop.status === true) {
                                programs.push({
                                    type: 'GROUND STOP',
                                    endTime: item.groundStop.endTime || 'TBD',
                                    reason: item.groundStop.reason || ''
                                });
                            }
                            
                            // Arrival/Departure delays
                            if (item.arrivalDelay && item.arrivalDelay.status === true) {
                                programs.push({
                                    type: 'ARR DELAY',
                                    minDelay: item.arrivalDelay.minDelay || '',
                                    maxDelay: item.arrivalDelay.maxDelay || '',
                                    reason: item.arrivalDelay.reason || ''
                                });
                            }
                            
                            if (item.departureDelay && item.departureDelay.status === true) {
                                programs.push({
                                    type: 'DEP DELAY',
                                    minDelay: item.departureDelay.minDelay || '',
                                    maxDelay: item.departureDelay.maxDelay || '',
                                    reason: item.departureDelay.reason || ''
                                });
                            }
                            
                            // Closures
                            if (item.closure && item.closure.status === true) {
                                programs.push({
                                    type: 'CLOSED',
                                    reason: item.closure.reason || ''
                                });
                            }
                            
                            // Deicing programs
                            if (item.deicing && item.deicing.status === true) {
                                programs.push({
                                    type: 'DEICING',
                                    startTime: item.deicing.startTime || '',
                                    reason: 'Formal deicing program active'
                                });
                            }
                            
                            if (programs.length > 0) {
                                trafficPrograms[icao] = programs;
                            }
                        }
                    }
                }
                
                console.log('Traffic programs loaded:', Object.keys(trafficPrograms).length, 'airports affected');
                
            } catch (e) {
                console.log('Traffic management fetch failed:', e.message);
                // Non-fatal - we'll just not show traffic data
            }
        }

        // FAA ATCSCC Advisory Database - more detailed info on GDPs, constraints, runway closures
        let faaAdvisoryData = {
            terminalActive: {},      // Active GDPs/Ground Stops with end times
            terminalPlanned: {},     // Planned/possible ground stops
            terminalConstraints: {}, // Weather constraints (TSTMS, LOW CIGS, etc.)
            runwayClosures: {},      // Runway/taxiway closures
            enRouteConstraints: [],  // En route issues
            rawText: ''
        };

        async function fetchFAAAdvisory() {
            const url = 'https://www.fly.faa.gov/adv/adv_spt';
            
            try {
                const text = await tryFetch(url, 0, 100);
                
                if (!text || text.length < 100) {
                    console.log('FAA Advisory: No data returned');
                    return;
                }
                
                faaAdvisoryData.rawText = text;
                
                // Parse TERMINAL ACTIVE section (active GDPs/Ground Stops)
                const terminalActiveMatch = text.match(/TERMINAL ACTIVE:\s*([\s\S]*?)(?=TERMINAL PLANNED:|EN ROUTE|$)/i);
                if (terminalActiveMatch) {
                    const lines = terminalActiveMatch[1].trim().split('\n');
                    for (const line of lines) {
                        // Format: UNTIL 1829 -SEA GROUND DELAY PROGRAM
                        const match = line.match(/UNTIL\s+(\d{4})\s+-([A-Z]{3})\s+(.+)/i);
                        if (match) {
                            const endTime = match[1];
                            const airport = 'K' + match[2];
                            const program = match[3].trim();
                            
                            if (!faaAdvisoryData.terminalActive[airport]) {
                                faaAdvisoryData.terminalActive[airport] = [];
                            }
                            faaAdvisoryData.terminalActive[airport].push({
                                endTime: endTime,
                                program: program
                            });
                        }
                    }
                }
                
                // Parse TERMINAL PLANNED section
                const terminalPlannedMatch = text.match(/TERMINAL PLANNED:\s*([\s\S]*?)(?=EN ROUTE|CDRS|$)/i);
                if (terminalPlannedMatch) {
                    const lines = terminalPlannedMatch[1].trim().split('\n');
                    for (const line of lines) {
                        // Format: UNTIL 0200 -MIA/FLL GROUND STOP POSSIBLE
                        const match = line.match(/UNTIL\s+(\d{4})\s+-([A-Z\/]+)\s+(.+)/i);
                        if (match) {
                            const airports = match[2].split('/');
                            const program = match[3].trim();
                            
                            for (const apt of airports) {
                                const icao = 'K' + apt;
                                if (!faaAdvisoryData.terminalPlanned[icao]) {
                                    faaAdvisoryData.terminalPlanned[icao] = [];
                                }
                                faaAdvisoryData.terminalPlanned[icao].push(program);
                            }
                        }
                    }
                }
                
                // Parse TERMINAL CONSTRAINTS section
                const constraintsMatch = text.match(/TERMINAL CONSTRAINTS:\s*([\s\S]*?)(?=TERMINAL ACTIVE:|TERMINAL PLANNED:|EN ROUTE|$)/i);
                if (constraintsMatch) {
                    const lines = constraintsMatch[1].trim().split('\n');
                    for (const line of lines) {
                        // Format: FLL/MIA - TSTMS or SFO/SEA - LOW CEILINGS
                        const match = line.match(/([A-Z\/]+)\s+-\s+(.+)/i);
                        if (match) {
                            const airports = match[1].split('/');
                            const constraint = match[2].trim();
                            
                            for (const apt of airports) {
                                const icao = 'K' + apt;
                                faaAdvisoryData.terminalConstraints[icao] = constraint;
                            }
                        }
                    }
                }
                
                // Parse RUNWAY/EQUIPMENT section
                const runwayMatch = text.match(/RUNWAY\/EQUIPMENT.*?:\s*([\s\S]*?)(?=AIRSPACE FLOW|PLANNED LAUNCH|FLIGHT CHECK|VIP|NEXT PLANNING|$)/i);
                if (runwayMatch) {
                    const lines = runwayMatch[1].trim().split('\n');
                    for (const line of lines) {
                        // Format: DEN - TWY CONSTRUCTION UNTIL 10/05/2025 2359Z
                        // or: ORD - EAST TAXIWAY CONSTRUCTION UNTIL 10/23/25
                        const match = line.match(/^([A-Z]{3})\s+-\s+(.+)/i);
                        if (match) {
                            const icao = 'K' + match[1];
                            const issue = match[2].trim();
                            
                            if (!faaAdvisoryData.runwayClosures[icao]) {
                                faaAdvisoryData.runwayClosures[icao] = [];
                            }
                            faaAdvisoryData.runwayClosures[icao].push(issue);
                        }
                    }
                }
                
                // Parse STAFFING TRIGGER section
                const staffingMatch = text.match(/STAFFING TRIGGER\(S\):\s*([\s\S]*?)(?=TERMINAL|EN ROUTE|$)/i);
                if (staffingMatch && !staffingMatch[1].includes('NONE')) {
                    const lines = staffingMatch[1].trim().split('\n');
                    for (const line of lines) {
                        // Format: UNTIL 2130 -ZAB SOUTHWEST AREA or 0000 - 0500 -C90 TRACON
                        const match = line.match(/([A-Z]\d{2}|[A-Z]{3})/i);
                        if (match) {
                            // Store staffing issues - these affect capacity
                            const facility = match[1];
                            if (!faaAdvisoryData.staffingTriggers) {
                                faaAdvisoryData.staffingTriggers = [];
                            }
                            faaAdvisoryData.staffingTriggers.push(line.trim());
                        }
                    }
                }
                
                const activeCount = Object.keys(faaAdvisoryData.terminalActive).length;
                const constraintCount = Object.keys(faaAdvisoryData.terminalConstraints).length;
                const runwayCount = Object.keys(faaAdvisoryData.runwayClosures).length;
                
                console.log(`FAA Advisory loaded: ${activeCount} active programs, ${constraintCount} constraints, ${runwayCount} runway issues`);
                
            } catch (e) {
                console.error('FAA Advisory fetch failed:', e.message);
            }
        }

        async function fetchTAFs() {
            try {
                const ids = AIRPORTS.join(',');
                const url = `https://aviationweather.gov/api/data/taf?ids=${ids}&format=raw`;
                console.log('Fetching TAFs from:', url);
                const text = await tryFetch(url, 0, 20);
                
                tafData = {};
                
                if (!text || text.length < 30) {
                    console.log('TAF: No data or empty response');
                    return;
                }
                
                console.log('TAF response length:', text.length);
                
                // TAFs can be separated by double newlines or be on single lines
                // Split by TAF keyword to handle both formats
                const tafParts = text.split(/(?=TAF\s+K[A-Z]{3})/);
                console.log('TAF parts found:', tafParts.length);
                
                for (const taf of tafParts) {
                    if (!taf.trim()) continue;
                    
                    const icaoMatch = taf.match(/TAF\s+(K[A-Z]{3})/);
                    if (!icaoMatch) continue;
                    
                    const icao = icaoMatch[1];
                    const forecasts = [];
                    
                    // Look for frozen precip anywhere in the TAF
                    // Match patterns like: SN, -SN, +SN, FZRA, -FZRA, etc.
                    const frozenPattern = /\b(\+|-)?((SN)|(FZRA)|(FZDZ)|(PL)|(FZFG)|(GS)|(GR))\b/g;
                    const matches = taf.matchAll(frozenPattern);
                    
                    for (const match of matches) {
                        const wx = match[0].replace(/^[+-]/, ''); // Remove intensity prefix
                        // Get context around the match (find the time group)
                        const beforeMatch = taf.substring(0, match.index);
                        const timeMatch = beforeMatch.match(/(FM\d{6}|TEMPO\s+\d{4}\/\d{4}|BECMG\s+\d{4}\/\d{4}|\d{4}\/\d{4})\s*[^\n]*$/);
                        
                        forecasts.push({
                            raw: timeMatch ? timeMatch[0].substring(0, 30) + ' ' + wx : wx,
                            wx: wx
                        });
                    }
                    
                    // Deduplicate forecasts
                    const uniqueForecasts = [];
                    const seen = new Set();
                    for (const fc of forecasts) {
                        if (!seen.has(fc.wx)) {
                            seen.add(fc.wx);
                            uniqueForecasts.push(fc);
                        }
                    }
                    
                    if (uniqueForecasts.length > 0 || taf.length > 20) {
                        tafData[icao] = {
                            raw: taf.substring(0, 500),
                            frozenForecasts: uniqueForecasts,
                            warmingTime: null
                        };
                    }
                }
                
                // Count airports with frozen precip forecasts
                let frozenCount = 0;
                for (const icao in tafData) {
                    if (tafData[icao].frozenForecasts.length > 0) frozenCount++;
                }
                console.log('TAFs loaded:', Object.keys(tafData).length, 'airports,', frozenCount, 'with frozen precip');
                
            } catch (e) {
                console.error('TAF fetch failed:', e.message);
                tafData = {};
            }
        }

        async function fetchPIREPs() {
            try {
                // Get all PIREPs from last 2 hours
                const url = `https://aviationweather.gov/api/data/pirep?format=raw&age=2`;
                console.log('Fetching PIREPs from:', url);
                const text = await tryFetch(url, 0, 10);
                
                pirepData = [];
                
                if (!text || text.length < 20) {
                    console.log('PIREP: No data or empty response');
                    return;
                }
                
                console.log('PIREP response length:', text.length, 'First 200 chars:', text.substring(0, 200));
                
                const pireps = text.trim().split('\n');
                console.log('Total PIREP lines:', pireps.length);
                
                let icingCount = 0;
                for (const pirep of pireps) {
                    // Look for icing reports - /IC or ICE or ICING
                    if (!pirep.match(/\/IC|ICE|ICING/i)) continue;
                    icingCount++;
                    
                    // Parse location - can be /OV XXX or just airport code at start
                    const locMatch = pirep.match(/\/OV\s*([A-Z]{3,4})|^([A-Z]{3,4})\s+UA/);
                    // Parse altitude - /FL or /ALT
                    const altMatch = pirep.match(/\/FL\s*(\d{3})|\/ALT\s*(\d{3,5})/);
                    // Parse icing type and intensity
                    const icMatch = pirep.match(/\/IC\s*([A-Z\-\s]+?)(?=\/|$)/);
                    // Parse time
                    const timeMatch = pirep.match(/\/TM\s*(\d{4})/);
                    
                    const location = locMatch ? (locMatch[1] || locMatch[2]) : null;
                    
                    if (location) {
                        let intensity = 'light';
                        const icText = icMatch ? icMatch[1].trim().toUpperCase() : 'ICING';
                        
                        if (icText.match(/MOD|MDT/)) intensity = 'moderate';
                        if (icText.match(/SEV|HVY|HEAVY/)) intensity = 'severe';
                        
                        let altitude = null;
                        if (altMatch) {
                            altitude = altMatch[1] ? parseInt(altMatch[1]) * 100 : parseInt(altMatch[2]);
                        }
                        
                        pirepData.push({
                            location: location,
                            altitude: altitude,
                            intensity: intensity,
                            type: icText.substring(0, 20),
                            time: timeMatch ? timeMatch[1] : null,
                            raw: pirep.substring(0, 100)
                        });
                    }
                }
                
                // Sort by intensity (severe first)
                const intensityOrder = { severe: 0, moderate: 1, light: 2 };
                pirepData.sort((a, b) => intensityOrder[a.intensity] - intensityOrder[b.intensity]);
                
                console.log('PIREPs with icing keyword:', icingCount, '| Parsed successfully:', pirepData.length);
                
            } catch (e) {
                console.error('PIREP fetch failed:', e.message, e);
                pirepData = [];
            }
        }

        async function fetchAIRMETs() {
            try {
                // Get AIRMETs - try without hazard filter first
                const url = `https://aviationweather.gov/api/data/airsigmet?format=raw`;
                console.log('Fetching AIRMETs from:', url);
                const text = await tryFetch(url, 0, 10);
                
                airmetData = [];
                
                if (!text || text.length < 20) {
                    console.log('AIRMET: No data or empty response');
                    return;
                }
                
                console.log('AIRMET response length:', text.length, 'First 300 chars:', text.substring(0, 300));
                
                // Split by double newline or by AIRMET keyword
                const parts = text.split(/\n\n|(?=WA\d+\s)|(?=AIRMET)/);
                console.log('AIRMET parts:', parts.length);
                
                let icingCount = 0;
                for (const part of parts) {
                    const airmet = part.trim();
                    if (!airmet) continue;
                    
                    // Look for icing-related AIRMETs
                    if (!airmet.match(/ICE|ICING|FRZLVL|ZULU|ICG/i)) continue;
                    icingCount++;
                    
                    // Extract validity time
                    const validMatch = airmet.match(/VALID\s*(?:UNTIL\s*)?(\d{6})|(\d{6})Z?-(\d{6})/i);
                    // Extract flight levels
                    const flMatch = airmet.match(/FL(\d{3})/g);
                    // Extract freezing level info
                    const frzlvlMatch = airmet.match(/FRZLVL[^\n\.]+|FREEZING\s+LEVEL[^\n\.]+/i);
                    
                    airmetData.push({
                        raw: airmet.substring(0, 250),
                        validUntil: validMatch ? (validMatch[1] || validMatch[3]) : null,
                        flightLevels: flMatch || [],
                        freezingLevel: frzlvlMatch ? frzlvlMatch[0] : null
                    });
                }
                
                console.log('AIRMETs with icing keywords:', icingCount, '| Parsed:', airmetData.length);
                
            } catch (e) {
                console.error('AIRMET fetch failed:', e.message, e);
                airmetData = [];
            }
        }

        async function fetchFreezingLevel() {
            try {
                // Try to get freezing level from AIRMETs first (most reliable)
                for (const airmet of airmetData) {
                    if (airmet.freezingLevel) {
                        // Parse patterns like "FRZLVL 080-100" or "FRZLVL SFC-040"
                        const lvlMatch = airmet.freezingLevel.match(/(\d{2,3})(?:00)?(?:\s*(?:FT|MSL|AGL))?/);
                        if (lvlMatch) {
                            let level = parseInt(lvlMatch[1]);
                            // If it looks like a flight level (2-3 digits), multiply by 100
                            if (level < 500) level *= 100;
                            
                            freezingLevelData = {
                                level: level,
                                unit: 'ft',
                                source: 'AIRMET',
                                raw: airmet.freezingLevel
                            };
                            console.log('Freezing level from AIRMET:', freezingLevelData);
                            return;
                        }
                    }
                }
                
                // Fallback: estimate from cold airport temperatures
                // Find the coldest airport at ground level and extrapolate
                // (rough estimate: freezing level is where ground temp would be 0¬∞C)
                
                console.log('Freezing level: Using AIRMET data if available');
                
            } catch (e) {
                console.log('Freezing level calculation failed:', e.message);
            }
        }

        function getFrostRisk(icao, tempC) {
            // Frost risk: below 4¬∞C during night/early morning hours
            if (tempC === null || tempC > 4) return false;
            
            const localTime = getLocalTime(icao);
            if (!localTime) return false;
            
            const hour = localTime.getHours();
            // High frost risk window: 10pm - 9am when temps are near/below freezing
            return (hour >= 22 || hour < 9) && tempC <= 4;
        }

        // Holdover Time estimation (simplified - based on FAA HOT guidelines)
        // Returns { minutes: number, fluid: string, status: 'ok'|'short'|'expired' }
        function estimateHoldoverTime(tempC, weather, intensity) {
            if (tempC === null) return null;
            
            // Determine precipitation type and intensity
            let precipType = null;
            let precipIntensity = 'light'; // light, moderate, heavy
            
            for (const wx of weather) {
                if (wx === 'FZRA' || wx === 'FZDZ') {
                    precipType = 'freezing_rain';
                } else if (wx === 'PL') {
                    precipType = 'ice_pellets';
                } else if (wx === 'SN' || wx === 'SG') {
                    precipType = 'snow';
                } else if (wx === 'FZFG') {
                    precipType = 'freezing_fog';
                }
                
                // Check intensity prefixes in original weather
                if (wx.startsWith('+')) precipIntensity = 'heavy';
                else if (wx.startsWith('-')) precipIntensity = 'light';
                else if (precipType) precipIntensity = 'moderate';
            }
            
            if (!precipType) return null;
            
            // Simplified HOT table (Type I fluid at various temps)
            // Real HOT tables are much more complex and depend on exact fluid type
            let hotMinutes = 0;
            let fluid = 'Type I';
            
            if (precipType === 'freezing_rain') {
                // FZRA has very short HOT
                hotMinutes = precipIntensity === 'light' ? 15 : 5;
                fluid = 'Type IV recommended';
            } else if (precipType === 'ice_pellets') {
                hotMinutes = precipIntensity === 'light' ? 10 : 5;
            } else if (precipType === 'snow') {
                // Snow HOT varies greatly by temp and intensity
                if (tempC >= -3) {
                    hotMinutes = precipIntensity === 'light' ? 45 : (precipIntensity === 'moderate' ? 25 : 15);
                } else if (tempC >= -10) {
                    hotMinutes = precipIntensity === 'light' ? 60 : (precipIntensity === 'moderate' ? 35 : 20);
                } else {
                    hotMinutes = precipIntensity === 'light' ? 90 : (precipIntensity === 'moderate' ? 45 : 25);
                }
            } else if (precipType === 'freezing_fog') {
                hotMinutes = 60;
            }
            
            // Determine status
            let status = 'ok';
            if (hotMinutes <= 15) status = 'expired';
            else if (hotMinutes <= 30) status = 'short';
            
            return {
                minutes: hotMinutes,
                fluid: fluid,
                precipType: precipType,
                status: status
            };
        }

        // Fetch NOTAMs for runway closures and braking action
        async function fetchNOTAMs() {
            try {
                // Try multiple NOTAM sources
                notamData = {};
                
                // Try the aviationweather.gov NOTAM endpoint
                const ids = AIRPORTS.slice(0, 30).join(','); // Limit to top 30 to keep request manageable
                const url = `https://aviationweather.gov/api/data/notam?ids=${ids}&format=raw`;
                console.log('Fetching NOTAMs from:', url);
                
                const text = await tryFetch(url, 0, 10);
                
                if (text && text.length > 50) {
                    console.log('NOTAM response length:', text.length);
                    
                    // Parse NOTAMs - look for runway closures and FICON (field conditions)
                    const notams = text.split(/(?=\!)/);
                    
                    for (const notam of notams) {
                        if (!notam.trim()) continue;
                        
                        // Find airport - try multiple patterns
                        const icaoMatch = notam.match(/\!(K[A-Z]{3})|^(K[A-Z]{3})\s/);
                        if (!icaoMatch) continue;
                        
                        const icao = icaoMatch[1] || icaoMatch[2];
                        if (!notamData[icao]) {
                            notamData[icao] = {
                                closedRunways: [],
                                brakingAction: null,
                                ficonReports: [],
                                airportClosed: false
                            };
                        }
                        
                        // Check for runway closures
                        const rwyCloseMatch = notam.match(/RWY\s+(\d{1,2}[LRC]?(?:\/\d{1,2}[LRC]?)?)\s+CLSD/i);
                        if (rwyCloseMatch) {
                            notamData[icao].closedRunways.push(rwyCloseMatch[1]);
                        }
                        
                        // Check for FICON (Field Condition) reports with braking action
                        // Look for MU values (e.g., MU 35, MU45)
                        const muMatch = notam.match(/\bMU\s*(\d{2})/i);
                        if (muMatch) {
                            const mu = parseInt(muMatch[1]);
                            if (mu >= 40) notamData[icao].brakingAction = 'GOOD';
                            else if (mu >= 30) notamData[icao].brakingAction = 'FAIR';
                            else if (mu >= 20) notamData[icao].brakingAction = 'POOR';
                            else notamData[icao].brakingAction = 'NIL';
                            notamData[icao].ficonReports.push(notam.substring(0, 150));
                        }
                        
                        // Look for explicit braking action
                        const brakingMatch = notam.match(/BRAKING\s*(ACTION)?\s*(GOOD|FAIR|MEDIUM|POOR|NIL)/i);
                        if (brakingMatch) {
                            notamData[icao].brakingAction = brakingMatch[2].toUpperCase();
                            if (!notamData[icao].ficonReports.includes(notam.substring(0, 150))) {
                                notamData[icao].ficonReports.push(notam.substring(0, 150));
                            }
                        }
                        
                        // Look for FICON keyword
                        if (notam.match(/\bFICON\b/i)) {
                            if (!notamData[icao].ficonReports.some(r => r === notam.substring(0, 150))) {
                                notamData[icao].ficonReports.push(notam.substring(0, 150));
                            }
                        }
                        
                        // Airport closures
                        if (notam.match(/\bAD\s+CLSD\b|\bAIRPORT\s+CLSD\b|\bARPT\s+CLSD\b/i)) {
                            notamData[icao].airportClosed = true;
                        }
                    }
                    
                    console.log('NOTAMs parsed for', Object.keys(notamData).length, 'airports');
                } else {
                    console.log('NOTAM: No data returned from API');
                }
                
            } catch (e) {
                console.error('NOTAM fetch failed:', e.message);
                notamData = {};
            }
        }

        // Extract field condition info from METAR remarks (backup source)
        function extractFieldConditions(metar) {
            if (!metar) return null;
            
            const result = {
                brakingAction: null,
                ficonReports: []
            };
            
            // Look for FICON (Field Condition) in remarks
            // Formats: FICON 5/5/5, MU45, BRAKING GOOD/FAIR/POOR/NIL
            const muMatch = metar.match(/\bMU(\d{2})/);
            if (muMatch) {
                const mu = parseInt(muMatch[1]);
                if (mu >= 40) result.brakingAction = 'GOOD';
                else if (mu >= 30) result.brakingAction = 'FAIR';
                else if (mu >= 20) result.brakingAction = 'POOR';
                else result.brakingAction = 'NIL';
            }
            
            const brakingMatch = metar.match(/BRAKING\s+(GOOD|FAIR|MEDIUM|POOR|NIL)/i);
            if (brakingMatch) {
                result.brakingAction = brakingMatch[1].toUpperCase();
            }
            
            // Look for FICON reports
            const ficonMatch = metar.match(/FICON[^A-Z].*?(?=\s{2}|$)/i);
            if (ficonMatch) {
                result.ficonReports.push(ficonMatch[0]);
            }
            
            return (result.brakingAction || result.ficonReports.length > 0) ? result : null;
        }

        // Calculate runway availability
        function getRunwayStatus(icao, metarRaw) {
            const totalRunways = RUNWAY_DATA[icao] || 2;
            const notams = notamData[icao];
            
            let closedCount = 0;
            let brakingAction = null;
            
            if (notams) {
                closedCount = notams.closedRunways ? notams.closedRunways.length : 0;
                brakingAction = notams.brakingAction;
                if (notams.airportClosed) {
                    return { 
                        available: 0, 
                        total: totalRunways, 
                        status: 'critical', 
                        brakingAction: brakingAction,
                        message: 'AIRPORT CLOSED'
                    };
                }
            }
            
            // Also check METAR for field conditions
            if (metarRaw && !brakingAction) {
                const fieldCond = extractFieldConditions(metarRaw);
                if (fieldCond && fieldCond.brakingAction) {
                    brakingAction = fieldCond.brakingAction;
                }
            }
            
            const available = Math.max(0, totalRunways - closedCount);
            let status = 'good';
            
            if (available === 0) status = 'critical';
            else if (available === 1) status = 'limited';
            else if (closedCount > 0) status = 'limited';
            
            // Braking action affects status
            if (brakingAction === 'NIL') {
                status = 'critical';
            } else if (brakingAction === 'POOR') {
                status = available <= 1 ? 'critical' : 'limited';
            }
            
            return {
                available: available,
                total: totalRunways,
                status: status,
                brakingAction: brakingAction,
                closedRunways: notams ? (notams.closedRunways || []) : []
            };
        }

        // Search and filter functions
        function filterAirports() {
            currentSearchTerm = document.getElementById('searchInput').value.toUpperCase();
            renderFilteredResults();
        }

        function clearSearch() {
            document.getElementById('searchInput').value = '';
            currentSearchTerm = '';
            renderFilteredResults();
        }

        function setRegionFilter(region) {
            currentRegionFilter = region;
            
            // Update button states
            document.querySelectorAll('.filter-btn').forEach(btn => {
                btn.classList.remove('active');
                if (btn.dataset.region === region) btn.classList.add('active');
            });
            
            renderFilteredResults();
        }

        function airportMatchesFilter(icao) {
            // Check search term
            if (currentSearchTerm) {
                const name = AIRPORT_NAMES[icao] || '';
                if (!icao.includes(currentSearchTerm) && !name.toUpperCase().includes(currentSearchTerm)) {
                    return false;
                }
            }
            
            // Check region filter
            if (currentRegionFilter !== 'all') {
                const regionAirports = AIRPORT_REGIONS[currentRegionFilter] || [];
                if (!regionAirports.includes(icao)) {
                    return false;
                }
            }
            
            return true;
        }

        let lastRenderData = null;

        function renderFilteredResults() {
            if (lastRenderData) {
                renderResults(lastRenderData.categories, lastRenderData.total);
            }
        }

        function tempToF(c) {
            return Math.round(c * 9/5 + 32);
        }

        function getTimeSince(obsTime) {
            if (!obsTime) return { text: 'N/A', stale: false };
            const now = new Date();
            const diffMs = now - obsTime;
            const diffMins = Math.floor(diffMs / 60000);
            
            if (diffMins < 60) {
                return { text: `${diffMins}m ago`, stale: diffMins > 90 };
            } else {
                const hours = Math.floor(diffMins / 60);
                const mins = diffMins % 60;
                return { text: `${hours}h ${mins}m ago`, stale: hours >= 2 };
            }
        }

        function getTrend(history) {
            if (!history || history.length < 2) return { symbol: '‚Äî', class: 'steady', text: 'No trend data' };
            
            // Get temps from oldest to newest (history is newest first, so reverse)
            const temps = history.map(h => h.temp_c).filter(t => t !== null).reverse();
            if (temps.length < 2) return { symbol: '‚Äî', class: 'steady', text: 'No trend data' };
            
            const oldest = temps[0];
            const newest = temps[temps.length - 1];
            const diff = newest - oldest;
            
            if (diff >= 3) return { symbol: '‚Üë', class: 'warming', text: `+${diff}¬∞ over ${temps.length} obs` };
            if (diff <= -3) return { symbol: '‚Üì', class: 'cooling', text: `${diff}¬∞ over ${temps.length} obs` };
            return { symbol: '‚Üí', class: 'steady', text: 'Steady' };
        }

        async function tryFetch(url, proxyIndex = 0, minLength = 10) {
            if (proxyIndex >= CORS_PROXIES.length) {
                console.warn('All fetch methods failed for:', url.substring(0, 60));
                return ''; // Return empty string instead of throwing
            }
            
            const proxyUrl = CORS_PROXIES[proxyIndex](url);
            
            try {
                const controller = new AbortController();
                const timeout = setTimeout(() => controller.abort(), 15000);
                
                const response = await fetch(proxyUrl, { 
                    signal: controller.signal,
                    headers: { 'Accept': 'text/plain' }
                });
                clearTimeout(timeout);
                
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                
                const text = await response.text();
                if (!text || text.length < minLength) {
                    throw new Error('Response too short: ' + text.length);
                }
                return text;
            } catch (e) {
                console.log(`Proxy ${proxyIndex} failed for ${url.substring(0,50)}:`, e.message);
                return tryFetch(url, proxyIndex + 1, minLength);
            }
        }

        async function fetchData() {
            const btn = document.getElementById('refreshBtn');
            const content = document.getElementById('content');
            
            btn.disabled = true;
            btn.textContent = '‚è≥ Loading...';
            
            content.innerHTML = `
                <div class="loading">
                    <div class="spinner"></div>
                    <div>Fetching METAR, TAF, PIREP, AIRMET, NOTAM data...</div>
                    <div id="loadingStatus" style="font-size: 11px; color: #666; margin-top: 10px;"></div>
                </div>
            `;
            
            const updateStatus = (msg) => {
                const el = document.getElementById('loadingStatus');
                if (el) el.innerHTML += msg + '<br>';
            };

            try {
                // Fetch all data sources in parallel
                const trafficPromise = fetchTrafficManagement();
                const advisoryPromise = fetchFAAAdvisory();
                const tafPromise = fetchTAFs();
                const pirepPromise = fetchPIREPs();
                const airmetPromise = fetchAIRMETs();
                const notamPromise = fetchNOTAMs();
                
                const ids = AIRPORTS.join(',');
                // Request last 6 hours of METARs
                const baseUrl = `https://aviationweather.gov/api/data/metar?ids=${ids}&format=raw&hours=6`;
                
                const text = await tryFetch(baseUrl);
                const metars = text.trim().split('\n').filter(m => m.length > 10 && m.match(/K[A-Z]{3}/));
                
                if (metars.length === 0) {
                    throw new Error('No valid METAR data received');
                }
                
                // Wait for all other data
                await Promise.all([trafficPromise, advisoryPromise, tafPromise, pirepPromise, airmetPromise, notamPromise]);
                
                // Fetch freezing level after AIRMETs (uses AIRMET data as fallback)
                await fetchFreezingLevel();
                
                // Parse all METARs
                const allParsed = metars.map(parseMetar).filter(p => p !== null);
                
                // Group by airport
                const byAirport = {};
                for (const p of allParsed) {
                    if (!byAirport[p.icao]) byAirport[p.icao] = [];
                    byAirport[p.icao].push(p);
                }
                
                // Sort each airport's METARs by time (newest first) and keep last 6
                for (const icao in byAirport) {
                    byAirport[icao].sort((a, b) => (b.obs_time || 0) - (a.obs_time || 0));
                    byAirport[icao] = byAirport[icao].slice(0, 6);
                }
                
                // Create airport objects with latest data and history
                const airportData = [];
                for (const icao of AIRPORTS) {
                    if (byAirport[icao] && byAirport[icao].length > 0) {
                        const history = byAirport[icao];
                        const latest = history[0];
                        const recentFrozen = checkRecentFrozen(history);
                        airportData.push({
                            ...latest,
                            history: history,
                            trend: getTrend(history),
                            had_recent_frozen: recentFrozen.hadFrozen,
                            recent_frozen_types: recentFrozen.frozenTypes,
                            last_frozen_time: recentFrozen.lastFrozenTime,
                            // New indicators
                            hub_airlines: getHubInfo(icao),
                            rush_status: getRushStatus(icao),
                            traffic_programs: trafficPrograms[icao] || null,
                            // TAF data
                            taf: tafData[icao] || null,
                            frost_risk: getFrostRisk(icao, latest.temp_c),
                            // HOT estimate
                            hot_estimate: estimateHoldoverTime(latest.temp_c, latest.weather, null),
                            // Runway status (pass raw METAR for braking extraction)
                            runway_status: getRunwayStatus(icao, latest.raw)
                        });
                    }
                }
                
                // Categorize
                const categories = { active: [], likely: [], residual: [], possible: [], marginal: [], none: [] };
                for (const apt of airportData) {
                    const cat = categorize(apt);
                    if (categories[cat]) categories[cat].push(apt);
                }

                // Sort by airport rank (busiest first)
                for (const cat in categories) {
                    categories[cat].sort((a, b) => {
                        const rankA = AIRPORTS.indexOf(a.icao);
                        const rankB = AIRPORTS.indexOf(b.icao);
                        return rankA - rankB;
                    });
                }

                renderResults(categories, airportData.length);
                
                const now = new Date();
                document.getElementById('timestamp').textContent = 
                    `Updated: ${now.toLocaleTimeString()} | ${airportData.length} airports reporting`;

            } catch (error) {
                content.innerHTML = `
                    <div class="error">
                        <strong>Unable to load data</strong><br><br>
                        ${error.message}<br><br>
                        <small>This can happen due to network issues or API availability.</small>
                        <br>
                        <button onclick="fetchData()">Try Again</button>
                    </div>
                `;
            }

            btn.disabled = false;
            btn.textContent = 'üîÑ Refresh';
        }

        function renderResults(categories, total) {
            // Store data for filtering
            lastRenderData = { categories, total };
            
            const content = document.getElementById('content');
            
            // Apply filters to categories
            const filteredCategories = {
                active: categories.active.filter(a => airportMatchesFilter(a.icao)),
                residual: categories.residual.filter(a => airportMatchesFilter(a.icao)),
                likely: categories.likely.filter(a => airportMatchesFilter(a.icao)),
                possible: categories.possible.filter(a => airportMatchesFilter(a.icao)),
                marginal: categories.marginal.filter(a => airportMatchesFilter(a.icao)),
                none: categories.none.filter(a => airportMatchesFilter(a.icao))
            };
            
            // Traffic management summary
            let trafficHtml = '';
            const affectedAirports = Object.keys(trafficPrograms).filter(icao => airportMatchesFilter(icao));
            if (affectedAirports.length > 0) {
                let trafficItems = '';
                for (const icao of affectedAirports) {
                    const programs = trafficPrograms[icao];
                    const name = AIRPORT_NAMES[icao] || icao;
                    for (const prog of programs) {
                        let details = '';
                        // Try to get end time from FAA Advisory
                        const advisoryInfo = faaAdvisoryData.terminalActive[icao];
                        if (prog.type === 'GDP') {
                            if (advisoryInfo && advisoryInfo.length > 0) {
                                details = `Until: ${advisoryInfo[0].endTime}Z (Avg: ${prog.avgDelay})`;
                            } else {
                                details = `Avg delay: ${prog.avgDelay}`;
                            }
                        } else if (prog.type === 'GROUND STOP') {
                            details = `Until: ${prog.endTime}`;
                        } else if (prog.type === 'ARR DELAY' || prog.type === 'DEP DELAY') {
                            details = `${prog.minDelay}-${prog.maxDelay}`;
                        } else if (prog.type === 'DEICING') {
                            details = prog.startTime ? `Started: ${prog.startTime}` : 'Active';
                        }
                        // Add constraint reason from FAA Advisory if available
                        const constraint = faaAdvisoryData.terminalConstraints[icao];
                        const reasonText = constraint ? constraint : prog.reason;
                        trafficItems += `
                            <div class="traffic-item">
                                <span class="airport">${icao}</span> ${name} - 
                                <span class="program">${prog.type}</span> ${details}
                                <div class="reason">${reasonText}</div>
                            </div>
                        `;
                    }
                }
                trafficHtml = `
                    <div id="section-traffic" class="collapsible-section section-traffic ${getSectionClass('section-traffic')}">
                        <div class="section-header" onclick="toggleSection('section-traffic')">
                            <h3>‚ö†Ô∏è Active Traffic Management Programs (${affectedAirports.length})</h3>
                            <span class="section-toggle">${getSectionToggle('section-traffic')}</span>
                        </div>
                        <div class="section-content ${getSectionContentClass('section-traffic')}">
                            ${trafficItems}
                        </div>
                    </div>
                `;
            }
            
            // Deicing Programs section - highlight airports with formal deicing
            const deicingAirports = Object.keys(trafficPrograms)
                .filter(icao => airportMatchesFilter(icao) && 
                    trafficPrograms[icao].some(p => p.type === 'DEICING'));
            if (deicingAirports.length > 0) {
                let deicingItems = '';
                for (const icao of deicingAirports) {
                    const name = AIRPORT_NAMES[icao] || icao;
                    const deicingProg = trafficPrograms[icao].find(p => p.type === 'DEICING');
                    const startTime = deicingProg.startTime ? `Started: ${deicingProg.startTime}` : '';
                    deicingItems += `
                        <div class="deicing-item">
                            <span class="airport">${icao}</span> ${name} ${startTime}
                        </div>
                    `;
                }
                trafficHtml += `
                    <div id="section-deicing" class="collapsible-section section-deicing ${getSectionClass('section-deicing')}">
                        <div class="section-header" onclick="toggleSection('section-deicing')">
                            <h3>‚ùÑÔ∏è Active Deicing Programs (${deicingAirports.length})</h3>
                            <span class="section-toggle">${getSectionToggle('section-deicing')}</span>
                        </div>
                        <div class="section-content ${getSectionContentClass('section-deicing')}">
                            ${deicingItems}
                        </div>
                    </div>
                `;
            }
            
            // FAA Advisory - Terminal Constraints (airports with weather issues but no GDP yet)
            const constrainedAirports = Object.keys(faaAdvisoryData.terminalConstraints)
                .filter(icao => airportMatchesFilter(icao) && !trafficPrograms[icao]);
            if (constrainedAirports.length > 0) {
                let constraintItems = '';
                for (const icao of constrainedAirports) {
                    const name = AIRPORT_NAMES[icao] || icao;
                    const constraint = faaAdvisoryData.terminalConstraints[icao];
                    constraintItems += `
                        <div class="constraint-item">
                            <span class="airport">${icao}</span> ${name} - 
                            <span class="constraint-type">${constraint}</span>
                        </div>
                    `;
                }
                trafficHtml += `
                    <div id="section-constraint" class="collapsible-section section-constraint ${getSectionClass('section-constraint')}">
                        <div class="section-header" onclick="toggleSection('section-constraint')">
                            <h3>üå°Ô∏è Terminal Constraints (${constrainedAirports.length})</h3>
                            <span class="section-toggle">${getSectionToggle('section-constraint')}</span>
                        </div>
                        <div class="section-content ${getSectionContentClass('section-constraint')}">
                            ${constraintItems}
                        </div>
                    </div>
                `;
            }
            
            // FAA Advisory - Planned/Possible ground stops
            const plannedAirports = Object.keys(faaAdvisoryData.terminalPlanned)
                .filter(icao => airportMatchesFilter(icao));
            if (plannedAirports.length > 0) {
                let plannedItems = '';
                for (const icao of plannedAirports) {
                    const name = AIRPORT_NAMES[icao] || icao;
                    const programs = faaAdvisoryData.terminalPlanned[icao];
                    for (const prog of programs) {
                        plannedItems += `
                            <div class="planned-item">
                                <span class="airport">${icao}</span> ${name} - ${prog}
                            </div>
                        `;
                    }
                }
                trafficHtml += `
                    <div id="section-planned" class="collapsible-section section-planned ${getSectionClass('section-planned')}">
                        <div class="section-header" onclick="toggleSection('section-planned')">
                            <h3>‚è≥ Possible Ground Stops (${plannedAirports.length})</h3>
                            <span class="section-toggle">${getSectionToggle('section-planned')}</span>
                        </div>
                        <div class="section-content ${getSectionContentClass('section-planned')}">
                            ${plannedItems}
                        </div>
                    </div>
                `;
            }
            
            // FAA Advisory - Runway/Taxiway closures
            const closureAirports = Object.keys(faaAdvisoryData.runwayClosures)
                .filter(icao => airportMatchesFilter(icao));
            if (closureAirports.length > 0) {
                let closureItems = '';
                for (const icao of closureAirports) {
                    const name = AIRPORT_NAMES[icao] || icao;
                    const closures = faaAdvisoryData.runwayClosures[icao];
                    for (const closure of closures) {
                        closureItems += `
                            <div class="closure-item">
                                <span class="airport">${icao}</span> ${name} - ${closure}
                            </div>
                        `;
                    }
                }
                trafficHtml += `
                    <div id="section-closure" class="collapsible-section section-closure ${getSectionClass('section-closure')}">
                        <div class="section-header" onclick="toggleSection('section-closure')">
                            <h3>üöß Runway/Taxiway Closures (${closureAirports.length})</h3>
                            <span class="section-toggle">${getSectionToggle('section-closure')}</span>
                        </div>
                        <div class="section-content ${getSectionContentClass('section-closure')}">
                            ${closureItems}
                        </div>
                    </div>
                `;
            }
            
            // Runway/NOTAM alerts for critical situations
            let runwayAlertHtml = '';
            const criticalRunways = [];
            
            // Collect all airports from all categories
            const allAirports = [
                ...filteredCategories.active,
                ...filteredCategories.residual,
                ...filteredCategories.likely,
                ...filteredCategories.possible,
                ...filteredCategories.marginal,
                ...filteredCategories.none
            ];
            
            for (const apt of allAirports) {
                const status = apt.runway_status;
                if (status && (status.status === 'critical' || status.brakingAction === 'NIL' || status.brakingAction === 'POOR')) {
                    criticalRunways.push({ icao: apt.icao, ...status });
                }
            }
            
            if (criticalRunways.length > 0) {
                let runwayItems = '';
                for (const rwy of criticalRunways) {
                    const name = AIRPORT_NAMES[rwy.icao] || rwy.icao;
                    let alertMsg = '';
                    if (rwy.message === 'AIRPORT CLOSED') {
                        alertMsg = '<span style="color: #e74c3c;">AIRPORT CLOSED</span>';
                    } else if (rwy.available === 0) {
                        alertMsg = '<span style="color: #e74c3c;">NO RUNWAYS AVAILABLE</span>';
                    } else {
                        alertMsg = `${rwy.available}/${rwy.total} runways open`;
                    }
                    
                    let brakingHtml = '';
                    if (rwy.brakingAction) {
                        const brakingClass = rwy.brakingAction === 'GOOD' ? 'braking-good' : 
                                            rwy.brakingAction === 'MEDIUM' || rwy.brakingAction === 'FAIR' ? 'braking-fair' :
                                            rwy.brakingAction === 'POOR' ? 'braking-poor' : 'braking-nil';
                        brakingHtml = `<span class="braking-action ${brakingClass}">${rwy.brakingAction}</span>`;
                    }
                    
                    runwayItems += `
                        <div class="notam-item">
                            <span class="airport" style="color: #f39c12;">${rwy.icao}</span> ${name} - ${alertMsg} ${brakingHtml}
                            ${rwy.closedRunways.length > 0 ? `<div style="color: #888; font-size: 10px;">Closed: ${rwy.closedRunways.join(', ')}</div>` : ''}
                        </div>
                    `;
                }
                runwayAlertHtml = `
                    <div id="section-runway" class="collapsible-section section-runway ${getSectionClass('section-runway')}">
                        <div class="section-header" onclick="toggleSection('section-runway')">
                            <h3>üõ¨ Runway/Braking Alerts (${criticalRunways.length})</h3>
                            <span class="section-toggle">${getSectionToggle('section-runway')}</span>
                        </div>
                        <div class="section-content ${getSectionContentClass('section-runway')}">
                            ${runwayItems}
                        </div>
                    </div>
                `;
            }
            
            // Info grid: PIREPs, AIRMETs, Freezing Level - wrapped in collapsible section
            let infoGridContent = '<div class="info-grid">';
            
            // Freezing Level panel
            if (freezingLevelData) {
                infoGridContent += `
                    <div class="data-panel freezing">
                        <h3>üå°Ô∏è Freezing Level</h3>
                        <div style="text-align: center;">
                            <div style="font-size: 28px; font-weight: bold; color: #1abc9c;">${freezingLevelData.level.toLocaleString()} ft</div>
                            <div style="font-size: 11px; color: #888; margin-top: 4px;">
                                ${freezingLevelData.source ? `Source: ${freezingLevelData.source}` : 'Regional estimate'}
                                ${freezingLevelData.raw ? '<br>' + freezingLevelData.raw : ''}
                            </div>
                        </div>
                    </div>
                `;
            } else {
                infoGridContent += `
                    <div class="data-panel freezing">
                        <h3>üå°Ô∏è Freezing Level</h3>
                        <div style="text-align: center; color: #666; font-size: 12px;">No data available</div>
                    </div>
                `;
            }
            
            // PIREPs panel
            if (pirepData.length > 0) {
                const pirepInitialShow = 8;
                const hasMorePireps = pirepData.length > pirepInitialShow;
                
                infoGridContent += `
                    <div class="data-panel pireps">
                        <h3 style="cursor: ${hasMorePireps ? 'pointer' : 'default'};" ${hasMorePireps ? 'onclick="togglePirepList()"' : ''}>
                            üõ©Ô∏è Icing PIREPs (${pirepData.length})
                            ${hasMorePireps ? '<span id="pirepToggleIcon" style="float: right; font-size: 10px;">‚ñº</span>' : ''}
                        </h3>
                        <div class="compact-list">
                `;
                for (const pirep of pirepData.slice(0, pirepInitialShow)) {
                    const alt = pirep.altitude ? `FL${Math.round(pirep.altitude/100).toString().padStart(3,'0')}` : 'N/A';
                    infoGridContent += `
                        <div class="item">
                            <span class="pirep-item">
                                <span class="intensity ${pirep.intensity}">${pirep.intensity.toUpperCase()}</span>
                                ${pirep.location} @ ${alt} - ${pirep.type}
                            </span>
                        </div>
                    `;
                }
                if (hasMorePireps) {
                    infoGridContent += `<div id="pirepExpandedList" style="display: none;">`;
                    for (const pirep of pirepData.slice(pirepInitialShow)) {
                        const alt = pirep.altitude ? `FL${Math.round(pirep.altitude/100).toString().padStart(3,'0')}` : 'N/A';
                        infoGridContent += `
                            <div class="item">
                                <span class="pirep-item">
                                    <span class="intensity ${pirep.intensity}">${pirep.intensity.toUpperCase()}</span>
                                    ${pirep.location} @ ${alt} - ${pirep.type}
                                </span>
                            </div>
                        `;
                    }
                    infoGridContent += '</div>';
                }
                infoGridContent += '</div></div>';
            } else {
                infoGridContent += `
                    <div class="data-panel pireps">
                        <h3>üõ©Ô∏è Icing PIREPs</h3>
                        <div style="color: #666; font-size: 12px;">No icing PIREPs in last 2 hours</div>
                    </div>
                `;
            }
            
            // AIRMETs panel
            if (airmetData.length > 0) {
                const airmetInitialShow = 4;
                const hasMoreAirmets = airmetData.length > airmetInitialShow;
                
                infoGridContent += `
                    <div class="data-panel airmets">
                        <h3 style="cursor: ${hasMoreAirmets ? 'pointer' : 'default'};" ${hasMoreAirmets ? 'onclick="toggleAirmetList()"' : ''}>
                            ‚ö° Icing AIRMETs (${airmetData.length})
                            ${hasMoreAirmets ? '<span id="airmetToggleIcon" style="float: right; font-size: 10px;">‚ñº</span>' : ''}
                        </h3>
                        <div class="compact-list">
                `;
                for (const airmet of airmetData.slice(0, airmetInitialShow)) {
                    const validText = airmet.validUntil ? `Valid until ${airmet.validUntil}Z` : '';
                    const frzText = airmet.freezingLevel || '';
                    infoGridContent += `
                        <div class="item">
                            <div style="color: #ddd;">${validText}</div>
                            <div style="color: #9b59b6; font-size: 10px;">${frzText}</div>
                        </div>
                    `;
                }
                if (hasMoreAirmets) {
                    infoGridContent += `<div id="airmetExpandedList" style="display: none;">`;
                    for (const airmet of airmetData.slice(airmetInitialShow)) {
                        const validText = airmet.validUntil ? `Valid until ${airmet.validUntil}Z` : '';
                        const frzText = airmet.freezingLevel || '';
                        infoGridContent += `
                            <div class="item">
                                <div style="color: #ddd;">${validText}</div>
                                <div style="color: #9b59b6; font-size: 10px;">${frzText}</div>
                            </div>
                        `;
                    }
                    infoGridContent += '</div>';
                }
                infoGridContent += '</div></div>';
            } else {
                infoGridContent += `
                    <div class="data-panel airmets">
                        <h3>‚ö° Icing AIRMETs</h3>
                        <div style="color: #666; font-size: 12px;">No active icing AIRMETs</div>
                    </div>
                `;
            }
            
            infoGridContent += '</div>'; // Close info-grid
            
            // Wrap info grid in collapsible section
            const infoGridHtml = `
                <div id="section-infogrid" class="collapsible-section section-pirep ${getSectionClass('section-infogrid')}">
                    <div class="section-header" onclick="toggleSection('section-infogrid')">
                        <h3>üìä Weather & Icing Reports</h3>
                        <span class="section-toggle">${getSectionToggle('section-infogrid')}</span>
                    </div>
                    <div class="section-content ${getSectionContentClass('section-infogrid')}">
                        ${infoGridContent}
                    </div>
                </div>
            `;
            
            // TAF Forecasts with frozen precip
            let tafHtml = '';
            const tafWarnings = [];
            for (const icao of AIRPORTS) {
                if (!airportMatchesFilter(icao)) continue;
                const taf = tafData[icao];
                if (taf && taf.frozenForecasts && taf.frozenForecasts.length > 0) {
                    const name = AIRPORT_NAMES[icao] || icao;
                    for (const fc of taf.frozenForecasts.slice(0, 1)) {
                        tafWarnings.push({
                            icao: icao,
                            name: name,
                            wx: fc.wx,
                            raw: fc.raw
                        });
                    }
                }
            }
            
            if (tafWarnings.length > 0) {
                const initialShow = 10;
                const hasMore = tafWarnings.length > initialShow;
                
                let tafItems = '';
                // First 10 always visible
                for (const warn of tafWarnings.slice(0, initialShow)) {
                    tafItems += `
                        <div class="forecast-note">
                            <span class="airport">${warn.icao}</span> ${warn.name} - 
                            <span style="color: #9b59b6;">${warn.wx}</span>
                            <span style="color: #666; font-size: 10px;"> ${warn.raw}</span>
                        </div>
                    `;
                }
                
                // Remaining airports in expandable section
                if (hasMore) {
                    tafItems += `<div id="tafExpandedList" style="display: none;">`;
                    for (const warn of tafWarnings.slice(initialShow)) {
                        tafItems += `
                            <div class="forecast-note">
                                <span class="airport">${warn.icao}</span> ${warn.name} - 
                                <span style="color: #9b59b6;">${warn.wx}</span>
                                <span style="color: #666; font-size: 10px;"> ${warn.raw}</span>
                            </div>
                        `;
                    }
                    tafItems += '</div>';
                    tafItems += `<div style="text-align: center; margin-top: 8px;">
                        <span id="tafToggleIcon" onclick="toggleTafList(); event.stopPropagation();" style="cursor: pointer; color: #4a90d9; font-size: 12px;">‚ñº Show all ${tafWarnings.length - initialShow} more</span>
                    </div>`;
                }
                
                tafHtml = `
                    <div id="section-taf" class="collapsible-section section-taf ${getSectionClass('section-taf')}">
                        <div class="section-header" onclick="toggleSection('section-taf')">
                            <h3>üìã TAF: Frozen Precip Forecast (${tafWarnings.length})</h3>
                            <span class="section-toggle">${getSectionToggle('section-taf')}</span>
                        </div>
                        <div class="section-content ${getSectionContentClass('section-taf')}">
                            ${tafItems}
                        </div>
                    </div>
                `;
            }
            
            let html = trafficHtml + runwayAlertHtml + infoGridHtml + tafHtml + `
                <div class="summary">
                    <div class="summary-card active">
                        <div class="count">${filteredCategories.active.length}</div>
                        <div class="label">üî¥ Active</div>
                    </div>
                    <div class="summary-card residual">
                        <div class="count">${filteredCategories.residual.length}</div>
                        <div class="label">üü£ Residual</div>
                    </div>
                    <div class="summary-card likely">
                        <div class="count">${filteredCategories.likely.length}</div>
                        <div class="label">üü† Likely</div>
                    </div>
                    <div class="summary-card possible">
                        <div class="count">${filteredCategories.possible.length}</div>
                        <div class="label">üü° Possible</div>
                    </div>
                </div>
            `;

            if (filteredCategories.active.length > 0) {
                html += renderSection('üî¥ Active Deicing', filteredCategories.active);
            }
            if (filteredCategories.residual.length > 0) {
                html += renderSection('üü£ Residual (Recent Frozen Precip)', filteredCategories.residual);
            }
            if (filteredCategories.likely.length > 0) {
                html += renderSection('üü† Likely Deicing', filteredCategories.likely);
            }
            if (filteredCategories.possible.length > 0) {
                html += renderSection('üü° Possible (Below Freezing)', filteredCategories.possible);
            }

            if (filteredCategories.active.length === 0 && filteredCategories.likely.length === 0 && filteredCategories.residual.length === 0 && filteredCategories.possible.length === 0) {
                if (currentSearchTerm || currentRegionFilter !== 'all') {
                    html += `<div class="status-msg info">No matching airports with deicing conditions</div>`;
                } else {
                    html += `<div class="status-msg info">‚úÖ No airports currently reporting deicing conditions</div>`;
                }
            }
            
            // Data status summary
            const advActive = Object.keys(faaAdvisoryData.terminalActive).length;
            const advClosures = Object.keys(faaAdvisoryData.runwayClosures).length;
            
            html += `
                <div style="background: #1a1a2e; border: 1px solid #333; border-radius: 8px; padding: 10px; margin-top: 20px; font-size: 11px; color: #666;">
                    <strong style="color: #888;">Data Status:</strong>
                    <span style="margin-left: 10px;">TAFs: ${Object.keys(tafData).length}</span>
                    <span style="margin-left: 10px;">PIREPs: ${pirepData.length}</span>
                    <span style="margin-left: 10px;">AIRMETs: ${airmetData.length}</span>
                    <span style="margin-left: 10px;">NOTAMs: ${Object.keys(notamData).length}</span>
                    <span style="margin-left: 10px;">FrzLvl: ${freezingLevelData ? '‚úì' : '‚úó'}</span>
                    <span style="margin-left: 10px;">ATCSCC: ${advActive > 0 || advClosures > 0 ? `${advActive} active, ${advClosures} rwys` : '‚úó'}</span>
                </div>
            `;

            content.innerHTML = html;
        }

        // Collapsible section state management
        const sectionState = JSON.parse(localStorage.getItem('deicingMonitorSections') || '{}');
        
        function toggleSection(sectionId) {
            const section = document.getElementById(sectionId);
            const content = section.querySelector('.section-content');
            const toggle = section.querySelector('.section-toggle');
            
            if (section.classList.contains('collapsed')) {
                section.classList.remove('collapsed');
                content.classList.remove('collapsed');
                toggle.textContent = '‚ñº';
                sectionState[sectionId] = 'expanded';
            } else {
                section.classList.add('collapsed');
                content.classList.add('collapsed');
                toggle.textContent = '‚ñ∂';
                sectionState[sectionId] = 'collapsed';
            }
            
            localStorage.setItem('deicingMonitorSections', JSON.stringify(sectionState));
        }
        
        function getSectionClass(sectionId) {
            return sectionState[sectionId] === 'collapsed' ? 'collapsed' : '';
        }
        
        function getSectionToggle(sectionId) {
            return sectionState[sectionId] === 'collapsed' ? '‚ñ∂' : '‚ñº';
        }
        
        function getSectionContentClass(sectionId) {
            return sectionState[sectionId] === 'collapsed' ? 'collapsed' : '';
        }
        
        function expandAllSections() {
            const sections = ['section-traffic', 'section-deicing', 'section-constraint', 'section-planned', 
                             'section-closure', 'section-runway', 'section-infogrid', 'section-taf'];
            for (const sectionId of sections) {
                const section = document.getElementById(sectionId);
                if (section) {
                    section.classList.remove('collapsed');
                    const content = section.querySelector('.section-content');
                    const toggle = section.querySelector('.section-toggle');
                    if (content) content.classList.remove('collapsed');
                    if (toggle) toggle.textContent = '‚ñº';
                    sectionState[sectionId] = 'expanded';
                }
            }
            localStorage.setItem('deicingMonitorSections', JSON.stringify(sectionState));
        }
        
        function collapseAllSections() {
            const sections = ['section-traffic', 'section-deicing', 'section-constraint', 'section-planned', 
                             'section-closure', 'section-runway', 'section-infogrid', 'section-taf'];
            for (const sectionId of sections) {
                const section = document.getElementById(sectionId);
                if (section) {
                    section.classList.add('collapsed');
                    const content = section.querySelector('.section-content');
                    const toggle = section.querySelector('.section-toggle');
                    if (content) content.classList.add('collapsed');
                    if (toggle) toggle.textContent = '‚ñ∂';
                    sectionState[sectionId] = 'collapsed';
                }
            }
            localStorage.setItem('deicingMonitorSections', JSON.stringify(sectionState));
        }

        function toggleHistory(id) {
            const el = document.getElementById(id);
            if (el) {
                el.classList.toggle('show');
            }
        }

        function toggleTafList() {
            const list = document.getElementById('tafExpandedList');
            const icon = document.getElementById('tafToggleIcon');
            if (list && icon) {
                if (list.style.display === 'none') {
                    list.style.display = 'block';
                    icon.textContent = '‚ñ≤ Show less';
                } else {
                    list.style.display = 'none';
                    icon.textContent = '‚ñº Show all';
                }
            }
        }

        function togglePirepList() {
            const list = document.getElementById('pirepExpandedList');
            const icon = document.getElementById('pirepToggleIcon');
            if (list && icon) {
                if (list.style.display === 'none') {
                    list.style.display = 'block';
                    icon.textContent = '‚ñ≤';
                } else {
                    list.style.display = 'none';
                    icon.textContent = '‚ñº';
                }
            }
        }

        function toggleAirmetList() {
            const list = document.getElementById('airmetExpandedList');
            const icon = document.getElementById('airmetToggleIcon');
            if (list && icon) {
                if (list.style.display === 'none') {
                    list.style.display = 'block';
                    icon.textContent = '‚ñ≤';
                } else {
                    list.style.display = 'none';
                    icon.textContent = '‚ñº';
                }
            }
        }

        function renderSection(title, airports) {
            let html = `
                <div class="section">
                    <div class="section-header"><h2>${title}</h2></div>
                    <div class="airport-list">
            `;

            for (const apt of airports) {
                const name = AIRPORT_NAMES[apt.icao] || apt.icao;
                const wx = apt.weather.length > 0 ? apt.weather.join(' ') : '‚Äî';
                const frClass = `fr-${apt.flight_rules.toLowerCase()}`;
                const rank = AIRPORTS.indexOf(apt.icao) + 1;
                const metarUrl = `https://aviationweather.gov/data/metar/?id=${apt.icao}&hours=6`;
                const notamUrl = `https://notams.aim.faa.gov/notamSearch/`;
                const timeSince = getTimeSince(apt.obs_time);
                const historyId = `history-${apt.icao}`;
                
                // Format wind info
                let windHtml = '';
                if (apt.wind_speed !== null) {
                    let windClass = '';
                    let windText = '';
                    
                    if (apt.wind_variable) {
                        windText = `VRB${apt.wind_speed}kt`;
                    } else if (apt.wind_dir !== null) {
                        windText = `${String(apt.wind_dir).padStart(3, '0')}¬∞/${apt.wind_speed}kt`;
                    } else {
                        windText = `${apt.wind_speed}kt`;
                    }
                    
                    if (apt.wind_gust) {
                        windText += `G${apt.wind_gust}`;
                        windClass = apt.wind_gust >= 25 ? 'strong' : 'gusty';
                    } else if (apt.wind_speed >= 20) {
                        windClass = 'strong';
                    }
                    
                    windHtml = `<span class="wind-info ${windClass}">üí® ${windText}</span>`;
                }
                
                // Format visibility
                let visHtml = '';
                if (apt.visibility_text) {
                    let visClass = apt.visibility < 3 ? 'low' : '';
                    visHtml = `<span class="vis-info ${visClass}">üëÅ ${apt.visibility_text}</span>`;
                }
                
                // Build badges HTML
                let badgesHtml = '<div class="badges">';
                
                // Traffic program badges (highest priority)
                if (apt.traffic_programs) {
                    for (const prog of apt.traffic_programs) {
                        if (prog.type === 'GROUND STOP') {
                            badgesHtml += `<span class="badge badge-gs" title="${prog.reason}">GS</span>`;
                        } else if (prog.type === 'GDP') {
                            badgesHtml += `<span class="badge badge-gdp" title="${prog.reason}">GDP</span>`;
                        } else if (prog.type === 'CLOSED') {
                            badgesHtml += `<span class="badge badge-gs" title="${prog.reason}">CLOSED</span>`;
                        } else if (prog.type === 'DEICING') {
                            badgesHtml += `<span class="badge badge-deicing" title="${prog.reason}">‚ùÑÔ∏è DEICING</span>`;
                        } else {
                            badgesHtml += `<span class="badge badge-delay" title="${prog.reason}">${prog.type}</span>`;
                        }
                    }
                }
                
                // Terminal constraint badge from FAA Advisory (if no GDP/GS active)
                const constraint = faaAdvisoryData.terminalConstraints[apt.icao];
                if (constraint && !apt.traffic_programs) {
                    badgesHtml += `<span class="badge badge-constraint" title="Terminal Constraint">‚ö†Ô∏è ${constraint}</span>`;
                }
                
                // Runway/taxiway closure badge
                const closures = faaAdvisoryData.runwayClosures[apt.icao];
                if (closures && closures.length > 0) {
                    badgesHtml += `<span class="badge badge-closure" title="${closures.join(', ')}">üöß RWY WORK</span>`;
                }
                
                // Planned ground stop badge
                const planned = faaAdvisoryData.terminalPlanned[apt.icao];
                if (planned && planned.length > 0) {
                    badgesHtml += `<span class="badge badge-planned" title="${planned.join(', ')}">‚è≥ GS POSS</span>`;
                }
                
                // Rush hour badge
                if (apt.rush_status) {
                    badgesHtml += `<span class="badge badge-rush">${apt.rush_status}</span>`;
                }
                
                // Frost risk badge (night + cold)
                if (apt.frost_risk) {
                    badgesHtml += `<span class="badge badge-frost">üåô FROST RISK</span>`;
                }
                
                // TAF frozen precip forecast badge
                if (apt.taf && apt.taf.frozenForecasts && apt.taf.frozenForecasts.length > 0) {
                    const fc = apt.taf.frozenForecasts[0];
                    badgesHtml += `<span class="badge badge-taf-sn" title="${fc.raw}">TAF: ${fc.wx}</span>`;
                }
                
                // Hub badge
                if (apt.hub_airlines) {
                    const hubText = apt.hub_airlines.length > 2 
                        ? apt.hub_airlines.slice(0, 2).join('/') + '+' 
                        : apt.hub_airlines.join('/');
                    badgesHtml += `<span class="badge badge-hub" title="${apt.hub_airlines.join(', ')} hub">HUB: ${hubText}</span>`;
                }
                
                badgesHtml += '</div>';
                
                // Recent frozen precip indicator
                let recentFrozenHtml = '';
                if (apt.had_recent_frozen && !apt.frozen_precip) {
                    const frozenAgo = apt.last_frozen_time ? getTimeSince(apt.last_frozen_time).text : 'recently';
                    recentFrozenHtml = `<div class="recent-frozen-note">‚ùÑÔ∏è ${apt.recent_frozen_types.join(', ')} ended ${frozenAgo}</div>`;
                }
                
                // TAF forecast indicator
                let tafHtml = '';
                if (apt.taf && apt.taf.frozenForecasts && apt.taf.frozenForecasts.length > 0 && !apt.frozen_precip) {
                    tafHtml = `<div class="taf-forecast">üìã TAF: ${apt.taf.frozenForecasts[0].wx} forecast</div>`;
                }
                
                // HOT estimate
                let hotHtml = '';
                if (apt.hot_estimate) {
                    const hot = apt.hot_estimate;
                    const precipName = hot.precipType.replace('_', ' ');
                    hotHtml = `<div class="hot-estimate ${hot.status}">‚è±Ô∏è HOT ~${hot.minutes} min (${precipName})</div>`;
                }
                
                // Runway status
                let runwayHtml = '';
                if (apt.runway_status) {
                    const rwy = apt.runway_status;
                    if (rwy.status !== 'good' || rwy.brakingAction) {
                        let brakingHtml = '';
                        if (rwy.brakingAction) {
                            const brakingClass = rwy.brakingAction === 'GOOD' ? 'braking-good' : 
                                                rwy.brakingAction === 'MEDIUM' || rwy.brakingAction === 'FAIR' ? 'braking-fair' :
                                                rwy.brakingAction === 'POOR' ? 'braking-poor' : 'braking-nil';
                            brakingHtml = `<span class="braking-action ${brakingClass}">BRAKING: ${rwy.brakingAction}</span>`;
                        }
                        
                        let statusText = rwy.message || `${rwy.available}/${rwy.total} rwys`;
                        runwayHtml = `<div class="runway-status ${rwy.status}">üõ¨ ${statusText} ${brakingHtml}</div>`;
                    }
                }
                
                let historyHtml = '';
                if (apt.history && apt.history.length > 0) {
                    historyHtml = `<div class="history" id="${historyId}"><div class="history-title">Last ${apt.history.length} observations</div>`;
                    for (const h of apt.history) {
                        const hTime = h.obs_time ? h.obs_time.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit', timeZoneName: 'short'}) : 'N/A';
                        const hWx = h.weather.length > 0 ? h.weather.join(' ') : '‚Äî';
                        const hTemp = h.temp_c !== null ? `${h.temp_c}¬∞C / ${tempToF(h.temp_c)}¬∞F` : 'N/A';
                        // Format wind for history
                        let hWind = '';
                        if (h.wind_speed !== null) {
                            hWind = h.wind_variable ? `VRB${h.wind_speed}` : `${h.wind_speed}kt`;
                            if (h.wind_gust) hWind += `G${h.wind_gust}`;
                        }
                        // Highlight rows with frozen precip
                        const hasFrozen = h.weather.some(w => FROZEN_PRECIP.includes(w));
                        const rowStyle = hasFrozen ? 'background: #3d2850;' : '';
                        historyHtml += `<div class="history-row" style="${rowStyle}"><span class="time">${hTime}</span><span class="temp">${hTemp}</span><span class="wx">${hWx}</span>${hWind ? `<span style="color:#3498db;margin-left:5px;">${hWind}</span>` : ''}</div>`;
                    }
                    historyHtml += '</div>';
                }
                
                html += `
                    <div class="airport-card" onclick="toggleHistory('${historyId}')">
                        <div class="airport-main">
                            <div class="left">
                                <div class="icao">#${rank} ${apt.icao}</div>
                                <div>
                                    <div class="name">
                                        <a href="${metarUrl}" target="_blank" onclick="event.stopPropagation();" title="View METARs">${name} ‚Üó</a>
                                        <a href="${notamUrl}" target="_blank" onclick="event.stopPropagation();" class="notam-link" title="FAA NOTAM Search">üìã</a>
                                    </div>
                                    <div class="weather">${wx} <span class="flight-rules ${frClass}">${apt.flight_rules}</span> ${windHtml} ${visHtml}</div>
                                    <div class="obs-time ${timeSince.stale ? 'stale' : ''}">${timeSince.text}</div>
                                    ${recentFrozenHtml}
                                    ${tafHtml}
                                    ${hotHtml}
                                    ${runwayHtml}
                                    ${badgesHtml}
                                </div>
                            </div>
                            <div class="right">
                                <div class="trend ${apt.trend.class}" title="${apt.trend.text}">${apt.trend.symbol}</div>
                                <div class="temp">
                                    <div class="temp-value">${apt.temp_c}¬∞</div>
                                    <div class="temp-f">${tempToF(apt.temp_c)}¬∞F</div>
                                </div>
                            </div>
                        </div>
                        <div class="expand-hint">Tap to see history</div>
                        ${historyHtml}
                    </div>
                `;
            }

            html += '</div></div>';
            return html;
        }

        function setAutoRefresh() {
            const mins = parseInt(document.getElementById('autoRefresh').value);
            if (refreshInterval) clearInterval(refreshInterval);
            if (mins > 0) {
                refreshInterval = setInterval(fetchData, mins * 60 * 1000);
            }
        }

        // Start
        fetchData();
        setAutoRefresh();
        
        // Timezone clock update
        function updateTimezones() {
            const now = new Date();
            
            const formatTime = (tz) => {
                try {
                    return now.toLocaleTimeString('en-US', { 
                        timeZone: tz, 
                        hour: '2-digit', 
                        minute: '2-digit',
                        hour12: false 
                    });
                } catch (e) {
                    return '--:--';
                }
            };
            
            // Zulu/UTC
            const zuluEl = document.getElementById('tz-zulu');
            if (zuluEl) zuluEl.textContent = formatTime('UTC') + 'Z';
            
            // Eastern
            const eastEl = document.getElementById('tz-eastern');
            if (eastEl) eastEl.textContent = formatTime('America/New_York');
            
            // Central
            const centEl = document.getElementById('tz-central');
            if (centEl) centEl.textContent = formatTime('America/Chicago');
            
            // Mountain
            const mtEl = document.getElementById('tz-mountain');
            if (mtEl) mtEl.textContent = formatTime('America/Denver');
            
            // Pacific
            const pacEl = document.getElementById('tz-pacific');
            if (pacEl) pacEl.textContent = formatTime('America/Los_Angeles');
        }
        
        updateTimezones();
        setInterval(updateTimezones, 1000);
    </script>
</body>
</html>
