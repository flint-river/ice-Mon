<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Airport Deicing Monitor - Top 110</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a2e;
            color: #eee;
            min-height: 100vh;
            padding: 15px;
        }
        
        .container {
            max-width: 800px;
            margin: 0 auto;
        }
        
        header {
            text-align: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid #333;
        }
        
        h1 {
            font-size: 22px;
            margin-bottom: 8px;
            color: #fff;
        }
        
        .subtitle {
            color: #4a90d9;
            font-size: 13px;
            margin-bottom: 5px;
        }
        
        .timestamp {
            color: #888;
            font-size: 12px;
        }
        
        .timezone-box {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 8px;
            margin: 15px 0;
            padding: 12px;
            background: #252540;
            border-radius: 8px;
        }
        
        .tz-item {
            text-align: center;
            padding: 4px 12px;
            min-width: 70px;
        }
        
        .tz-item .tz-time {
            font-family: 'Courier New', monospace;
            font-size: 18px;
            font-weight: bold;
            color: #fff;
        }
        
        .tz-item .tz-label {
            font-size: 10px;
            color: #888;
            text-transform: uppercase;
            margin-top: 2px;
        }
        
        .tz-item.zulu .tz-time {
            color: #4a90d9;
        }
        
        .tz-item.zulu .tz-label {
            color: #4a90d9;
        }
        
        .tz-item.local .tz-time {
            color: #2ecc71;
        }
        
        .tz-item.local .tz-label {
            color: #2ecc71;
        }
        
        .tz-toggle {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 28px;
            height: 28px;
            background: #1a1a2e;
            border: 1px solid #444;
            border-radius: 50%;
            color: #888;
            font-size: 16px;
            cursor: pointer;
            align-self: center;
            transition: all 0.2s;
        }
        
        .tz-toggle:hover {
            background: #333;
            color: #fff;
            border-color: #666;
        }
        
        .tz-toggle.expanded {
            transform: rotate(45deg);
        }
        
        .timezone-box-expanded {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 8px;
            margin: 0 0 15px 0;
            padding: 10px;
            background: #1a1a2e;
            border: 1px solid #333;
            border-radius: 0 0 8px 8px;
            margin-top: -8px;
        }
        
        .timezone-box-expanded .tz-item .tz-time {
            font-size: 14px;
        }
        
        .timezone-box-expanded .tz-item .tz-label {
            font-size: 9px;
        }
        
        .controls {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        
        .search-box {
            display: flex;
            gap: 8px;
            width: 100%;
            max-width: 400px;
            margin-bottom: 10px;
        }
        
        .search-box input {
            flex: 1;
            background: #252540;
            color: #fff;
            border: 1px solid #444;
            padding: 12px;
            border-radius: 6px;
            font-size: 14px;
        }
        
        .search-box input::placeholder {
            color: #666;
        }
        
        .search-box button {
            padding: 12px 16px;
            font-size: 14px;
        }
        
        .filter-buttons {
            display: flex;
            gap: 4px;
            flex-wrap: wrap;
            justify-content: center;
            margin-bottom: 12px;
        }
        
        .filter-btn {
            background: #252540;
            color: #888;
            border: 1px solid #444;
            padding: 5px 8px;
            border-radius: 4px;
            font-size: 11px;
            cursor: pointer;
        }
        
        .filter-btn.active {
            background: #4a90d9;
            color: white;
            border-color: #4a90d9;
        }
        
        .filter-btn:hover {
            border-color: #666;
        }
        
        .section-controls {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-bottom: 15px;
        }
        
        .section-controls button {
            background: #2a2a4a;
            border: 1px solid #444;
            color: #888;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
        }
        
        .section-controls button:hover {
            background: #3a3a5a;
            color: #fff;
        }
        
        button {
            background: #4a90d9;
            color: white;
            border: none;
            padding: 14px 28px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 500;
            touch-action: manipulation;
        }
        
        button:disabled {
            background: #555;
        }
        
        .auto-refresh {
            display: flex;
            align-items: center;
            gap: 8px;
            color: #888;
            font-size: 14px;
        }
        
        .auto-refresh select {
            background: #252540;
            color: #fff;
            border: 1px solid #444;
            padding: 12px;
            border-radius: 6px;
            font-size: 16px;
        }
        
        .summary {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-bottom: 25px;
        }
        
        .summary-card {
            background: #252540;
            padding: 15px;
            border-radius: 10px;
            text-align: center;
        }
        
        .summary-card .count {
            font-size: 32px;
            font-weight: bold;
            margin-bottom: 3px;
        }
        
        .summary-card .label {
            font-size: 11px;
            color: #888;
            text-transform: uppercase;
        }
        
        .summary-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            transition: all 0.2s ease;
        }
        
        .summary-card.active { border-left: 4px solid #e74c3c; }
        .summary-card.active .count { color: #e74c3c; }
        
        .summary-card.likely { border-left: 4px solid #f39c12; }
        .summary-card.likely .count { color: #f39c12; }
        
        .summary-card.possible { border-left: 4px solid #f1c40f; }
        .summary-card.possible .count { color: #f1c40f; }
        
        .summary-card.none { border-left: 4px solid #2ecc71; }
        .summary-card.none .count { color: #2ecc71; }
        
        .summary-card.residual { border-left: 4px solid #9b59b6; }
        .summary-card.residual .count { color: #9b59b6; }
        
        .summary-card.atc { border-left: 4px solid #e74c3c; }
        .summary-card.atc .count { color: #e74c3c; }
        
        .summary-card.deicing-prog { border-left: 4px solid #1e90ff; }
        .summary-card.deicing-prog .count { color: #1e90ff; }
        
        .summary-card.runway-alert { border-left: 4px solid #f39c12; }
        .summary-card.runway-alert .count { color: #f39c12; }
        
        .summary-card.taf-warn { border-left: 4px solid #9b59b6; }
        .summary-card.taf-warn .count { color: #9b59b6; }
        
        .summary-card.frost { border-left: 4px solid #3498db; }
        .summary-card.frost .count { color: #3498db; }
        
        .summary-card.closure { border-left: 4px solid #8b4513; }
        .summary-card.closure .count { color: #cd853f; }
        
        .summary-card.planned { border-left: 4px solid #2e8b8b; }
        .summary-card.planned .count { color: #3ce7e7; }
        
        .summary-card.disabled {
            opacity: 0.4;
            cursor: default;
        }
        
        .summary-card.disabled:hover {
            transform: none;
            box-shadow: none;
        }
        
        .summary-dashboard {
            margin-bottom: 20px;
        }
        
        .summary-row {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
            margin-bottom: 8px;
        }
        
        @media (max-width: 600px) {
            .summary-row {
                grid-template-columns: repeat(2, 1fr);
            }
        }
        
        .summary-card {
            cursor: pointer;
        }
        
        .section {
            margin-bottom: 25px;
        }
        
        .section-header {
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 1px solid #333;
        }
        
        .section-header h2 {
            font-size: 16px;
            font-weight: 600;
        }
        
        .airport-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .airport-card {
            background: #252540;
            padding: 12px 15px;
            border-radius: 8px;
            cursor: pointer;
            transition: background 0.2s;
            text-decoration: none;
            color: inherit;
            display: block;
        }
        
        .airport-card:hover {
            background: #333355;
        }
        
        .airport-main {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .airport-card .left {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .airport-card .icao {
            font-family: 'Courier New', monospace;
            font-weight: bold;
            font-size: 14px;
            background: #1a1a2e;
            padding: 6px 8px;
            border-radius: 4px;
        }
        
        .airport-card .name {
            font-weight: 500;
            font-size: 14px;
        }
        
        .airport-card .name a {
            color: #7db8eb;
            text-decoration: none;
        }
        
        .airport-card .name a:hover {
            text-decoration: underline;
        }
        
        .airport-card .notam-link {
            margin-left: 8px;
            font-size: 14px;
            opacity: 0.6;
            text-decoration: none;
        }
        
        .airport-card .notam-link:hover {
            opacity: 1;
            text-decoration: none;
        }
        
        .airport-card .weather {
            font-size: 11px;
            color: #888;
            margin-top: 2px;
        }
        
        .airport-card .right {
            text-align: right;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .airport-card .temp {
            text-align: right;
        }
        
        .airport-card .temp-value {
            font-size: 18px;
            font-weight: bold;
        }
        
        .airport-card .temp-f {
            font-size: 11px;
            color: #888;
        }
        
        .trend {
            font-size: 20px;
            font-weight: bold;
        }
        
        .trend.warming { color: #e74c3c; }
        .trend.cooling { color: #3498db; }
        .trend.steady { color: #888; }
        
        .obs-time {
            font-size: 10px;
            color: #888;
            margin-top: 4px;
        }
        
        .obs-time.stale {
            color: #e74c3c;
        }
        
        .flight-rules {
            font-size: 9px;
            padding: 2px 5px;
            border-radius: 3px;
            display: inline-block;
            margin-top: 3px;
        }
        
        .fr-vfr { background: #2ecc71; color: #000; }
        .fr-mvfr { background: #3498db; color: #fff; }
        .fr-ifr { background: #e74c3c; color: #fff; }
        .fr-lifr { background: #9b59b6; color: #fff; }
        
        .history {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid #333;
            display: none;
        }
        
        .history.show {
            display: block;
        }
        
        .history-title {
            font-size: 11px;
            color: #888;
            margin-bottom: 8px;
            text-transform: uppercase;
        }
        
        .history-header {
            display: flex;
            justify-content: space-between;
            font-size: 10px;
            padding: 2px 0 4px 0;
            border-bottom: 1px solid #333;
            margin-bottom: 4px;
            gap: 6px;
            color: #666;
            text-transform: uppercase;
        }
        
        .history-header span {
            flex-shrink: 0;
        }
        
        .history-header .time { min-width: 135px; }
        .history-header .ceiling { min-width: 50px; }
        .history-header .wx { flex: 1; min-width: 50px; }
        .history-header .wind { min-width: 55px; }
        .history-header .temp { min-width: 85px; text-align: right; }
        
        .history-row {
            display: flex;
            justify-content: space-between;
            font-size: 11px;
            padding: 4px 0;
            border-bottom: 1px solid #1a1a2e;
            gap: 6px;
        }
        
        .history-row .time {
            color: #888;
            min-width: 135px;
            flex-shrink: 0;
            font-size: 10px;
        }
        
        .history-row .ceiling {
            color: #4a90d9;
            min-width: 50px;
            flex-shrink: 0;
        }
        
        .history-row .wx {
            color: #aaa;
            flex: 1;
            min-width: 50px;
        }
        
        .history-row .wind {
            color: #3498db;
            min-width: 55px;
            flex-shrink: 0;
        }
        
        .history-row .temp {
            font-weight: bold;
            min-width: 85px;
            text-align: right;
            flex-shrink: 0;
        }
        
        .loading, .error {
            text-align: center;
            padding: 40px 20px;
        }
        
        .loading .spinner {
            width: 36px;
            height: 36px;
            border: 3px solid #333;
            border-top-color: #4a90d9;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        .error {
            background: #3d1f1f;
            border-radius: 8px;
            color: #ff6b6b;
        }
        
        .error button {
            margin-top: 15px;
            background: #c0392b;
        }
        
        footer {
            text-align: center;
            margin-top: 30px;
            padding-top: 15px;
            border-top: 1px solid #333;
            color: #555;
            font-size: 11px;
        }
        
        .status-msg {
            text-align: center;
            padding: 10px;
            margin-bottom: 15px;
            border-radius: 6px;
            font-size: 13px;
        }
        
        .status-msg.info { background: #1a3a5c; color: #7db8eb; }

        .expand-hint {
            font-size: 10px;
            color: #666;
            margin-top: 4px;
        }
        
        .residual-badge {
            background: #9b59b6;
            color: white;
            font-size: 9px;
            padding: 2px 6px;
            border-radius: 3px;
            margin-left: 8px;
            display: inline-block;
        }
        
        .recent-frozen-note {
            font-size: 10px;
            color: #9b59b6;
            margin-top: 3px;
        }
        
        .badges {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            margin-top: 4px;
        }
        
        .badge {
            font-size: 9px;
            padding: 2px 6px;
            border-radius: 3px;
            display: inline-block;
        }
        
        .badge-hub {
            background: #2c3e50;
            color: #bdc3c7;
        }
        
        .badge-rush {
            background: #d35400;
            color: white;
        }
        
        .badge-gdp {
            background: #c0392b;
            color: white;
            animation: pulse 2s infinite;
        }
        
        .badge-gs {
            background: #8e44ad;
            color: white;
            animation: pulse 1.5s infinite;
        }
        
        .badge-delay {
            background: #e67e22;
            color: white;
        }
        
        .badge-constraint {
            background: #b8860b;
            color: white;
        }
        
        .badge-closure {
            background: #8b4513;
            color: white;
        }
        
        .badge-planned {
            background: #2e8b8b;
            color: white;
        }
        
        .badge-deicing {
            background: #1e90ff;
            color: white;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        
        .traffic-section {
            background: #2d1f1f;
            border: 1px solid #5c3a3a;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 20px;
        }
        
        .traffic-section h3 {
            font-size: 14px;
            color: #e74c3c;
            margin-bottom: 10px;
        }
        
        /* Collapsible section styles */
        .collapsible-section {
            margin-bottom: 15px;
        }
        
        .section-header {
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 12px;
            border-radius: 8px 8px 0 0;
            user-select: none;
        }
        
        .section-header:hover {
            filter: brightness(1.1);
        }
        
        .section-header h3 {
            margin: 0;
            font-size: 14px;
        }
        
        .section-toggle {
            font-size: 12px;
            opacity: 0.7;
        }
        
        .section-content {
            padding: 10px 12px;
            border-radius: 0 0 8px 8px;
        }
        
        .section-content.collapsed {
            display: none;
        }
        
        .collapsible-section.collapsed .section-header {
            border-radius: 8px;
        }
        
        /* Section color themes */
        .section-traffic .section-header { background: #2d1f1f; border: 1px solid #5c3a3a; border-bottom: none; }
        .section-traffic .section-header h3 { color: #e74c3c; }
        .section-traffic .section-content { background: #2d1f1f; border: 1px solid #5c3a3a; border-top: none; }
        .section-traffic.collapsed .section-header { border-bottom: 1px solid #5c3a3a; }
        
        .section-deicing .section-header { background: #1f2d3d; border: 1px solid #3a68a0; border-bottom: none; }
        .section-deicing .section-header h3 { color: #1e90ff; }
        .section-deicing .section-content { background: #1f2d3d; border: 1px solid #3a68a0; border-top: none; }
        .section-deicing.collapsed .section-header { border-bottom: 1px solid #3a68a0; }
        
        .section-constraint .section-header { background: #2d2d1f; border: 1px solid #5c5c3a; border-bottom: none; }
        .section-constraint .section-header h3 { color: #e7c43c; }
        .section-constraint .section-content { background: #2d2d1f; border: 1px solid #5c5c3a; border-top: none; }
        .section-constraint.collapsed .section-header { border-bottom: 1px solid #5c5c3a; }
        
        .section-planned .section-header { background: #1f2d2d; border: 1px solid #3a5c5c; border-bottom: none; }
        .section-planned .section-header h3 { color: #3ce7e7; }
        .section-planned .section-content { background: #1f2d2d; border: 1px solid #3a5c5c; border-top: none; }
        .section-planned.collapsed .section-header { border-bottom: 1px solid #3a5c5c; }
        
        .section-closure .section-header { background: #2d251f; border: 1px solid #5c4a3a; border-bottom: none; }
        .section-closure .section-header h3 { color: #e79c3c; }
        .section-closure .section-content { background: #2d251f; border: 1px solid #5c4a3a; border-top: none; }
        .section-closure.collapsed .section-header { border-bottom: 1px solid #5c4a3a; }
        
        .section-runway .section-header { background: #2d2d1f; border: 1px solid #8b6914; border-bottom: none; }
        .section-runway .section-header h3 { color: #ffa500; }
        .section-runway .section-content { background: #2d2d1f; border: 1px solid #8b6914; border-top: none; }
        .section-runway.collapsed .section-header { border-bottom: 1px solid #8b6914; }
        
        .section-taf .section-header { background: #1f2d3d; border: 1px solid #3a5068; border-bottom: none; }
        .section-taf .section-header h3 { color: #4a90d9; }
        .section-taf .section-content { background: #1f2d3d; border: 1px solid #3a5068; border-top: none; }
        .section-taf.collapsed .section-header { border-bottom: 1px solid #3a5068; }
        
        /* Deicing category section styles */
        .section-deice-active .section-header { background: #3d1f1f; border: 1px solid #e74c3c; border-bottom: none; }
        .section-deice-active .section-header h3 { color: #e74c3c; }
        .section-deice-active .section-content { background: #2d1a1a; border: 1px solid #e74c3c; border-top: none; }
        .section-deice-active.collapsed .section-header { border-bottom: 1px solid #e74c3c; }
        
        .section-deice-residual .section-header { background: #2d1f3d; border: 1px solid #9b59b6; border-bottom: none; }
        .section-deice-residual .section-header h3 { color: #9b59b6; }
        .section-deice-residual .section-content { background: #251a2d; border: 1px solid #9b59b6; border-top: none; }
        .section-deice-residual.collapsed .section-header { border-bottom: 1px solid #9b59b6; }
        
        .section-deice-likely .section-header { background: #3d2d1f; border: 1px solid #f39c12; border-bottom: none; }
        .section-deice-likely .section-header h3 { color: #f39c12; }
        .section-deice-likely .section-content { background: #2d251a; border: 1px solid #f39c12; border-top: none; }
        .section-deice-likely.collapsed .section-header { border-bottom: 1px solid #f39c12; }
        
        .section-deice-possible .section-header { background: #3d3d1f; border: 1px solid #f1c40f; border-bottom: none; }
        .section-deice-possible .section-header h3 { color: #f1c40f; }
        .section-deice-possible .section-content { background: #2d2d1a; border: 1px solid #f1c40f; border-top: none; }
        .section-deice-possible.collapsed .section-header { border-bottom: 1px solid #f1c40f; }
        
        .section-deice-none .section-header { background: #1f3d1f; border: 1px solid #2ecc71; border-bottom: none; }
        .section-deice-none .section-header h3 { color: #2ecc71; }
        .section-deice-none .section-content { background: #1a2d1a; border: 1px solid #2ecc71; border-top: none; }
        .section-deice-none.collapsed .section-header { border-bottom: 1px solid #2ecc71; }
        
        .traffic-item {
            font-size: 12px;
            padding: 6px 0;
            border-bottom: 1px solid #3d2a2a;
        }
        
        .traffic-item:last-child {
            border-bottom: none;
        }
        
        .traffic-item .airport {
            font-weight: bold;
            color: #fff;
        }
        
        .traffic-item .program {
            color: #e74c3c;
        }
        
        .traffic-item .reason {
            color: #888;
            font-size: 11px;
        }
        
        .constraint-section {
            background: #2d2d1f;
            border: 1px solid #5c5c3a;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 15px;
        }
        
        .constraint-section h3 {
            font-size: 14px;
            color: #e7c43c;
            margin-bottom: 10px;
        }
        
        .constraint-item {
            font-size: 12px;
            padding: 6px 0;
            border-bottom: 1px solid #3d3d2a;
        }
        
        .constraint-item:last-child {
            border-bottom: none;
        }
        
        .constraint-item .airport {
            font-weight: bold;
            color: #fff;
        }
        
        .constraint-item .constraint-type {
            color: #e7c43c;
        }
        
        .planned-section {
            background: #1f2d2d;
            border: 1px solid #3a5c5c;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 15px;
        }
        
        .planned-section h3 {
            font-size: 14px;
            color: #3ce7e7;
            margin-bottom: 10px;
        }
        
        .planned-item {
            font-size: 12px;
            padding: 6px 0;
            border-bottom: 1px solid #2a3d3d;
            color: #aaa;
        }
        
        .planned-item:last-child {
            border-bottom: none;
        }
        
        .planned-item .airport {
            font-weight: bold;
            color: #fff;
        }
        
        .closure-section {
            background: #2d251f;
            border: 1px solid #5c4a3a;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 15px;
        }
        
        .closure-section h3 {
            font-size: 14px;
            color: #e79c3c;
            margin-bottom: 10px;
        }
        
        .closure-item {
            font-size: 12px;
            padding: 6px 0;
            border-bottom: 1px solid #3d352a;
            color: #aaa;
        }
        
        .closure-item:last-child {
            border-bottom: none;
        }
        
        .closure-item .airport {
            font-weight: bold;
            color: #fff;
        }
        
        .deicing-section {
            background: #1f2d3d;
            border: 1px solid #3a68a0;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 15px;
        }
        
        .deicing-section h3 {
            font-size: 14px;
            color: #1e90ff;
            margin-bottom: 10px;
        }
        
        .deicing-item {
            font-size: 12px;
            padding: 6px 0;
            border-bottom: 1px solid #2a3d5d;
            color: #aaa;
        }
        
        .deicing-item:last-child {
            border-bottom: none;
        }
        
        .deicing-item .airport {
            font-weight: bold;
            color: #fff;
        }
        
        .forecast-section {
            background: #1f2d3d;
            border: 1px solid #3a5068;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 15px;
        }
        
        .forecast-section h3 {
            font-size: 14px;
            color: #4a90d9;
            margin-bottom: 10px;
        }
        
        .forecast-section h3[onclick]:hover {
            color: #7db8eb;
        }
        
        .forecast-note {
            font-size: 11px;
            color: #7db8eb;
            padding: 6px 0;
            border-bottom: 1px solid #2a4058;
            cursor: pointer;
        }
        
        .forecast-note:hover {
            background: #1a3050;
        }
        
        .forecast-note:last-child {
            border-bottom: none;
        }
        
        .forecast-note .airport {
            font-weight: bold;
            color: #fff;
        }
        
        .forecast-note .time {
            color: #f39c12;
        }
        
        .forecast-note .taf-expand-icon {
            color: #4a90d9;
            font-size: 10px;
            margin-left: 8px;
        }
        
        .taf-full {
            display: none;
            background: #0d1f30;
            border: 1px solid #2a4058;
            border-radius: 4px;
            padding: 8px;
            margin-top: 6px;
            font-family: 'Courier New', monospace;
            font-size: 10px;
            color: #aaa;
            white-space: pre-wrap;
            word-break: break-word;
            line-height: 1.4;
        }
        
        .taf-full.show {
            display: block;
        }
        
        .taf-inline {
            display: none;
            background: #1a2d40;
            border: 1px solid #2a4058;
            border-radius: 4px;
            padding: 4px 8px;
            margin-top: 4px;
            font-family: 'Courier New', monospace;
            font-size: 9px;
            color: #7db8eb;
            cursor: pointer;
            max-width: 100%;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        .taf-inline.expanded {
            display: block;
            white-space: pre-wrap;
            word-break: break-word;
        }
        
        .taf-inline:hover {
            background: #253d55;
        }
        
        .taf-inline.expanded {
            white-space: pre-wrap;
            word-break: break-word;
        }
        
        .badge-frost {
            background: #2980b9;
            color: white;
        }
        
        .badge-taf-sn {
            background: #8e44ad;
            color: white;
        }
        
        .wind-info {
            font-size: 11px;
            color: #3498db;
            margin-top: 2px;
        }
        
        .wind-info.gusty {
            color: #e67e22;
        }
        
        .wind-info.strong {
            color: #e74c3c;
        }
        
        .vis-info {
            font-size: 10px;
            color: #888;
        }
        
        .vis-info.low {
            color: #e74c3c;
        }
        
        .hot-estimate {
            font-size: 10px;
            color: #1abc9c;
            margin-top: 3px;
            padding: 3px 6px;
            background: #1a3d3d;
            border-radius: 4px;
            display: inline-block;
        }
        
        .hot-estimate.short {
            background: #3d2a1a;
            color: #e67e22;
        }
        
        .hot-estimate.expired {
            background: #3d1a1a;
            color: #e74c3c;
        }
        
        .runway-status {
            font-size: 10px;
            margin-top: 4px;
            padding: 4px 8px;
            border-radius: 4px;
        }
        
        .runway-status.good {
            background: #1a3d1a;
            color: #2ecc71;
        }
        
        .runway-status.limited {
            background: #3d3d1a;
            color: #f1c40f;
        }
        
        .runway-status.critical {
            background: #3d1a1a;
            color: #e74c3c;
            animation: pulse 2s infinite;
        }
        
        .braking-action {
            font-size: 9px;
            padding: 2px 5px;
            border-radius: 3px;
            margin-left: 4px;
        }
        
        .braking-good { background: #27ae60; color: white; }
        .braking-fair { background: #f39c12; color: black; }
        .braking-poor { background: #e67e22; color: white; }
        .braking-nil { background: #c0392b; color: white; }
        
        .notam-section {
            background: #2d2a1f;
            border: 1px solid #5c563a;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 15px;
        }
        
        .notam-section h3 {
            font-size: 14px;
            color: #f39c12;
            margin-bottom: 10px;
        }
        
        .notam-item {
            font-size: 11px;
            padding: 6px 0;
            border-bottom: 1px solid #3d3a2a;
        }
        
        .notam-item:last-child {
            border-bottom: none;
        }
        
        .taf-forecast {
            font-size: 10px;
            color: #9b59b6;
            margin-top: 3px;
        }
        
        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .data-panel {
            background: #252540;
            border-radius: 8px;
            padding: 12px;
        }
        
        .data-panel h3 {
            font-size: 13px;
            margin-bottom: 10px;
            padding-bottom: 8px;
            border-bottom: 1px solid #333;
        }
        
        .data-panel h3[onclick]:hover {
            opacity: 0.8;
        }
        
        .compact-list {
            font-size: 11px;
            max-height: 150px;
            overflow-y: auto;
        }
        
        .compact-list .item {
            padding: 4px 0;
            border-bottom: 1px solid #1a1a2e;
        }
        
        /* Runway Map Styles */
        .runway-map-btn {
            background: #2a4a5a;
            color: #4a90d9;
            border: 1px solid #4a90d9;
            border-radius: 4px;
            padding: 2px 6px;
            font-size: 11px;
            cursor: pointer;
            margin-left: 6px;
            white-space: nowrap;
            position: relative;
            z-index: 10;
        }
        
        .runway-map-btn:hover {
            background: #3a5a6a;
        }
        
        .runway-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            z-index: 1000;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }
        
        .runway-modal.active {
            display: flex;
        }
        
        .runway-modal-content {
            background: #1a1a2e;
            border-radius: 12px;
            padding: 20px;
            max-width: 500px;
            width: 100%;
            max-height: 90vh;
            overflow-y: auto;
            border: 1px solid #333;
        }
        
        .runway-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #333;
        }
        
        .runway-modal-title {
            font-size: 18px;
            font-weight: bold;
            color: #fff;
        }
        
        .runway-modal-close {
            background: none;
            border: none;
            color: #888;
            font-size: 24px;
            cursor: pointer;
            padding: 0 5px;
        }
        
        .runway-modal-close:hover {
            color: #fff;
        }
        
        .runway-diagram {
            background: #0d1f0d;
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 15px;
            text-align: center;
        }
        
        .runway-diagram svg {
            max-width: 100%;
        }
        
        .runway-list {
            font-size: 12px;
        }
        
        .runway-item {
            display: flex;
            justify-content: space-between;
            padding: 6px 0;
            border-bottom: 1px solid #252540;
        }
        
        .runway-item:last-child {
            border-bottom: none;
        }
        
        .runway-ident {
            font-weight: bold;
            color: #4a90d9;
        }
        
        .runway-dim {
            color: #888;
        }
        
        .runway-surface {
            color: #aaa;
            text-transform: capitalize;
        }
        
        .runway-closed {
            color: #e74c3c;
            font-weight: bold;
        }
        
        .runway-loading {
            text-align: center;
            padding: 30px;
            color: #888;
        }
        
        .runway-error {
            text-align: center;
            padding: 20px;
            color: #e74c3c;
        }
        
        .runway-faa-link {
            display: block;
            text-align: center;
            margin-top: 15px;
            padding: 10px;
            background: #252540;
            border-radius: 6px;
            color: #4a90d9;
            text-decoration: none;
        }
        
        .runway-faa-link:hover {
            background: #303050;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>&#x1F6EB; Airport Deicing Monitor</h1>
            <div class="subtitle">Top 110 US + Canadian Airports &bull; Search Any Airport Worldwide</div>
            <div class="timestamp" id="timestamp">Loading...</div>
        </header>
        
        <div class="timezone-box" id="timezoneBox">
            <div class="tz-item zulu">
                <div class="tz-time" id="tz-zulu">--:--</div>
                <div class="tz-label">Zulu</div>
            </div>
            <div class="tz-item local">
                <div class="tz-time" id="tz-local">--:--</div>
                <div class="tz-label" id="tz-local-label">Local</div>
            </div>
            <div class="tz-toggle" id="tzToggle" onclick="toggleAllTimezones()" title="Show all US timezones">+</div>
        </div>
        <div class="timezone-box-expanded" id="timezoneBoxExpanded" style="display:none;">
            <div class="tz-item">
                <div class="tz-time" id="tz-eastern">--:--</div>
                <div class="tz-label">Eastern</div>
            </div>
            <div class="tz-item">
                <div class="tz-time" id="tz-central">--:--</div>
                <div class="tz-label">Central</div>
            </div>
            <div class="tz-item">
                <div class="tz-time" id="tz-mountain">--:--</div>
                <div class="tz-label">Mountain</div>
            </div>
            <div class="tz-item">
                <div class="tz-time" id="tz-pacific">--:--</div>
                <div class="tz-label">Pacific</div>
            </div>
        </div>
        
        <div class="controls">
            <div class="search-box">
                <input type="text" id="searchInput" placeholder="&#x1F50D; Search any airport (KORD, EGLL, ORD, LHR...)" oninput="debouncedFilter()" onkeydown="if(event.key==='Enter')filterAirports()">
                <button onclick="clearSearch()">&#x2716;</button>
            </div>
        </div>
        
        <div class="filter-buttons">
            <button class="filter-btn active" data-region="all" onclick="setRegionFilter('all')">All</button>
            <button class="filter-btn" data-region="northeast" onclick="setRegionFilter('northeast')">Northeast</button>
            <button class="filter-btn" data-region="midwest" onclick="setRegionFilter('midwest')">Midwest</button>
            <button class="filter-btn" data-region="south" onclick="setRegionFilter('south')">South</button>
            <button class="filter-btn" data-region="west" onclick="setRegionFilter('west')">West</button>
            <button class="filter-btn" data-region="canada" onclick="setRegionFilter('canada')">Canada</button>
        </div>
        
        <div class="section-controls">
            <button onclick="expandAllSections()">&#x1F4C2; Expand All</button>
            <button onclick="collapseAllSections()">&#x1F4C1; Collapse All</button>
            <button onclick="window.open('https://notams.aim.faa.gov/notamSearch/', '_blank')">&#x1F4CB; NOTAMs</button>
        </div>
        
        <div class="controls">
            <button id="refreshBtn" onclick="fetchData()">&#x1F504; Refresh</button>
            <div class="auto-refresh">
                <span>Auto:</span>
                <select id="autoRefresh" onchange="setAutoRefresh()">
                    <option value="0">Off</option>
                    <option value="5" selected>5m</option>
                    <option value="15">15m</option>
                    <option value="30">30m</option>
                </select>
            </div>
        </div>
        
        <!-- Summary Cards Dashboard -->
        <div id="summaryDashboard" class="summary-dashboard">
            <div class="summary-row">
                <div class="summary-card active" id="card-active" onclick="scrollToSection('section-active')">
                    <div class="count" id="count-active">-</div>
                    <div class="label">&#x1F534; Active</div>
                </div>
                <div class="summary-card residual" id="card-residual" onclick="scrollToSection('section-residual')">
                    <div class="count" id="count-residual">-</div>
                    <div class="label">&#x1F7E3; Residual</div>
                </div>
                <div class="summary-card likely" id="card-likely" onclick="scrollToSection('section-likely')">
                    <div class="count" id="count-likely">-</div>
                    <div class="label">&#x1F7E0; Likely</div>
                </div>
                <div class="summary-card possible" id="card-possible" onclick="scrollToSection('section-possible')">
                    <div class="count" id="count-possible">-</div>
                    <div class="label">&#x1F7E1; Possible</div>
                </div>
            </div>
            <div class="summary-row">
                <div class="summary-card atc" id="card-atc" onclick="scrollToSection('section-traffic')">
                    <div class="count" id="count-atc">-</div>
                    <div class="label">&#x1F6EB; ATC/GDP</div>
                </div>
                <div class="summary-card deicing-prog" id="card-deicing-prog" onclick="scrollToSection('section-deicing')">
                    <div class="count" id="count-deicing-prog">-</div>
                    <div class="label">&#x2744; Deice Prog</div>
                </div>
                <div class="summary-card runway-alert" id="card-runway" onclick="scrollToSection('section-runway')">
                    <div class="count" id="count-runway">-</div>
                    <div class="label">&#x1F6EC; Rwy Alert</div>
                </div>
                <div class="summary-card taf-warn" id="card-taf" onclick="scrollToSection('section-taf')">
                    <div class="count" id="count-taf">-</div>
                    <div class="label">&#x1F4CB; TAF Snow</div>
                </div>
            </div>
            <div class="summary-row">
                <div class="summary-card frost" id="card-frost" onclick="scrollToSection('section-frost')">
                    <div class="count" id="count-frost">-</div>
                    <div class="label">&#x1F319; Frost Risk</div>
                </div>
                <div class="summary-card closure" id="card-closure" onclick="scrollToSection('section-closure')">
                    <div class="count" id="count-closure">-</div>
                    <div class="label">&#x1F6A7; Rwy Closed</div>
                </div>
                <div class="summary-card planned" id="card-planned" onclick="scrollToSection('section-planned')">
                    <div class="count" id="count-planned">-</div>
                    <div class="label">&#x23F3; GS Possible</div>
                </div>
                <div class="summary-card none" id="card-none" onclick="scrollToSection('section-none')">
                    <div class="count" id="count-none">-</div>
                    <div class="label">&#x1F7E2; Clear</div>
                </div>
            </div>
        </div>
        
        <div id="content">
            <div class="loading">
                <div class="spinner"></div>
                <div>Fetching METAR data for 110 airports...</div>
            </div>
        </div>
        
        <footer>
            Data: Aviation Weather Center<br>
            Tap airport to see history  Tap city name to open full METAR
        </footer>
    </div>

    <!-- Runway Map Modal -->
    <div id="runwayModal" class="runway-modal" onclick="closeRunwayModal(event)">
        <div class="runway-modal-content" onclick="event.stopPropagation()">
            <div class="runway-modal-header">
                <div class="runway-modal-title" id="runwayModalTitle">Loading...</div>
                <button class="runway-modal-close" onclick="closeRunwayModal()">&times;</button>
            </div>
            <div id="runwayModalBody">
                <div class="runway-loading">Loading runway data...</div>
            </div>
        </div>
    </div>

    <script>
        // Top 110 US + Canadian airports by passenger volume (interleaved)
        const AIRPORTS = [
            // 1-10
            'KATL', 'KLAX', 'KORD', 'KDFW', 'KDEN', 'CYYZ', 'KJFK', 'KSFO', 'KLAS', 'KMCO',
            // 11-20
            'KSEA', 'KMIA', 'KPHX', 'KEWR', 'KIAH', 'CYVR', 'KBOS', 'KMSP', 'KDTW', 'KFLL',
            // 21-30
            'KPHL', 'KLGA', 'CYUL', 'KBWI', 'KSLC', 'CYYC', 'KDCA', 'KSAN', 'KTPA', 'KAUS',
            // 31-40
            'KIAD', 'KMDW', 'KHNL', 'KSTL', 'KBNA', 'KOAK', 'KSMF', 'KSJC', 'KRDU', 'KMCI',
            // 41-50
            'KCLE', 'KPIT', 'KCLT', 'KPDX', 'KIND', 'CYEG', 'KCVG', 'KMSY', 'KSAT', 'KMKE',
            // 51-60
            'KBUF', 'KPBI', 'KABQ', 'KONT', 'KRSW', 'CYOW', 'KBUR', 'KOMA', 'KRIC', 'KBDL',
            // 61-70
            'KSNA', 'KJAN', 'KCHS', 'KJAX', 'KORF', 'CYWG', 'CYHZ', 'KANC', 'KLIT', 'KELP',
            // 71-80
            'KTUS', 'KOKC', 'KTUL', 'KGRR', 'KDSM', 'KDAY', 'KSYR', 'KPVD', 'KALB', 'KGSO',
            // 81-90
            'KPWM', 'KBTV', 'KROC', 'CYQB', 'CYYT', 'KBHM', 'KLEX', 'KSDF', 'KCMH', 'KCOS',
            // 91-100
            'KBOI', 'KFSD', 'KICT', 'KMSN', 'KLBB', 'KFAR', 'KBIS', 'KDLH', 'KERI', 'KBGR',
            // 101-110
            'KAVL', 'KMYR', 'KSAV', 'KPNS', 'KFWA', 'KLNK', 'KSGF', 'KXNA', 'KCRP', 'KABI'
        ];

        const AIRPORT_NAMES = {
            // Top 50
            'KATL': 'Atlanta', 'KLAX': 'Los Angeles', 'KORD': 'Chicago ORD',
            'KDFW': 'Dallas/Fort Worth', 'KDEN': 'Denver', 'KJFK': 'New York JFK',
            'KSFO': 'San Francisco', 'KLAS': 'Las Vegas', 'KMCO': 'Orlando',
            'KSEA': 'Seattle', 'KMIA': 'Miami', 'KPHX': 'Phoenix', 'KEWR': 'Newark',
            'KIAH': 'Houston IAH', 'KBOS': 'Boston', 'KMSP': 'Minneapolis',
            'KDTW': 'Detroit', 'KFLL': 'Fort Lauderdale', 'KPHL': 'Philadelphia',
            'KLGA': 'New York LGA', 'KBWI': 'Baltimore', 'KSLC': 'Salt Lake City',
            'KDCA': 'Washington DCA', 'KSAN': 'San Diego', 'KTPA': 'Tampa',
            'KAUS': 'Austin', 'KIAD': 'Washington IAD', 'KMDW': 'Chicago MDW',
            'KHNL': 'Honolulu', 'KSTL': 'St. Louis', 'KBNA': 'Nashville',
            'KOAK': 'Oakland', 'KSMF': 'Sacramento', 'KSJC': 'San Jose',
            'KRDU': 'Raleigh-Durham', 'KMCI': 'Kansas City', 'KCLE': 'Cleveland',
            'KPIT': 'Pittsburgh', 'KCLT': 'Charlotte', 'KPDX': 'Portland OR',
            'KIND': 'Indianapolis', 'KCVG': 'Cincinnati', 'KMSY': 'New Orleans',
            'KSAT': 'San Antonio', 'KMKE': 'Milwaukee', 'KBUF': 'Buffalo',
            'KPBI': 'West Palm Beach', 'KABQ': 'Albuquerque', 'KONT': 'Ontario CA',
            'KRSW': 'Fort Myers',
            // 51-75
            'KBUR': 'Burbank', 'KOMA': 'Omaha', 'KRIC': 'Richmond',
            'KBDL': 'Hartford', 'KSNA': 'Orange County', 'KJAN': 'Jackson MS',
            'KCHS': 'Charleston', 'KJAX': 'Jacksonville', 'KORF': 'Norfolk',
            'KANC': 'Anchorage', 'KLIT': 'Little Rock', 'KELP': 'El Paso',
            'KTUS': 'Tucson', 'KOKC': 'Oklahoma City', 'KTUL': 'Tulsa',
            'KGRR': 'Grand Rapids', 'KDSM': 'Des Moines', 'KDAY': 'Dayton',
            'KSYR': 'Syracuse', 'KPVD': 'Providence', 'KALB': 'Albany',
            'KGSO': 'Greensboro', 'KPWM': 'Portland ME', 'KBTV': 'Burlington VT',
            'KROC': 'Rochester',
            // 76-100
            'KBHM': 'Birmingham', 'KLEX': 'Lexington', 'KSDF': 'Louisville',
            'KCMH': 'Columbus OH', 'KCOS': 'Colorado Springs', 'KBOI': 'Boise',
            'KFSD': 'Sioux Falls', 'KICT': 'Wichita', 'KMSN': 'Madison',
            'KLBB': 'Lubbock', 'KFAR': 'Fargo', 'KBIS': 'Bismarck',
            'KDLH': 'Duluth', 'KERI': 'Erie', 'KBGR': 'Bangor',
            'KAVL': 'Asheville', 'KMYR': 'Myrtle Beach', 'KSAV': 'Savannah',
            'KPNS': 'Pensacola', 'KFWA': 'Fort Wayne', 'KLNK': 'Lincoln',
            'KSGF': 'Springfield MO', 'KXNA': 'NW Arkansas', 'KCRP': 'Corpus Christi',
            'KABI': 'Abilene',
            // Top 10 Canada
            'CYYZ': 'Toronto Pearson', 'CYVR': 'Vancouver', 'CYUL': 'Montreal Trudeau',
            'CYYC': 'Calgary', 'CYEG': 'Edmonton', 'CYOW': 'Ottawa',
            'CYWG': 'Winnipeg', 'CYQB': 'Quebec City', 'CYYT': "St. John's NL",
            'CYHZ': 'Halifax'
        };

        // Timezone offsets from UTC (standard time - will need DST adjustment)
        const AIRPORT_TIMEZONES = {
            // Eastern (-5 standard, -4 DST)
            'KATL': 'America/New_York', 'KJFK': 'America/New_York', 'KMCO': 'America/New_York',
            'KMIA': 'America/New_York', 'KEWR': 'America/New_York', 'KBOS': 'America/New_York',
            'KDTW': 'America/New_York', 'KFLL': 'America/New_York', 'KPHL': 'America/New_York',
            'KLGA': 'America/New_York', 'KBWI': 'America/New_York', 'KDCA': 'America/New_York',
            'KTPA': 'America/New_York', 'KIAD': 'America/New_York', 'KRDU': 'America/New_York',
            'KCLE': 'America/New_York', 'KPIT': 'America/New_York', 'KCLT': 'America/New_York',
            'KIND': 'America/New_York', 'KCVG': 'America/New_York', 'KBUF': 'America/New_York',
            'KPBI': 'America/New_York', 'KRSW': 'America/New_York', 'KRIC': 'America/New_York',
            'KBDL': 'America/New_York', 'KCHS': 'America/New_York', 'KJAX': 'America/New_York',
            'KORF': 'America/New_York', 'KDAY': 'America/New_York', 'KSYR': 'America/New_York',
            'KPVD': 'America/New_York', 'KALB': 'America/New_York', 'KGSO': 'America/New_York',
            'KROC': 'America/New_York', 'KBHM': 'America/New_York', 'KLEX': 'America/New_York',
            'KSDF': 'America/New_York', 'KCMH': 'America/New_York', 'KERI': 'America/New_York',
            'KBGR': 'America/New_York', 'KAVL': 'America/New_York', 'KMYR': 'America/New_York',
            'KSAV': 'America/New_York', 'KPNS': 'America/New_York', 'KFWA': 'America/New_York',
            'KPWM': 'America/New_York', 'KBTV': 'America/New_York',
            // Central (-6 standard, -5 DST)
            'KORD': 'America/Chicago', 'KDFW': 'America/Chicago', 'KIAH': 'America/Chicago',
            'KMSP': 'America/Chicago', 'KMDW': 'America/Chicago', 'KSTL': 'America/Chicago',
            'KBNA': 'America/Chicago', 'KMCI': 'America/Chicago', 'KMSY': 'America/Chicago',
            'KSAT': 'America/Chicago', 'KMKE': 'America/Chicago', 'KAUS': 'America/Chicago',
            'KOMA': 'America/Chicago', 'KJAN': 'America/Chicago', 'KLIT': 'America/Chicago',
            'KELP': 'America/Chicago', 'KOKC': 'America/Chicago', 'KTUL': 'America/Chicago',
            'KGRR': 'America/Chicago', 'KDSM': 'America/Chicago', 'KFSD': 'America/Chicago',
            'KICT': 'America/Chicago', 'KMSN': 'America/Chicago', 'KLBB': 'America/Chicago',
            'KFAR': 'America/Chicago', 'KBIS': 'America/Chicago', 'KDLH': 'America/Chicago',
            'KLNK': 'America/Chicago', 'KSGF': 'America/Chicago', 'KXNA': 'America/Chicago',
            'KCRP': 'America/Chicago', 'KABI': 'America/Chicago',
            // Mountain (-7 standard, -6 DST)
            'KDEN': 'America/Denver', 'KPHX': 'America/Phoenix', 'KSLC': 'America/Denver',
            'KABQ': 'America/Denver', 'KTUS': 'America/Denver', 'KCOS': 'America/Denver',
            'KBOI': 'America/Boise',
            // Pacific (-8 standard, -7 DST)
            'KLAX': 'America/Los_Angeles', 'KSFO': 'America/Los_Angeles', 'KLAS': 'America/Los_Angeles',
            'KSEA': 'America/Los_Angeles', 'KSAN': 'America/Los_Angeles', 'KPDX': 'America/Los_Angeles',
            'KOAK': 'America/Los_Angeles', 'KSMF': 'America/Los_Angeles', 'KSJC': 'America/Los_Angeles',
            'KONT': 'America/Los_Angeles', 'KBUR': 'America/Los_Angeles', 'KSNA': 'America/Los_Angeles',
            // Alaska/Hawaii
            'KANC': 'America/Anchorage', 'KHNL': 'Pacific/Honolulu',
            // Canada
            'CYYZ': 'America/Toronto', 'CYVR': 'America/Vancouver', 'CYUL': 'America/Montreal',
            'CYYC': 'America/Edmonton', 'CYEG': 'America/Edmonton', 'CYOW': 'America/Toronto',
            'CYWG': 'America/Winnipeg', 'CYQB': 'America/Montreal', 'CYYT': 'America/St_Johns',
            'CYHZ': 'America/Halifax'
        };

        // Major airline hubs
        const HUB_AIRPORTS = {
            'KATL': ['Delta'],
            'KLAX': ['American', 'Delta', 'United'],
            'KORD': ['American', 'United'],
            'KDFW': ['American'],
            'KDEN': ['United', 'Southwest', 'Frontier'],
            'KJFK': ['JetBlue', 'Delta'],
            'KSFO': ['United'],
            'KLAS': ['Southwest', 'Spirit'],
            'KMCO': ['Southwest', 'JetBlue'],
            'KSEA': ['Alaska', 'Delta'],
            'KMIA': ['American'],
            'KPHX': ['American', 'Southwest'],
            'KEWR': ['United'],
            'KIAH': ['United'],
            'KBOS': ['JetBlue'],
            'KMSP': ['Delta', 'Sun Country'],
            'KDTW': ['Delta'],
            'KCLT': ['American'],
            'KSLC': ['Delta'],
            'KBWI': ['Southwest'],
            'KMDW': ['Southwest'],
            'KBNA': ['Southwest'],
            'KAUS': ['Southwest'],
            'KFLL': ['Spirit', 'JetBlue'],
            // Canada
            'CYYZ': ['Air Canada', 'WestJet'],
            'CYVR': ['Air Canada', 'WestJet'],
            'CYUL': ['Air Canada'],
            'CYYC': ['WestJet']
        };

        // Traffic management data
        let trafficPrograms = {};
        
        // Additional aviation data
        let tafData = {};
        let currentSearchTerm = '';
        let currentRegionFilter = 'all';

        // Runway counts per airport (for display purposes)
        const RUNWAY_COUNT = {
            'KATL': 5, 'KLAX': 4, 'KORD': 8, 'KDFW': 7, 'KDEN': 6, 'KJFK': 4, 'KSFO': 4, 'KLAS': 4, 'KMCO': 4, 'KSEA': 3,
            'KMIA': 4, 'KPHX': 3, 'KEWR': 3, 'KIAH': 5, 'KBOS': 4, 'KMSP': 4, 'KDTW': 6, 'KFLL': 2, 'KPHL': 4, 'KLGA': 2,
            'KBWI': 3, 'KSLC': 4, 'KDCA': 3, 'KSAN': 1, 'KTPA': 3, 'KAUS': 2, 'KIAD': 4, 'KMDW': 5, 'KHNL': 4, 'KSTL': 4,
            'KBNA': 4, 'KOAK': 4, 'KSMF': 2, 'KSJC': 2, 'KRDU': 3, 'KMCI': 3, 'KCLE': 3, 'KPIT': 4, 'KCLT': 4, 'KPDX': 3,
            'KIND': 3, 'KCVG': 4, 'KMSY': 2, 'KSAT': 3, 'KMKE': 5, 'KBUF': 2, 'KPBI': 3, 'KABQ': 3, 'KONT': 2, 'KRSW': 2,
            'KBUR': 1, 'KOMA': 3, 'KRIC': 2, 'KBDL': 2, 'KSNA': 1, 'KJAN': 2, 'KCHS': 2, 'KJAX': 2, 'KORF': 2, 'KANC': 3,
            'KLIT': 2, 'KELP': 3, 'KTUS': 3, 'KOKC': 3, 'KTUL': 3, 'KGRR': 2, 'KDSM': 2, 'KDAY': 3, 'KSYR': 2, 'KPVD': 2,
            'KALB': 2, 'KGSO': 2, 'KPWM': 2, 'KBTV': 2, 'KROC': 2, 'KBHM': 3, 'KLEX': 2, 'KSDF': 3, 'KCMH': 3, 'KCOS': 3,
            'KBOI': 2, 'KFSD': 2, 'KICT': 3, 'KMSN': 2, 'KLBB': 2, 'KFAR': 2, 'KBIS': 2, 'KDLH': 2, 'KERI': 2, 'KBGR': 2,
            'KAVL': 1, 'KMYR': 2, 'KSAV': 2, 'KPNS': 2, 'KFWA': 2, 'KLNK': 2, 'KSGF': 2, 'KXNA': 2, 'KCRP': 2, 'KABI': 2,
            // Canada
            'CYYZ': 5, 'CYVR': 3, 'CYUL': 3, 'CYYC': 4, 'CYEG': 2, 'CYOW': 3, 'CYWG': 3, 'CYQB': 2, 'CYYT': 2, 'CYHZ': 2
        };

        // Regional groupings
        const AIRPORT_REGIONS = {
            northeast: ['KJFK', 'KEWR', 'KLGA', 'KBOS', 'KPHL', 'KBWI', 'KDCA', 'KIAD', 'KBUF', 'KBDL', 'KSYR', 'KPVD', 'KALB', 'KPWM', 'KBTV', 'KROC', 'KERI', 'KBGR', 'KPIT'],
            midwest: ['KORD', 'KMDW', 'KDTW', 'KMSP', 'KCLE', 'KIND', 'KCVG', 'KMKE', 'KSTL', 'KMCI', 'KOMA', 'KGRR', 'KDSM', 'KDAY', 'KCMH', 'KFSD', 'KICT', 'KMSN', 'KFAR', 'KBIS', 'KDLH', 'KFWA', 'KLNK', 'KSGF'],
            south: ['KATL', 'KMIA', 'KFLL', 'KTPA', 'KMCO', 'KIAH', 'KDFW', 'KAUS', 'KSAT', 'KMSY', 'KBNA', 'KCLT', 'KRDU', 'KRIC', 'KJAN', 'KCHS', 'KJAX', 'KORF', 'KLIT', 'KELP', 'KOKC', 'KTUL', 'KGSO', 'KBHM', 'KLEX', 'KSDF', 'KAVL', 'KMYR', 'KSAV', 'KPNS', 'KXNA', 'KCRP', 'KABI', 'KPBI', 'KRSW', 'KLBB'],
            west: ['KLAX', 'KSFO', 'KLAS', 'KSEA', 'KPHX', 'KDEN', 'KSLC', 'KSAN', 'KPDX', 'KOAK', 'KSMF', 'KSJC', 'KABQ', 'KONT', 'KBUR', 'KSNA', 'KTUS', 'KCOS', 'KBOI', 'KANC', 'KHNL'],
            canada: ['CYYZ', 'CYVR', 'CYUL', 'CYYC', 'CYEG', 'CYOW', 'CYWG', 'CYQB', 'CYYT', 'CYHZ']
        };

        const FROZEN_PRECIP = ['SN', 'FZRA', 'FZFG', 'FZDZ', 'PL', 'GR', 'GS', 'IC', 'SG'];
        const ALL_PRECIP = [...FROZEN_PRECIP, 'RA', 'DZ', 'SHRA', 'TSRA', 'SHSN'];

        let refreshInterval = null;
        
        // Global storage for current wind data by airport
        const currentWindData = {};

        const CORS_PROXIES = [
            (url) => `https://api.allorigins.win/raw?url=${encodeURIComponent(url)}`,
            (url) => `https://corsproxy.io/?${encodeURIComponent(url)}`,
            (url) => `https://api.codetabs.com/v1/proxy?quest=${encodeURIComponent(url)}`,
            (url) => url
        ];

        // Worldwide runway data - loaded from external JSON
        let RUNWAY_DATA = {};
        let IATA_TO_ICAO = {};
        let AIRPORT_INFO = {};  // Store city, name, elevation for all airports
        let runwayDataLoaded = false;
        
        // Load runway data from external JSON file
        async function loadRunwayData() {
            console.log('=== loadRunwayData() called ===');
            if (runwayDataLoaded) {
                console.log('Already loaded, skipping');
                return;
            }
            try {
                console.log('Attempting to fetch runway_data.json...');
                const response = await fetch('runway_data.json');
                console.log('Fetch response:', response.status, response.statusText, response.ok);
                
                if (response.ok) {
                    console.log('Response OK, parsing JSON...');
                    const data = await response.json();
                    console.log('JSON parsed, keys:', Object.keys(data));
                    
                    IATA_TO_ICAO = data.iata_to_icao || {};
                    console.log('IATA to ICAO mappings loaded:', Object.keys(IATA_TO_ICAO).length);
                    
                    // Convert the airport data to expected format
                    let airportCount = 0;
                    const airports = data.airports || {};
                    console.log('Processing airports object with', Object.keys(airports).length, 'entries');
                    
                    for (const [icao, airport] of Object.entries(airports)) {
                        RUNWAY_DATA[icao] = { 
                            runways: airport.runways || [],
                            elevation_ft: airport.elevation_ft
                        };
                        // Store airport info separately for quick lookup
                        AIRPORT_INFO[icao] = {
                            city: airport.city || '',
                            name: airport.name || '',
                            region: airport.region || '',
                            elevation_ft: airport.elevation_ft,
                            iata: airport.iata || ''
                        };
                        airportCount++;
                    }
                    runwayDataLoaded = true;
                    console.log(`&#x2714; Loaded runway data for ${airportCount} airports worldwide`);
                    console.log('RUNWAY_DATA now has', Object.keys(RUNWAY_DATA).length, 'entries');
                    console.log('Sample - KORD runways:', RUNWAY_DATA['KORD']?.runways?.length || 0);
                    console.log('Sample - KBUF runways:', RUNWAY_DATA['KBUF']?.runways?.length || 0);
                } else {
                    console.error('&#x2717; Failed to load runway data:', response.status, response.statusText);
                    console.log('Loading fallback data instead...');
                    loadFallbackRunwayData();
                }
            } catch (e) {
                console.error('&#x2717; Exception loading runway data:', e);
                console.error('Error name:', e.name);
                console.error('Error message:', e.message);
                console.log('Loading fallback runway data...');
                loadFallbackRunwayData();
            }
        }
        
        // Fallback runway data for top US airports (used if JSON fails to load)
        function loadFallbackRunwayData() {
            console.log('=== Loading FALLBACK runway data ===');
            // Basic runway data for top 20+ airports
            const fallbackData = {
                'KATL': { elevation_ft: 1026, runways: [
                    { le_ident: '08L', he_ident: '26R', length_ft: 9000, width_ft: 150, le_heading_degT: 90 },
                    { le_ident: '08R', he_ident: '26L', length_ft: 10000, width_ft: 150, le_heading_degT: 90 },
                    { le_ident: '09L', he_ident: '27R', length_ft: 12390, width_ft: 150, le_heading_degT: 90 },
                    { le_ident: '09R', he_ident: '27L', length_ft: 9000, width_ft: 150, le_heading_degT: 90 },
                    { le_ident: '10', he_ident: '28', length_ft: 9000, width_ft: 150, le_heading_degT: 100 }
                ]},
                'KLAX': { elevation_ft: 128, runways: [
                    { le_ident: '06L', he_ident: '24R', length_ft: 8926, width_ft: 150, le_heading_degT: 69 },
                    { le_ident: '06R', he_ident: '24L', length_ft: 10285, width_ft: 150, le_heading_degT: 69 },
                    { le_ident: '07L', he_ident: '25R', length_ft: 12091, width_ft: 150, le_heading_degT: 69 },
                    { le_ident: '07R', he_ident: '25L', length_ft: 11096, width_ft: 200, le_heading_degT: 69 }
                ]},
                'KORD': { elevation_ft: 672, runways: [
                    { le_ident: '04L', he_ident: '22R', length_ft: 7500, width_ft: 150, le_heading_degT: 41 },
                    { le_ident: '09L', he_ident: '27R', length_ft: 7967, width_ft: 150, le_heading_degT: 90 },
                    { le_ident: '09R', he_ident: '27L', length_ft: 9687, width_ft: 150, le_heading_degT: 90 },
                    { le_ident: '10L', he_ident: '28R', length_ft: 13000, width_ft: 200, le_heading_degT: 101 },
                    { le_ident: '10C', he_ident: '28C', length_ft: 10801, width_ft: 200, le_heading_degT: 101 },
                    { le_ident: '10R', he_ident: '28L', length_ft: 10141, width_ft: 150, le_heading_degT: 101 }
                ]},
                'KDFW': { elevation_ft: 607, runways: [
                    { le_ident: '13L', he_ident: '31R', length_ft: 9000, width_ft: 150, le_heading_degT: 130 },
                    { le_ident: '13R', he_ident: '31L', length_ft: 9301, width_ft: 200, le_heading_degT: 130 },
                    { le_ident: '17C', he_ident: '35C', length_ft: 13401, width_ft: 200, le_heading_degT: 175 },
                    { le_ident: '17L', he_ident: '35R', length_ft: 8500, width_ft: 150, le_heading_degT: 175 },
                    { le_ident: '17R', he_ident: '35L', length_ft: 13401, width_ft: 200, le_heading_degT: 175 },
                    { le_ident: '18L', he_ident: '36R', length_ft: 13400, width_ft: 200, le_heading_degT: 175 },
                    { le_ident: '18R', he_ident: '36L', length_ft: 13400, width_ft: 200, le_heading_degT: 175 }
                ]},
                'KDEN': { elevation_ft: 5431, runways: [
                    { le_ident: '07', he_ident: '25', length_ft: 12000, width_ft: 150, le_heading_degT: 70 },
                    { le_ident: '08', he_ident: '26', length_ft: 12000, width_ft: 150, le_heading_degT: 80 },
                    { le_ident: '16L', he_ident: '34R', length_ft: 12000, width_ft: 150, le_heading_degT: 160 },
                    { le_ident: '16R', he_ident: '34L', length_ft: 16000, width_ft: 200, le_heading_degT: 160 },
                    { le_ident: '17L', he_ident: '35R', length_ft: 12000, width_ft: 150, le_heading_degT: 170 },
                    { le_ident: '17R', he_ident: '35L', length_ft: 12000, width_ft: 150, le_heading_degT: 170 }
                ]},
                'KJFK': { elevation_ft: 13, runways: [
                    { le_ident: '04L', he_ident: '22R', length_ft: 12079, width_ft: 200, le_heading_degT: 31 },
                    { le_ident: '04R', he_ident: '22L', length_ft: 8400, width_ft: 200, le_heading_degT: 31 },
                    { le_ident: '13L', he_ident: '31R', length_ft: 10000, width_ft: 200, le_heading_degT: 130 },
                    { le_ident: '13R', he_ident: '31L', length_ft: 14511, width_ft: 200, le_heading_degT: 130 }
                ]},
                'KSFO': { elevation_ft: 13, runways: [
                    { le_ident: '01L', he_ident: '19R', length_ft: 7650, width_ft: 200, le_heading_degT: 10 },
                    { le_ident: '01R', he_ident: '19L', length_ft: 8648, width_ft: 200, le_heading_degT: 10 },
                    { le_ident: '10L', he_ident: '28R', length_ft: 11870, width_ft: 200, le_heading_degT: 100 },
                    { le_ident: '10R', he_ident: '28L', length_ft: 10602, width_ft: 200, le_heading_degT: 100 }
                ]},
                'KLAS': { elevation_ft: 2181, runways: [
                    { le_ident: '01L', he_ident: '19R', length_ft: 9775, width_ft: 150, le_heading_degT: 10 },
                    { le_ident: '01R', he_ident: '19L', length_ft: 8504, width_ft: 150, le_heading_degT: 10 },
                    { le_ident: '08L', he_ident: '26R', length_ft: 14510, width_ft: 150, le_heading_degT: 80 },
                    { le_ident: '08R', he_ident: '26L', length_ft: 10527, width_ft: 150, le_heading_degT: 80 }
                ]},
                'KMCO': { elevation_ft: 96, runways: [
                    { le_ident: '17L', he_ident: '35R', length_ft: 9000, width_ft: 150, le_heading_degT: 173 },
                    { le_ident: '17R', he_ident: '35L', length_ft: 10000, width_ft: 150, le_heading_degT: 173 },
                    { le_ident: '18L', he_ident: '36R', length_ft: 12005, width_ft: 200, le_heading_degT: 180 },
                    { le_ident: '18R', he_ident: '36L', length_ft: 12004, width_ft: 200, le_heading_degT: 180 }
                ]},
                'KSEA': { elevation_ft: 433, runways: [
                    { le_ident: '16L', he_ident: '34R', length_ft: 11901, width_ft: 200, le_heading_degT: 160 },
                    { le_ident: '16C', he_ident: '34C', length_ft: 9426, width_ft: 150, le_heading_degT: 160 },
                    { le_ident: '16R', he_ident: '34L', length_ft: 8500, width_ft: 150, le_heading_degT: 160 }
                ]},
                'KBUF': { elevation_ft: 728, runways: [
                    { le_ident: '05', he_ident: '23', length_ft: 8102, width_ft: 150, le_heading_degT: 50 },
                    { le_ident: '14', he_ident: '32', length_ft: 7161, width_ft: 150, le_heading_degT: 140 }
                ]},
                'KBOS': { elevation_ft: 20, runways: [
                    { le_ident: '04L', he_ident: '22R', length_ft: 7861, width_ft: 150, le_heading_degT: 39 },
                    { le_ident: '04R', he_ident: '22L', length_ft: 10006, width_ft: 150, le_heading_degT: 39 },
                    { le_ident: '09', he_ident: '27', length_ft: 7000, width_ft: 150, le_heading_degT: 86 },
                    { le_ident: '15R', he_ident: '33L', length_ft: 10083, width_ft: 150, le_heading_degT: 150 }
                ]},
                'KMSP': { elevation_ft: 841, runways: [
                    { le_ident: '04', he_ident: '22', length_ft: 11006, width_ft: 200, le_heading_degT: 40 },
                    { le_ident: '12L', he_ident: '30R', length_ft: 10000, width_ft: 200, le_heading_degT: 118 },
                    { le_ident: '12R', he_ident: '30L', length_ft: 8200, width_ft: 150, le_heading_degT: 118 },
                    { le_ident: '17', he_ident: '35', length_ft: 8000, width_ft: 150, le_heading_degT: 170 }
                ]},
                'KDTW': { elevation_ft: 645, runways: [
                    { le_ident: '03L', he_ident: '21R', length_ft: 10001, width_ft: 150, le_heading_degT: 26 },
                    { le_ident: '03R', he_ident: '21L', length_ft: 8501, width_ft: 200, le_heading_degT: 26 },
                    { le_ident: '04L', he_ident: '22R', length_ft: 12003, width_ft: 200, le_heading_degT: 36 },
                    { le_ident: '04R', he_ident: '22L', length_ft: 10000, width_ft: 200, le_heading_degT: 36 }
                ]},
                'KCLE': { elevation_ft: 791, runways: [
                    { le_ident: '06L', he_ident: '24R', length_ft: 9956, width_ft: 150, le_heading_degT: 62 },
                    { le_ident: '06R', he_ident: '24L', length_ft: 11000, width_ft: 150, le_heading_degT: 62 },
                    { le_ident: '10', he_ident: '28', length_ft: 6017, width_ft: 150, le_heading_degT: 100 }
                ]}
            };
            
            for (const [icao, data] of Object.entries(fallbackData)) {
                RUNWAY_DATA[icao] = data;
            }
            
            // Basic IATA mappings for top airports
            IATA_TO_ICAO = {
                'ATL': 'KATL', 'LAX': 'KLAX', 'ORD': 'KORD', 'DFW': 'KDFW', 'DEN': 'KDEN',
                'JFK': 'KJFK', 'SFO': 'KSFO', 'LAS': 'KLAS', 'MCO': 'KMCO', 'SEA': 'KSEA',
                'MIA': 'KMIA', 'PHX': 'KPHX', 'EWR': 'KEWR', 'IAH': 'KIAH', 'BOS': 'KBOS',
                'MSP': 'KMSP', 'DTW': 'KDTW', 'FLL': 'KFLL', 'PHL': 'KPHL', 'LGA': 'KLGA',
                'BUF': 'KBUF', 'CLE': 'KCLE'
            };
            
            console.log('&#x2714; Loaded fallback runway data for', Object.keys(fallbackData).length, 'airports');
            console.log('Fallback airports:', Object.keys(fallbackData).join(', '));
            runwayDataLoaded = true;
        }
        
        // Get airport display name - checks both hardcoded US names and worldwide data
        function getAirportName(icao) {
            // First check hardcoded US airport names (more user-friendly)
            if (AIRPORT_NAMES[icao]) return AIRPORT_NAMES[icao];
            
            // Then check worldwide data
            const info = AIRPORT_INFO[icao];
            if (info) {
                if (info.city && info.name) {
                    return `${info.city} - ${info.name}`;
                } else if (info.name) {
                    return info.name;
                } else if (info.city) {
                    return info.city;
                }
            }
            return icao;
        }
        
        // Get full airport info for display
        function getAirportInfo(icao) {
            return AIRPORT_INFO[icao] || null;
        }
        
        // Resolve IATA to ICAO code
        function resolveToICAO(code) {
            if (!code) return null;
            code = code.toUpperCase().trim();
            // If it's already a valid ICAO (4 letters starting with country prefix)
            if (/^[A-Z]{4}$/.test(code)) return code;
            // If it's a 3-letter IATA code, try to resolve
            if (/^[A-Z]{3}$/.test(code)) {
                return IATA_TO_ICAO[code] || null;
            }
            return null;
        }
        
        // Show runway map modal
        function showRunwayMap(icao, evt) {
            if (evt) evt.stopPropagation();
            console.log('showRunwayMap called for:', icao);
            
            const modal = document.getElementById('runwayModal');
            const title = document.getElementById('runwayModalTitle');
            const body = document.getElementById('runwayModalBody');
            
            if (!modal || !title || !body) {
                console.error('Modal elements not found!');
                return;
            }
            
            const airportName = getAirportName(icao);
            const info = getAirportInfo(icao);
            const iataDisplay = info?.iata ? ` (${info.iata})` : '';
            title.textContent = `${icao}${iataDisplay} - ${airportName}`;
            
            // Get wind data from global storage
            const windData = currentWindData[icao] || { direction: null, speed: null, gust: null, variable: false };
            console.log('Wind data for', icao, ':', windData);
            
            console.log('RUNWAY_DATA keys count:', Object.keys(RUNWAY_DATA).length);
            console.log('runwayDataLoaded:', runwayDataLoaded);
            
            const data = RUNWAY_DATA[icao];
            console.log('Data for', icao, ':', data);
            console.log('Has runways:', data?.runways?.length);
            
            if (data && data.runways && data.runways.length > 0) {
                console.log('Calling renderRunwayModal with', data.runways.length, 'runways');
                // Add elevation to data if from info
                if (info?.elevation_ft && !data.elevation_ft) {
                    data.elevation_ft = info.elevation_ft;
                }
                renderRunwayModal(icao, data, windData);
            } else {
                console.log('No runway data - showing fallback');
                console.log('  data exists:', !!data);
                console.log('  data.runways exists:', !!data?.runways);
                console.log('  data.runways.length:', data?.runways?.length);
                console.log('  runwayDataLoaded:', runwayDataLoaded);
                console.log('  RUNWAY_DATA keys:', Object.keys(RUNWAY_DATA).length);
                
                // No runway data - show just the acukwik image
                const diagramUrl = `https://acukwik.com/extimages/Listing-Images/${icao}.jpg`;
                
                let statusMsg = '';
                if (!runwayDataLoaded) {
                    statusMsg = 'Runway data is still loading...';
                } else if (Object.keys(RUNWAY_DATA).length === 0) {
                    statusMsg = 'Could not load runway database. Check console for errors.';
                } else if (!data) {
                    statusMsg = `Airport ${icao} not found in runway database.`;
                } else if (!data.runways || data.runways.length === 0) {
                    statusMsg = `No runway information available for ${icao}.`;
                }
                
                body.innerHTML = `
                    <div class="runway-diagram" style="background:#fff;padding:5px;border-radius:4px;">
                        <img src="${diagramUrl}" alt="${icao} Airport Diagram" 
                             style="max-width:100%;height:auto;display:block;margin:0 auto;"
                             onerror="this.parentElement.innerHTML='<div style=\\'color:#888;text-align:center;padding:40px;background:#1a1a2e;\\'>Diagram not available for ${icao}</div>'">
                    </div>
                    <div style="margin-top:12px;text-align:center;color:#888;font-size:11px;">
                        ${statusMsg}
                    </div>
                    <div style="margin-top:8px;text-align:center;color:#666;font-size:10px;">
                        RUNWAY_DATA entries: ${Object.keys(RUNWAY_DATA).length}
                    </div>
                    <a href="https://www.faa.gov/airports/runway_safety/diagrams/" target="_blank" class="runway-faa-link">
                        &#x1F50D; Search FAA Airport Diagrams
                    </a>
                `;
            }
            
            modal.classList.add('active');
        }
        
        // Render the runway modal content
        function renderRunwayModal(icao, data, windData) {
            const body = document.getElementById('runwayModalBody');
            
            console.log('renderRunwayModal called');
            console.log('  icao:', icao);
            console.log('  data:', data);
            console.log('  data.runways:', data?.runways);
            console.log('  data.runways.length:', data?.runways?.length);
            console.log('  windData:', windData);
            console.log('  windData.speed:', windData?.speed);
            console.log('  windData.direction:', windData?.direction);
            
            // Use acukwik diagram image
            const diagramUrl = `https://acukwik.com/extimages/Listing-Images/${icao}.jpg`;
            
            // Build runway list
            let listHtml = '';
            if (data.runways && data.runways.length > 0) {
                console.log('Building runway list for', data.runways.length, 'runways');
                listHtml = '<div class="runway-list" style="margin-top:12px;">';
                for (const rwy of data.runways) {
                    const length = rwy.length_ft ? `${Number(rwy.length_ft).toLocaleString()}ft` : 'N/A';
                    const width = rwy.width_ft ? `${rwy.width_ft}ft wide` : '';
                    const ident = [rwy.le_ident, rwy.he_ident].filter(Boolean).join('/') || 'N/A';
                    
                    listHtml += `
                        <div class="runway-item">
                            <span class="runway-ident">${ident}</span>
                            <span class="runway-dim">${length} x ${width}</span>
                        </div>
                    `;
                }
                listHtml += '</div>';
            } else {
                console.log('No runway data available for this airport');
                listHtml = `<div style="margin-top:12px;padding:10px;background:#252540;border-radius:6px;text-align:center;color:#888;font-size:11px;">
                    Runway details not available
                </div>`;
            }
            
            // Wind display with arrow - compact for side position
            let windDisplayHtml = '';
            if (windData && windData.speed !== null && windData.speed !== undefined) {
                if (windData.speed === 0) {
                    windDisplayHtml = `
                        <div style="text-align:center;padding:10px;background:#151525;border-radius:6px;">
                            <div style="color:#44ff44;font-size:14px;font-weight:bold;">CALM</div>
                            <div style="color:#888;font-size:10px;">No wind</div>
                        </div>`;
                } else {
                    // Wind arrow SVG
                    let windColor = windData.speed >= 30 ? '#ff4444' : windData.speed >= 20 ? '#ff8c00' : windData.speed >= 10 ? '#ffd700' : '#44ff44';
                    let arrowSvg = '';
                    
                    if (windData.variable) {
                        arrowSvg = `<svg width="70" height="70" viewBox="0 0 70 70">
                            <circle cx="35" cy="35" r="25" fill="none" stroke="${windColor}" stroke-width="3" stroke-dasharray="5,3"/>
                            <text x="35" y="39" fill="${windColor}" font-size="12" font-weight="bold" text-anchor="middle">VRB</text>
                        </svg>`;
                    } else if (windData.direction !== null) {
                        const flowDir = (windData.direction + 180) % 360;
                        const rad = flowDir * Math.PI / 180;
                        const dx = Math.sin(rad);
                        const dy = -Math.cos(rad);
                        const len = 22;
                        const cx = 35, cy = 35;
                        const x1 = cx - dx * len, y1 = cy - dy * len;
                        const x2 = cx + dx * len, y2 = cy + dy * len;
                        
                        arrowSvg = `<svg width="70" height="70" viewBox="0 0 70 70">
                            <circle cx="35" cy="35" r="30" fill="none" stroke="#333" stroke-width="1"/>
                            <line x1="${x1}" y1="${y1}" x2="${x2}" y2="${y2}" stroke="${windColor}" stroke-width="3" stroke-linecap="round"/>
                            <polygon points="${x2},${y2} ${x2 - dx*8 - dy*4},${y2 - dy*8 + dx*4} ${x2 - dx*8 + dy*4},${y2 - dy*8 - dx*4}" fill="${windColor}"/>
                            <text x="35" y="8" fill="#4a90d9" font-size="9" text-anchor="middle">N</text>
                        </svg>`;
                    }
                    
                    let windDir = windData.variable ? 'VRB' : `${String(windData.direction).padStart(3, '0')}&deg;`;
                    let windSpd = `${windData.speed}kt`;
                    if (windData.gust) windSpd += ` G${windData.gust}`;
                    
                    windDisplayHtml = `
                        <div style="text-align:center;padding:8px;background:#151525;border-radius:6px;">
                            <div style="color:#888;font-size:9px;margin-bottom:4px;">WIND</div>
                            ${arrowSvg}
                            <div style="color:${windColor};font-size:12px;font-weight:bold;">${windDir}</div>
                            <div style="color:${windColor};font-size:11px;">${windSpd}</div>
                        </div>`;
                }
            } else {
                // No wind data available - show placeholder
                windDisplayHtml = `
                    <div style="text-align:center;padding:10px;background:#151525;border-radius:6px;">
                        <div style="color:#888;font-size:12px;">WIND</div>
                        <div style="color:#666;font-size:10px;margin-top:4px;">No data</div>
                    </div>`;
            }
            
            // Wind components table
            let windComponentsHtml = '';
            if (windData && windData.speed !== null && windData.speed > 0 && !windData.variable && windData.direction !== null && data.runways && data.runways.length > 0) {
                const components = calculateWindComponents(data.runways, windData);
                
                windComponentsHtml = `
                    <div style="margin-top:12px;padding:10px;background:#151525;border-radius:6px;">
                        <div style="color:#888;font-size:10px;margin-bottom:6px;text-align:center;">WIND COMPONENTS BY RUNWAY</div>
                        <table style="width:100%;font-size:11px;border-collapse:collapse;">
                            <thead>
                                <tr style="color:#888;border-bottom:1px solid #333;">
                                    <th style="padding:4px;text-align:left;">RWY</th>
                                    <th style="padding:4px;text-align:right;">Head/Tail</th>
                                    <th style="padding:4px;text-align:right;">Crosswind</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${components.map(c => `
                                    <tr style="border-bottom:1px solid #252525;">
                                        <td style="padding:4px;color:#4a90d9;font-weight:bold;">${c.runway}</td>
                                        <td style="padding:4px;text-align:right;color:${c.headwind >= 0 ? '#44ff44' : '#ff6b6b'};">
                                            ${Math.abs(c.headwind)}kt ${c.headwind >= 0 ? 'HEAD' : 'TAIL'}
                                        </td>
                                        <td style="padding:4px;text-align:right;color:${Math.abs(c.crosswind) >= 15 ? '#ff8c00' : '#888'};">
                                            ${Math.abs(c.crosswind)}kt ${c.crosswind > 0 ? 'R' : c.crosswind < 0 ? 'L' : ''}
                                        </td>
                                    </tr>
                                `).join('')}
                            </tbody>
                        </table>
                        ${windData.gust ? `<div style="color:#ff8c00;font-size:10px;text-align:center;margin-top:6px;">Gusts to ${windData.gust}kt - components may be higher</div>` : ''}
                    </div>
                `;
            } else if (windData && windData.variable && windData.speed > 0) {
                windComponentsHtml = `
                    <div style="margin-top:12px;padding:10px;background:#151525;border-radius:6px;text-align:center;">
                        <div style="color:#888;font-size:10px;margin-bottom:4px;">WIND COMPONENTS</div>
                        <div style="color:#ffd700;font-size:12px;">Variable wind - components vary</div>
                    </div>
                `;
            }
            
            // Elevation
            let infoHtml = '';
            if (data.elevation_ft) {
                infoHtml = `<div style="text-align:center;color:#888;font-size:11px;margin-top:8px;">Elevation: ${data.elevation_ft}ft</div>`;
            }
            
            console.log('Setting body.innerHTML with:');
            console.log('  windDisplayHtml length:', windDisplayHtml.length);
            console.log('  windComponentsHtml length:', windComponentsHtml.length);
            console.log('  listHtml length:', listHtml.length);
            console.log('  infoHtml length:', infoHtml.length);
            
            body.innerHTML = `
                <div style="display:flex;gap:10px;align-items:flex-start;">
                    <div class="runway-diagram" style="background:#fff;padding:5px;border-radius:4px;flex:1;min-width:0;">
                        <img src="${diagramUrl}" alt="${icao} Airport Diagram" 
                             style="max-width:100%;height:auto;display:block;margin:0 auto;"
                             onerror="this.parentElement.innerHTML='<div style=\\'color:#888;text-align:center;padding:40px;background:#1a1a2e;\\'>Diagram not available for ${icao}</div>'">
                    </div>
                    <div style="flex-shrink:0;width:90px;">
                        ${windDisplayHtml}
                    </div>
                </div>
                ${windComponentsHtml}
                ${infoHtml}
                ${listHtml}
                <a href="https://www.faa.gov/airports/runway_safety/diagrams/" target="_blank" class="runway-faa-link">
                    &#x1F50D; View Official FAA Diagram
                </a>
            `;
            
            console.log('Modal body innerHTML set, length:', body.innerHTML.length);
        }
        
        // Calculate wind components for each runway direction
        function calculateWindComponents(runways, windData) {
            const results = [];
            const windDir = windData.direction; // True direction wind is FROM
            const windSpeed = windData.speed;
            
            for (const rwy of runways) {
                // Get runway heading (true)
                let heading = parseFloat(rwy.le_heading_degT);
                if (isNaN(heading) && rwy.le_ident) {
                    heading = parseInt(rwy.le_ident.replace(/[LRC]/g, '')) * 10;
                }
                if (isNaN(heading)) continue;
                
                // Calculate for low-end runway (le_ident)
                if (rwy.le_ident) {
                    const leHeading = heading;
                    const leComponents = getWindComponents(windDir, windSpeed, leHeading);
                    results.push({
                        runway: rwy.le_ident,
                        heading: leHeading,
                        headwind: leComponents.headwind,
                        crosswind: leComponents.crosswind
                    });
                }
                
                // Calculate for high-end runway (he_ident) - opposite direction
                if (rwy.he_ident) {
                    const heHeading = (heading + 180) % 360;
                    const heComponents = getWindComponents(windDir, windSpeed, heHeading);
                    results.push({
                        runway: rwy.he_ident,
                        heading: heHeading,
                        headwind: heComponents.headwind,
                        crosswind: heComponents.crosswind
                    });
                }
            }
            
            // Sort by headwind (best runways first - highest headwind)
            results.sort((a, b) => b.headwind - a.headwind);
            
            return results;
        }
        
        // Calculate headwind and crosswind components
        function getWindComponents(windDir, windSpeed, runwayHeading) {
            // Wind direction is where wind comes FROM
            // Runway heading is direction you face when landing
            // Angle difference: how far off the nose is the wind coming from
            const angleDiff = (windDir - runwayHeading) * Math.PI / 180;
            
            // Headwind component: positive = headwind, negative = tailwind
            // cos(0) = 1 = direct headwind
            // cos(180 deg) = -1 = direct tailwind
            const headwind = Math.round(windSpeed * Math.cos(angleDiff));
            
            // Crosswind component: positive = from right, negative = from left
            // sin(90 deg) = 1 = wind from right
            // sin(-90 deg) = -1 = wind from left
            const crosswind = Math.round(windSpeed * Math.sin(angleDiff));
            
            return { headwind, crosswind };
        }
        
        // Generate SVG runway diagram
        function generateRunwaySVG(runways, airportData, windData) {
            const width = 280;
            const height = 280;
            const padding = 45; // Padding for labels
            const centerX = width / 2;
            const centerY = height / 2;
            
            // Check if runways have lat/long data
            const hasLatLon = runways.some(r => r.le_lat !== undefined && r.le_lon !== undefined);
            
            let svgContent = '';
            
            if (hasLatLon) {
                // Use precise lat/long projection
                // Find bounding box of all runway endpoints
                let minLat = Infinity, maxLat = -Infinity;
                let minLon = Infinity, maxLon = -Infinity;
                
                for (const rwy of runways) {
                    if (rwy.le_lat !== undefined) {
                        minLat = Math.min(minLat, rwy.le_lat, rwy.he_lat);
                        maxLat = Math.max(maxLat, rwy.le_lat, rwy.he_lat);
                        minLon = Math.min(minLon, rwy.le_lon, rwy.he_lon);
                        maxLon = Math.max(maxLon, rwy.le_lon, rwy.he_lon);
                    }
                }
                
                // Add 10% padding to bounding box
                const latRange = maxLat - minLat;
                const lonRange = maxLon - minLon;
                const latPad = latRange * 0.15;
                const lonPad = lonRange * 0.15;
                minLat -= latPad; maxLat += latPad;
                minLon -= lonPad; maxLon += lonPad;
                
                // Calculate scale to fit in SVG (accounting for padding)
                const drawWidth = width - 2 * padding;
                const drawHeight = height - 2 * padding;
                
                // Adjust for latitude distortion (cosine of latitude)
                const centerLat = (minLat + maxLat) / 2;
                const cosLat = Math.cos(centerLat * Math.PI / 180);
                const adjustedLonRange = (maxLon - minLon) * cosLat;
                const adjustedLatRange = maxLat - minLat;
                
                // Scale to fit while preserving aspect ratio
                const scaleX = drawWidth / adjustedLonRange;
                const scaleY = drawHeight / adjustedLatRange;
                const scale = Math.min(scaleX, scaleY);
                
                // Calculate center offset
                const usedWidth = adjustedLonRange * scale;
                const usedHeight = adjustedLatRange * scale;
                const offsetX = padding + (drawWidth - usedWidth) / 2;
                const offsetY = padding + (drawHeight - usedHeight) / 2;
                
                // Project lat/lon to SVG coordinates
                // North is up (higher lat = lower Y)
                const projectX = (lon) => offsetX + (lon - minLon) * cosLat * scale;
                const projectY = (lat) => offsetY + (maxLat - lat) * scale;
                
                // Draw each runway
                for (const rwy of runways) {
                    if (rwy.le_lat === undefined) continue;
                    
                    const leX = projectX(rwy.le_lon);
                    const leY = projectY(rwy.le_lat);
                    const heX = projectX(rwy.he_lon);
                    const heY = projectY(rwy.he_lat);
                    
                    // Calculate runway width in pixels (use a minimum)
                    const rwyLength = Math.sqrt((heX - leX) ** 2 + (heY - leY) ** 2);
                    const widthFt = parseFloat(rwy.width_ft) || 150;
                    const lengthFt = parseFloat(rwy.length_ft) || 9000;
                    const scaledWidth = Math.max((widthFt / lengthFt) * rwyLength * 0.8, 5);
                    
                    // Runway color
                    const rwyColor = rwy.closed === '1' ? '#8b0000' : '#3a3a3a';
                    const rwyStroke = rwy.closed === '1' ? '#ff0000' : '#555';
                    
                    // Draw runway as a thick line with rounded ends
                    svgContent += `
                        <line x1="${leX}" y1="${leY}" x2="${heX}" y2="${heY}" 
                            stroke="${rwyStroke}" stroke-width="${scaledWidth + 2}" stroke-linecap="round" fill="none" stroke-opacity="0.5"/>
                        <line x1="${leX}" y1="${leY}" x2="${heX}" y2="${heY}" 
                            stroke="${rwyColor}" stroke-width="${scaledWidth}" stroke-linecap="round"/>
                        <line x1="${leX}" y1="${leY}" x2="${heX}" y2="${heY}" 
                            stroke="#666" stroke-width="1" stroke-dasharray="8,6"/>
                    `;
                    
                    // Calculate direction vector for label placement
                    const dx = heX - leX;
                    const dy = heY - leY;
                    const len = Math.sqrt(dx * dx + dy * dy);
                    const ux = dx / len;
                    const uy = dy / len;
                    
                    // Runway labels at ends
                    const labelOffset = 15;
                    const leIdent = rwy.le_ident || '';
                    const heIdent = rwy.he_ident || '';
                    
                    const leLabelX = leX - ux * labelOffset;
                    const leLabelY = leY - uy * labelOffset;
                    const heLabelX = heX + ux * labelOffset;
                    const heLabelY = heY + uy * labelOffset;
                    
                    if (leIdent) {
                        svgContent += `<text x="${leLabelX}" y="${leLabelY}" fill="#4a90d9" font-size="10" font-weight="bold" text-anchor="middle" dominant-baseline="middle">${leIdent}</text>`;
                    }
                    if (heIdent) {
                        svgContent += `<text x="${heLabelX}" y="${heLabelY}" fill="#4a90d9" font-size="10" font-weight="bold" text-anchor="middle" dominant-baseline="middle">${heIdent}</text>`;
                    }
                }
            } else {
                // Fallback: Use heading-based calculation (original method)
                
                // Find the longest runway for scaling
                let maxLength = 0;
                for (const rwy of runways) {
                    const len = parseFloat(rwy.length_ft) || 0;
                    if (len > maxLength) maxLength = len;
                }
                
                // Scale factor: fit longest runway in ~180px
                const scaleFactor = maxLength > 0 ? 180 / maxLength : 1;
                
                // Group runways by heading (within 15 degrees = same orientation)
                const groups = [];
                for (const rwy of runways) {
                    let heading = parseFloat(rwy.le_heading_degT);
                    if (isNaN(heading) && rwy.le_ident) {
                        heading = parseInt(rwy.le_ident.replace(/[LRC]/g, '')) * 10;
                    }
                    if (isNaN(heading)) heading = 0;
                    
                    const normalizedHeading = heading % 180;
                    
                    let foundGroup = null;
                    for (const g of groups) {
                        const diff = Math.abs(g.heading - normalizedHeading);
                        if (diff < 15 || diff > 165) {
                            foundGroup = g;
                            break;
                        }
                    }
                    
                    if (foundGroup) {
                        foundGroup.runways.push({ ...rwy, heading });
                    } else {
                        groups.push({ heading: normalizedHeading, runways: [{ ...rwy, heading }] });
                    }
                }
                
                // Draw each group of runways
                for (const group of groups) {
                    const numInGroup = group.runways.length;
                    
                    for (let i = 0; i < numInGroup; i++) {
                        const rwy = group.runways[i];
                        const length = parseFloat(rwy.length_ft) || 5000;
                        const widthFt = parseFloat(rwy.width_ft) || 150;
                        const heading = rwy.heading;
                        
                        const scaledLength = length * scaleFactor;
                        const scaledWidth = Math.max(widthFt * scaleFactor * 0.5, 6);
                        
                        const headingRad = heading * Math.PI / 180;
                        const dx = Math.sin(headingRad);
                        const dy = -Math.cos(headingRad);
                        
                        const perpDx = Math.cos(headingRad);
                        const perpDy = Math.sin(headingRad);
                        
                        let offsetX = 0, offsetY = 0;
                        if (numInGroup > 1) {
                            const spacing = 25;
                            const offset = (i - (numInGroup - 1) / 2) * spacing;
                            offsetX = perpDx * offset;
                            offsetY = perpDy * offset;
                        }
                        
                        const rwyX = centerX + offsetX;
                        const rwyY = centerY + offsetY;
                        
                        const heX = rwyX + dx * scaledLength / 2;
                        const heY = rwyY + dy * scaledLength / 2;
                        const leX = rwyX - dx * scaledLength / 2;
                        const leY = rwyY - dy * scaledLength / 2;
                        
                        const rwyColor = rwy.closed === '1' ? '#8b0000' : '#3a3a3a';
                        const rwyStroke = rwy.closed === '1' ? '#ff0000' : '#555';
                        
                        svgContent += `
                            <line x1="${leX}" y1="${leY}" x2="${heX}" y2="${heY}" 
                                stroke="${rwyStroke}" stroke-width="${scaledWidth + 2}" stroke-linecap="round" fill="none" stroke-opacity="0.5"/>
                            <line x1="${leX}" y1="${leY}" x2="${heX}" y2="${heY}" 
                                stroke="${rwyColor}" stroke-width="${scaledWidth}" stroke-linecap="round"/>
                            <line x1="${leX}" y1="${leY}" x2="${heX}" y2="${heY}" 
                                stroke="#666" stroke-width="1" stroke-dasharray="8,6"/>
                        `;
                        
                        const labelOffset = 18;
                        const leIdent = rwy.le_ident || '';
                        const heIdent = rwy.he_ident || '';
                        
                        const leLabelX = leX - dx * labelOffset;
                        const leLabelY = leY - dy * labelOffset;
                        const heLabelX = heX + dx * labelOffset;
                        const heLabelY = heY + dy * labelOffset;
                        
                        if (leIdent) {
                            svgContent += `<text x="${leLabelX}" y="${leLabelY}" fill="#4a90d9" font-size="11" font-weight="bold" text-anchor="middle" dominant-baseline="middle">${leIdent}</text>`;
                        }
                        if (heIdent) {
                            svgContent += `<text x="${heLabelX}" y="${heLabelY}" fill="#4a90d9" font-size="11" font-weight="bold" text-anchor="middle" dominant-baseline="middle">${heIdent}</text>`;
                        }
                    }
                }
            }
            
            // Add compass rose - North pointing UP
            svgContent += `
                <g transform="translate(${width - 25}, 25)">
                    <circle cx="0" cy="0" r="15" fill="none" stroke="#444" stroke-width="1"/>
                    <line x1="0" y1="0" x2="0" y2="-12" stroke="#4a90d9" stroke-width="2"/>
                    <polygon points="0,-15 -4,-8 4,-8" fill="#4a90d9"/>
                    <text x="0" y="-20" fill="#4a90d9" font-size="10" text-anchor="middle">N</text>
                </g>
            `;
            
            // Add wind vector if wind data is available
            if (windData && windData.speed !== null) {
                if (windData.speed === 0) {
                    // Calm wind indicator
                    svgContent += `
                        <rect x="5" y="5" width="80" height="55" fill="#0a1a0a" fill-opacity="0.8" stroke="#333" rx="4"/>
                        <text x="45" y="18" fill="#888" font-size="9" text-anchor="middle">WIND</text>
                        <text x="45" y="38" fill="#44ff44" font-size="14" font-weight="bold" text-anchor="middle">CALM</text>
                        <text x="45" y="52" fill="#888" font-size="9" text-anchor="middle">0kt</text>
                    `;
                } else {
                    svgContent += generateWindVector(centerX, centerY, windData, width, height);
                }
            }
            
            return `
                <svg width="${width}" height="${height}" viewBox="0 0 ${width} ${height}">
                    <rect width="100%" height="100%" fill="#0a1a0a"/>
                    ${svgContent}
                </svg>
            `;
        }
        
        // Generate wind vector overlay
        function generateWindVector(centerX, centerY, windData, svgWidth, svgHeight) {
            const { direction, speed, gust, variable } = windData;
            
            // Wind color based on speed
            let windColor;
            if (speed >= 30 || (gust && gust >= 35)) {
                windColor = '#ff4444'; // Red - severe
            } else if (speed >= 20 || (gust && gust >= 25)) {
                windColor = '#ff8c00'; // Orange - strong
            } else if (speed >= 10) {
                windColor = '#ffd700'; // Yellow - moderate
            } else {
                windColor = '#44ff44'; // Green - light
            }
            
            let svgContent = '';
            
            // Wind legend box background
            svgContent += `
                <rect x="5" y="5" width="80" height="75" fill="#0a1a0a" fill-opacity="0.9" stroke="#333" rx="4"/>
                <text x="45" y="18" fill="#888" font-size="9" text-anchor="middle">WIND</text>
            `;
            
            // Position wind arrow in legend box
            const windCenterX = 45;
            const windCenterY = 45;
            
            if (variable) {
                // Variable wind - show circular indicator
                svgContent += `
                    <circle cx="${windCenterX}" cy="${windCenterY}" r="18" fill="none" stroke="${windColor}" stroke-width="2" stroke-dasharray="5,3"/>
                    <text x="${windCenterX}" y="${windCenterY - 2}" fill="${windColor}" font-size="10" font-weight="bold" text-anchor="middle">VRB</text>
                    <text x="${windCenterX}" y="${windCenterY + 10}" fill="${windColor}" font-size="10" text-anchor="middle">${speed}kt</text>
                `;
            } else if (direction !== null) {
                // Wind direction: METAR says where wind comes FROM
                // Arrow shows where wind is GOING (flow direction) = direction + 180
                const flowDirection = (direction + 180) % 360;
                
                // Convert to our coordinate system: North=up(-Y), East=right(+X)
                const flowRad = flowDirection * Math.PI / 180;
                const dx = Math.sin(flowRad);
                const dy = -Math.cos(flowRad);
                
                // Arrow length based on speed
                const arrowLength = Math.min(25 + speed * 1.2, 55);
                
                // Arrow from tail to head (in flow direction)
                const tailX = windCenterX - dx * arrowLength / 2;
                const tailY = windCenterY - dy * arrowLength / 2;
                const headX = windCenterX + dx * arrowLength / 2;
                const headY = windCenterY + dy * arrowLength / 2;
                
                // Gust extension
                if (gust && gust > speed) {
                    const gustLength = Math.min(25 + gust * 1.2, 65);
                    const gustHeadX = windCenterX + dx * gustLength / 2;
                    const gustHeadY = windCenterY + dy * gustLength / 2;
                    svgContent += `
                        <line x1="${headX}" y1="${headY}" x2="${gustHeadX}" y2="${gustHeadY}" 
                            stroke="${windColor}" stroke-width="3" stroke-dasharray="3,2" opacity="0.6"/>
                    `;
                }
                
                // Main arrow shaft
                svgContent += `
                    <line x1="${tailX}" y1="${tailY}" x2="${headX}" y2="${headY}" 
                        stroke="${windColor}" stroke-width="3" stroke-linecap="round"/>
                `;
                
                // Arrowhead
                const headSize = 8;
                const perpDx = Math.cos(flowRad);
                const perpDy = Math.sin(flowRad);
                svgContent += `
                    <polygon points="${headX},${headY} ${headX - dx*headSize - perpDx*4},${headY - dy*headSize - perpDy*4} ${headX - dx*headSize + perpDx*4},${headY - dy*headSize + perpDy*4}" 
                        fill="${windColor}"/>
                `;
                
                // Wind barbs on the tail side
                let remainingSpeed = speed;
                let barbPos = 0.15;
                while (remainingSpeed >= 5 && barbPos < 0.5) {
                    const posX = tailX + (headX - tailX) * barbPos;
                    const posY = tailY + (headY - tailY) * barbPos;
                    const barbLen = remainingSpeed >= 10 ? 7 : 4;
                    
                    svgContent += `
                        <line x1="${posX}" y1="${posY}" x2="${posX + perpDx*barbLen}" y2="${posY + perpDy*barbLen}" 
                            stroke="${windColor}" stroke-width="2" stroke-linecap="round"/>
                    `;
                    remainingSpeed -= (remainingSpeed >= 10) ? 10 : 5;
                    barbPos += 0.12;
                }
                
                // Speed and direction labels
                let speedText = gust ? `${speed}G${gust}` : `${speed}kt`;
                const dirText = `${String(direction).padStart(3, '0')}&deg;`;
                
                svgContent += `
                    <text x="${windCenterX}" y="70" fill="${windColor}" font-size="10" font-weight="bold" text-anchor="middle">${speedText}</text>
                    <text x="${windCenterX}" y="80" fill="#666" font-size="8" text-anchor="middle">from ${dirText}</text>
                `;
            }
            
            return svgContent;
        }
        
        // Format surface type
        function formatSurface(surface) {
            if (!surface) return 'Unknown';
            // Common surface abbreviations
            const abbrevs = {
                'ASP': 'Asphalt',
                'CON': 'Concrete',
                'ASPH': 'Asphalt',
                'CONC': 'Concrete',
                'GRS': 'Grass',
                'TURF': 'Turf',
                'GVL': 'Gravel',
                'DIRT': 'Dirt'
            };
            
            const upper = surface.toUpperCase();
            for (const [abbr, full] of Object.entries(abbrevs)) {
                if (upper.includes(abbr)) return full;
            }
            
            // Clean up the surface string
            return surface.split('-')[0].split(' - ')[0].trim();
        }
        
        // Close runway modal
        function closeRunwayModal(event) {
            if (event && event.target !== event.currentTarget) return;
            document.getElementById('runwayModal').classList.remove('active');
        }
        
        // Close modal on Escape key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                closeRunwayModal();
            }
        });

        function parseMetar(metar) {
            if (!metar || metar.length < 10) return null;

            const result = {
                raw: metar,
                icao: null,
                temp_c: null,
                dewpoint_c: null,
                dewpoint_spread: null,
                altimeter: null,
                weather: [],
                rmk_weather: [],
                weather_intensity: {},
                visibility: 10,
                visibility_text: '',
                ceiling: null,
                ceiling_text: '',
                cloud_layers: [],
                flight_rules: 'VFR',
                frozen_precip: false,
                rmk_frozen_precip: false,
                has_precip: false,
                has_moisture: false,
                obs_time: null,
                wind_dir: null,
                wind_speed: null,
                wind_gust: null,
                wind_variable: false,
                remarks: ''
            };

            const icaoMatch = metar.match(/\b([A-Z]{4})\b/);
            if (icaoMatch) result.icao = icaoMatch[1];
            else return null;

            // Extract observation time (format: 031852Z = day 03, 18:52 UTC)
            const timeMatch = metar.match(/\b(\d{2})(\d{2})(\d{2})Z\b/);
            if (timeMatch) {
                const day = parseInt(timeMatch[1]);
                const hour = parseInt(timeMatch[2]);
                const min = parseInt(timeMatch[3]);
                const now = new Date();
                const obsDate = new Date(Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), day, hour, min));
                // Handle month rollover
                if (obsDate > now) {
                    obsDate.setUTCMonth(obsDate.getUTCMonth() - 1);
                }
                result.obs_time = obsDate;
            }

            // Extract wind data (format: 27015G25KT or VRB05KT)
            const windMatch = metar.match(/\b(VRB|\d{3})(\d{2,3})(G(\d{2,3}))?KT\b/);
            if (windMatch) {
                if (windMatch[1] === 'VRB') {
                    result.wind_variable = true;
                    result.wind_dir = 'VRB';
                } else {
                    result.wind_dir = parseInt(windMatch[1]);
                }
                result.wind_speed = parseInt(windMatch[2]);
                if (windMatch[4]) {
                    result.wind_gust = parseInt(windMatch[4]);
                }
            }

            const tempMatch = metar.match(/\s(M?\d{2})\/(M?\d{2})\s/);
            if (tempMatch) {
                const tempStr = tempMatch[1];
                const dewStr = tempMatch[2];
                result.temp_c = tempStr.startsWith('M') ? -parseInt(tempStr.slice(1)) : parseInt(tempStr);
                result.dewpoint_c = dewStr.startsWith('M') ? -parseInt(dewStr.slice(1)) : parseInt(dewStr);
                result.dewpoint_spread = result.temp_c - result.dewpoint_c;
            }
            
            // Parse altimeter (pressure) - format: A2992 or Q1013
            const altMatch = metar.match(/\b(A\d{4}|Q\d{4})\b/);
            if (altMatch) {
                const altStr = altMatch[1];
                if (altStr.startsWith('A')) {
                    result.altimeter = parseFloat(altStr.slice(1)) / 100; // inHg
                } else {
                    result.altimeter = parseInt(altStr.slice(1)); // hPa
                }
            }
            
            // Extract remarks section first
            const rmkMatch = metar.match(/\sRMK\s(.+)$/);
            if (rmkMatch) {
                result.remarks = rmkMatch[1];
            }
            
            // Split METAR into main body (before RMK) and remarks
            const rmkIndex = metar.indexOf(' RMK ');
            const mainBody = rmkIndex > 0 ? metar.substring(0, rmkIndex) : metar;
            const rmkSection = rmkIndex > 0 ? metar.substring(rmkIndex) : '';

            // Parse visibility with text (from main body)
            const visMatch = mainBody.match(/\s(\d+)\s?SM\b/);
            const visFracMatch = mainBody.match(/\s(\d+)?\s?(\d\/\d+)\s?SM\b/);
            const visP6Match = mainBody.match(/\bP6SM\b/);
            
            if (visP6Match) {
                result.visibility = 7;
                result.visibility_text = 'P6SM';
            } else if (visFracMatch) {
                const whole = visFracMatch[1] ? parseInt(visFracMatch[1]) : 0;
                const frac = visFracMatch[2];
                const [num, den] = frac.split('/').map(Number);
                result.visibility = whole + (num / den);
                result.visibility_text = visFracMatch[0].trim();
            } else if (visMatch) {
                result.visibility = parseInt(visMatch[1]);
                result.visibility_text = visMatch[1] + 'SM';
            }

            // Parse weather from MAIN BODY only (not remarks)
            // Match patterns like: +SN, -SN, SN, +FZRA, -TSRA, etc.
            const wxPattern = /\s(\+|-|VC)?((TS|SH|FZ|DR|BL|MI|PR|BC|RE)*)?(DZ|RA|SN|SG|IC|PL|GR|GS|UP|BR|FG|FU|VA|DU|SA|HZ|PY|PO|SQ|FC|SS|DS)\b/g;
            const wxMatches = mainBody.matchAll(wxPattern);
            
            for (const match of wxMatches) {
                const intensity = match[1] || ''; // +, -, or empty
                const descriptor = match[2] || ''; // TS, SH, FZ, DR, BL, etc.
                const precip = match[4]; // The main weather type
                
                // Build the full weather code
                let wxCode = descriptor + precip;
                
                // Store intensity separately
                result.weather_intensity[wxCode] = intensity === '+' ? 'heavy' : intensity === '-' ? 'light' : 'moderate';
                
                // Add to weather array with intensity for display
                const displayCode = intensity + wxCode;
                if (!result.weather.includes(displayCode) && !result.weather.includes(wxCode)) {
                    result.weather.push(displayCode);
                }
                
                // Check for precipitation
                if (['DZ', 'RA', 'SN', 'SG', 'IC', 'PL', 'GR', 'GS', 'UP'].includes(precip)) {
                    result.has_precip = true;
                }
                
                // Check for frozen precip
                if (['SN', 'SG', 'IC', 'PL', 'GR', 'GS'].includes(precip) || 
                    (descriptor.includes('FZ') && ['DZ', 'RA', 'FG'].includes(precip))) {
                    result.frozen_precip = true;
                }
                
                // Check for moisture
                if (['BR', 'FG'].includes(precip)) {
                    result.has_moisture = true;
                }
            }
            
            // Parse weather from REMARKS section (for display as "RMK: xxx")
            // RMK weather is less operationally significant - track separately
            if (rmkSection) {
                const rmkWxMatches = rmkSection.matchAll(wxPattern);
                for (const match of rmkWxMatches) {
                    const intensity = match[1] || '';
                    const descriptor = match[2] || '';
                    const precip = match[4];
                    const displayCode = intensity + descriptor + precip;
                    
                    if (!result.rmk_weather.includes(displayCode)) {
                        result.rmk_weather.push(displayCode);
                    }
                    
                    // Track frozen precip in remarks separately (less significant than main body)
                    if (['SN', 'SG', 'IC', 'PL', 'GR', 'GS'].includes(precip) || 
                        (descriptor.includes('FZ') && ['DZ', 'RA', 'FG'].includes(precip))) {
                        result.rmk_frozen_precip = true;
                    }
                }
            }
            
            // Fallback: also check for simple codes that might be missed in main body
            // Use regex with space/intensity prefix to avoid matching airport codes (e.g., KMSN matching SN)
            for (const code of FROZEN_PRECIP) {
                const codeRegex = new RegExp(`\\s[-+]?${code}\\b`);
                if (codeRegex.test(mainBody) && !result.weather.some(w => w.includes(code))) {
                    result.weather.push(code);
                    result.frozen_precip = true;
                    result.has_precip = true;
                }
            }

            // Parse cloud layers (from main body)
            const cloudPattern = /(SKC|CLR|FEW|SCT|BKN|OVC|VV)(\d{3})/g;
            const cloudMatches = mainBody.matchAll(cloudPattern);
            for (const match of cloudMatches) {
                const type = match[1];
                const alt = parseInt(match[2]) * 100;
                const text = match[1] + match[2];
                result.cloud_layers.push({ type, altitude: alt, text });
                
                // Track ceiling (BKN, OVC, or VV)
                if ((type === 'BKN' || type === 'OVC' || type === 'VV') && 
                    (result.ceiling === null || alt < result.ceiling)) {
                    result.ceiling = alt;
                    result.ceiling_text = text;
                }
            }

            const vis = result.visibility;
            const ceil = result.ceiling;
            if ((ceil !== null && ceil < 500) || vis < 1) result.flight_rules = 'LIFR';
            else if ((ceil !== null && ceil < 1000) || vis < 3) result.flight_rules = 'IFR';
            else if ((ceil !== null && ceil < 3000) || vis < 5) result.flight_rules = 'MVFR';

            return result;
        }

        function categorize(parsed) {
            if (parsed.temp_c === null) return 'unknown';
            
            const temp = parsed.temp_c;
            
            // Active: frozen precip in MAIN BODY of METAR (not just remarks)
            if (temp <= 0 && parsed.frozen_precip) return 'active';
            // Check for freezing rain/drizzle in main body with any intensity prefix
            if (parsed.weather.some(wx => wx.includes('FZRA') || wx.includes('FZDZ'))) return 'active';
            
            // Residual: frozen precip only in RMK section, OR recent history had frozen
            // RMK weather (like DRSN) is less significant - indicates nearby/peripheral conditions
            if (temp <= 3 && !parsed.frozen_precip && (parsed.had_recent_frozen || parsed.rmk_frozen_precip)) return 'residual';
            
            if (temp <= 0 && parsed.has_precip) return 'likely';
            if (temp <= 0 && parsed.has_moisture) return 'likely';
            if (temp <= 0) return 'possible';
            if (temp <= 3 && parsed.has_precip) return 'marginal';
            return 'none';
        }
        
        function checkRecentFrozen(history) {
            if (!history || history.length < 2) return { hadFrozen: false, lastFrozenTime: null, frozenTypes: [] };
            
            // Skip the first (current) observation, check the rest
            const pastObs = history.slice(1);
            const frozenTypes = new Set();
            let lastFrozenTime = null;
            
            for (const obs of pastObs) {
                for (const wx of obs.weather) {
                    // Strip intensity prefix (+/-) and check if it contains any frozen precip code
                    const stripped = wx.replace(/^[-+]/, '');
                    for (const code of FROZEN_PRECIP) {
                        if (stripped === code || stripped.includes(code)) {
                            frozenTypes.add(code);
                            if (!lastFrozenTime && obs.obs_time) {
                                lastFrozenTime = obs.obs_time;
                            }
                        }
                    }
                }
            }
            
            return {
                hadFrozen: frozenTypes.size > 0,
                lastFrozenTime: lastFrozenTime,
                frozenTypes: Array.from(frozenTypes)
            };
        }

        // Format weather display with ceiling and RMK weather
        function formatWeatherDisplay(apt, includeCeiling = true) {
            const parts = [];
            
            // Add ceiling if exists and requested (default true for backward compatibility)
            if (includeCeiling !== false && apt.ceiling_text) {
                parts.push(apt.ceiling_text);
            }
            
            // Add main body weather
            if (apt.weather && apt.weather.length > 0) {
                parts.push(...apt.weather);
            }
            
            // Add RMK weather with prefix
            if (apt.rmk_weather && apt.rmk_weather.length > 0) {
                parts.push('RMK:' + apt.rmk_weather.join(' '));
            }
            
            return parts.length > 0 ? parts.join(' ') : '&mdash;';
        }
        
        // Format weather for history rows (no ceiling - shown separately)
        function formatHistoryWeather(h) {
            const parts = [];
            if (h.weather && h.weather.length > 0) {
                parts.push(...h.weather);
            }
            if (h.rmk_weather && h.rmk_weather.length > 0) {
                parts.push('RMK:' + h.rmk_weather.join(' '));
            }
            return parts.length > 0 ? parts.join(' ') : '&mdash;';
        }

        function getLocalTime(icao) {
            const tz = AIRPORT_TIMEZONES[icao];
            if (!tz) return null;
            
            try {
                const now = new Date();
                const localTime = new Date(now.toLocaleString('en-US', { timeZone: tz }));
                return localTime;
            } catch (e) {
                return null;
            }
        }

        function getRushStatus(icao) {
            const localTime = getLocalTime(icao);
            if (!localTime) return null;
            
            const hour = localTime.getHours();
            const dayOfWeek = localTime.getDay(); // 0 = Sunday
            
            // Weekends have different patterns
            const isWeekend = dayOfWeek === 0 || dayOfWeek === 6;
            
            if (isWeekend) {
                // Weekend patterns are less pronounced
                if (hour >= 7 && hour < 11) return 'AM RUSH';
                if (hour >= 15 && hour < 19) return 'PM RUSH';
            } else {
                // Weekday patterns
                if (hour >= 6 && hour < 9) return 'AM RUSH';
                if (hour >= 16 && hour < 19) return 'PM RUSH';
            }
            
            return null;
        }

        function getHubInfo(icao) {
            return HUB_AIRPORTS[icao] || null;
        }

        async function fetchTrafficManagement() {
            // FAA Airport Status API - now returns XML
            const url = 'https://nasstatus.faa.gov/api/airport-status-information';
            
            try {
                const text = await tryFetch(url);
                trafficPrograms = {};
                
                // Check if response is XML (starts with <)
                if (text.trim().startsWith('<')) {
                    // Parse XML response
                    const parser = new DOMParser();
                    const xmlDoc = parser.parseFromString(text, 'text/xml');
                    
                    // Check for parse errors
                    const parseError = xmlDoc.querySelector('parsererror');
                    if (parseError) {
                        console.log('XML parse error:', parseError.textContent);
                        return;
                    }
                    
                    // Get update time for logging
                    const updateTime = xmlDoc.querySelector('Update_Time')?.textContent || 'unknown';
                    console.log('FAA NAS Status XML - Updated:', updateTime);
                    
                    // Parse Ground Delay Programs
                    const gdpNodes = xmlDoc.querySelectorAll('Ground_Delay_List Ground_Delay');
                    console.log('Found', gdpNodes.length, 'Ground Delay Programs');
                    for (const gdp of gdpNodes) {
                        const arpt = gdp.querySelector('ARPT')?.textContent;
                        if (!arpt) continue;
                        
                        const icao = 'K' + arpt;
                        if (!trafficPrograms[icao]) trafficPrograms[icao] = [];
                        
                        const avgDelay = gdp.querySelector('Avg')?.textContent || 'N/A';
                        const maxDelay = gdp.querySelector('Max')?.textContent || '';
                        const reason = gdp.querySelector('Reason')?.textContent || '';
                        
                        trafficPrograms[icao].push({
                            type: 'GDP',
                            avgDelay: avgDelay,
                            maxDelay: maxDelay,
                            reason: reason
                        });
                    }
                    
                    // Parse Ground Stops
                    const gsNodes = xmlDoc.querySelectorAll('Ground_Stop_List Ground_Stop');
                    console.log('Found', gsNodes.length, 'Ground Stops');
                    for (const gs of gsNodes) {
                        const arpt = gs.querySelector('ARPT')?.textContent;
                        if (!arpt) continue;
                        
                        const icao = 'K' + arpt;
                        if (!trafficPrograms[icao]) trafficPrograms[icao] = [];
                        
                        const endTime = gs.querySelector('End_Time')?.textContent || 
                                       gs.querySelector('Endtime')?.textContent || 'TBD';
                        const reason = gs.querySelector('Reason')?.textContent || '';
                        
                        trafficPrograms[icao].push({
                            type: 'GROUND STOP',
                            endTime: endTime,
                            reason: reason
                        });
                    }
                    
                    // Parse Arrival/Departure Delays - try multiple selectors
                    // Structure might be: Arrival_Departure_Delay_List > Delay with Arrival_Departure child or attribute
                    const delayNodes = xmlDoc.querySelectorAll('Arrival_Departure_Delay_List Delay, Arrival_Departure_Delay_List Arrival_Delay, Arrival_Departure_Delay_List Departure_Delay');
                    console.log('Found', delayNodes.length, 'Arrival/Departure Delays');
                    for (const delay of delayNodes) {
                        const arpt = delay.querySelector('ARPT')?.textContent;
                        if (!arpt) continue;
                        
                        const icao = 'K' + arpt;
                        if (!trafficPrograms[icao]) trafficPrograms[icao] = [];
                        
                        const minDelay = delay.querySelector('Min')?.textContent || '';
                        const maxDelay = delay.querySelector('Max')?.textContent || '';
                        const reason = delay.querySelector('Reason')?.textContent || '';
                        
                        // Determine if arrival or departure
                        const typeAttr = delay.getAttribute('Arrival_Departure');
                        const typeChild = delay.querySelector('Arrival_Departure')?.textContent;
                        const tagName = delay.tagName;
                        
                        let delayType = 'DELAY';
                        if (typeAttr === 'Arrival' || typeChild === 'Arrival' || tagName === 'Arrival_Delay') {
                            delayType = 'ARR DELAY';
                        } else if (typeAttr === 'Departure' || typeChild === 'Departure' || tagName === 'Departure_Delay') {
                            delayType = 'DEP DELAY';
                        }
                        
                        trafficPrograms[icao].push({
                            type: delayType,
                            minDelay: minDelay,
                            maxDelay: maxDelay,
                            reason: reason
                        });
                    }
                    
                    // Parse Deicing (if present in XML)
                    const deiceNodes = xmlDoc.querySelectorAll('Deicing_List Airport, Deice_List Airport');
                    if (deiceNodes.length > 0) console.log('Found', deiceNodes.length, 'Deicing Programs');
                    for (const deice of deiceNodes) {
                        const arpt = deice.querySelector('ARPT')?.textContent || deice.textContent?.trim();
                        if (!arpt) continue;
                        
                        const icao = 'K' + arpt;
                        if (!trafficPrograms[icao]) trafficPrograms[icao] = [];
                        
                        trafficPrograms[icao].push({
                            type: 'DEICING',
                            reason: 'Formal deicing program active'
                        });
                    }
                    
                    console.log('Traffic programs loaded (XML):', Object.keys(trafficPrograms).length, 'airports affected');
                    if (Object.keys(trafficPrograms).length > 0) {
                        console.log('Affected airports:', Object.keys(trafficPrograms).join(', '));
                    }
                    
                } else {
                    // Try JSON parsing as fallback
                    try {
                        const data = JSON.parse(text);
                        if (data && Array.isArray(data)) {
                            for (const item of data) {
                                const icao = 'K' + item.airportId;
                                if (AIRPORTS.includes(icao)) {
                                    const programs = [];
                                    
                                    if (item.groundDelay && item.groundDelay.status === true) {
                                        programs.push({
                                            type: 'GDP',
                                            avgDelay: item.groundDelay.avgDelay || 'N/A',
                                            reason: item.groundDelay.reason || ''
                                        });
                                    }
                                    
                                    if (item.groundStop && item.groundStop.status === true) {
                                        programs.push({
                                            type: 'GROUND STOP',
                                            endTime: item.groundStop.endTime || 'TBD',
                                            reason: item.groundStop.reason || ''
                                        });
                                    }
                                    
                                    if (item.arrivalDelay && item.arrivalDelay.status === true) {
                                        programs.push({
                                            type: 'ARR DELAY',
                                            minDelay: item.arrivalDelay.minDelay || '',
                                            maxDelay: item.arrivalDelay.maxDelay || '',
                                            reason: item.arrivalDelay.reason || ''
                                        });
                                    }
                                    
                                    if (item.departureDelay && item.departureDelay.status === true) {
                                        programs.push({
                                            type: 'DEP DELAY',
                                            minDelay: item.departureDelay.minDelay || '',
                                            maxDelay: item.departureDelay.maxDelay || '',
                                            reason: item.departureDelay.reason || ''
                                        });
                                    }
                                    
                                    if (item.deicing && item.deicing.status === true) {
                                        programs.push({
                                            type: 'DEICING',
                                            startTime: item.deicing.startTime || '',
                                            reason: 'Formal deicing program active'
                                        });
                                    }
                                    
                                    if (programs.length > 0) {
                                        trafficPrograms[icao] = programs;
                                    }
                                }
                            }
                        }
                        console.log('Traffic programs loaded (JSON):', Object.keys(trafficPrograms).length, 'airports affected');
                    } catch (jsonErr) {
                        console.log('Traffic data parse failed - not JSON or XML');
                    }
                }
                
            } catch (e) {
                console.log('Traffic management fetch failed:', e.message);
            }
        }

        // FAA ATCSCC Advisory Database - more detailed info on GDPs, constraints, runway closures
        let faaAdvisoryData = {
            terminalActive: {},      // Active GDPs/Ground Stops with end times
            terminalPlanned: {},     // Planned/possible ground stops
            terminalConstraints: {}, // Weather constraints (TSTMS, LOW CIGS, etc.)
            runwayClosures: {},      // Runway/taxiway closures
            enRouteConstraints: [],  // En route issues
            rawText: ''
        };

        async function fetchFAAAdvisory() {
            const url = 'https://www.fly.faa.gov/adv/adv_spt';
            
            // Reset data before fetching
            faaAdvisoryData = {
                terminalActive: {},
                terminalPlanned: {},
                terminalConstraints: {},
                runwayClosures: {},
                enRouteConstraints: [],
                rawText: ''
            };
            
            try {
                const text = await tryFetch(url, 0, 100);
                
                if (!text || text.length < 100) {
                    console.log('FAA Advisory: No data returned');
                    return;
                }
                
                faaAdvisoryData.rawText = text;
                
                // Parse TERMINAL ACTIVE section (active GDPs/Ground Stops)
                const terminalActiveMatch = text.match(/TERMINAL ACTIVE:\s*([\s\S]*?)(?=TERMINAL PLANNED:|EN ROUTE|$)/i);
                if (terminalActiveMatch) {
                    const lines = terminalActiveMatch[1].trim().split('\n');
                    for (const line of lines) {
                        // Format: UNTIL 1829 -SEA GROUND DELAY PROGRAM
                        const match = line.match(/UNTIL\s+(\d{4})\s+-([A-Z]{3})\s+(.+)/i);
                        if (match) {
                            const endTime = match[1];
                            const airport = 'K' + match[2];
                            const program = match[3].trim();
                            
                            if (!faaAdvisoryData.terminalActive[airport]) {
                                faaAdvisoryData.terminalActive[airport] = [];
                            }
                            faaAdvisoryData.terminalActive[airport].push({
                                endTime: endTime,
                                program: program
                            });
                        }
                    }
                }
                
                // Parse TERMINAL PLANNED section
                const terminalPlannedMatch = text.match(/TERMINAL PLANNED:\s*([\s\S]*?)(?=EN ROUTE|CDRS|$)/i);
                if (terminalPlannedMatch) {
                    const lines = terminalPlannedMatch[1].trim().split('\n');
                    for (const line of lines) {
                        // Format: UNTIL 0200 -MIA/FLL GROUND STOP POSSIBLE
                        const match = line.match(/UNTIL\s+(\d{4})\s+-([A-Z\/]+)\s+(.+)/i);
                        if (match) {
                            const airports = match[2].split('/');
                            const program = match[3].trim();
                            
                            for (const apt of airports) {
                                const icao = 'K' + apt;
                                if (!faaAdvisoryData.terminalPlanned[icao]) {
                                    faaAdvisoryData.terminalPlanned[icao] = [];
                                }
                                faaAdvisoryData.terminalPlanned[icao].push(program);
                            }
                        }
                    }
                }
                
                // Parse TERMINAL CONSTRAINTS section
                const constraintsMatch = text.match(/TERMINAL CONSTRAINTS:\s*([\s\S]*?)(?=TERMINAL ACTIVE:|TERMINAL PLANNED:|EN ROUTE|$)/i);
                if (constraintsMatch) {
                    const lines = constraintsMatch[1].trim().split('\n');
                    for (const line of lines) {
                        // Format: FLL/MIA - TSTMS or SFO/SEA - LOW CEILINGS
                        const match = line.match(/([A-Z\/]+)\s+-\s+(.+)/i);
                        if (match) {
                            const airports = match[1].split('/');
                            const constraint = match[2].trim();
                            
                            for (const apt of airports) {
                                const icao = 'K' + apt;
                                faaAdvisoryData.terminalConstraints[icao] = constraint;
                            }
                        }
                    }
                }
                
                // Parse RUNWAY/EQUIPMENT section
                const runwayMatch = text.match(/RUNWAY\/EQUIPMENT.*?:\s*([\s\S]*?)(?=AIRSPACE FLOW|PLANNED LAUNCH|FLIGHT CHECK|VIP|NEXT PLANNING|$)/i);
                if (runwayMatch) {
                    const lines = runwayMatch[1].trim().split('\n');
                    for (const line of lines) {
                        // Format: DEN - TWY CONSTRUCTION UNTIL 10/05/2025 2359Z
                        // or: ORD - EAST TAXIWAY CONSTRUCTION UNTIL 10/23/25
                        const match = line.match(/^([A-Z]{3})\s+-\s+(.+)/i);
                        if (match) {
                            const icao = 'K' + match[1];
                            const issue = match[2].trim();
                            
                            if (!faaAdvisoryData.runwayClosures[icao]) {
                                faaAdvisoryData.runwayClosures[icao] = [];
                            }
                            faaAdvisoryData.runwayClosures[icao].push(issue);
                        }
                    }
                }
                
                // Parse STAFFING TRIGGER section
                const staffingMatch = text.match(/STAFFING TRIGGER\(S\):\s*([\s\S]*?)(?=TERMINAL|EN ROUTE|$)/i);
                if (staffingMatch && !staffingMatch[1].includes('NONE')) {
                    const lines = staffingMatch[1].trim().split('\n');
                    for (const line of lines) {
                        // Format: UNTIL 2130 -ZAB SOUTHWEST AREA or 0000 - 0500 -C90 TRACON
                        const match = line.match(/([A-Z]\d{2}|[A-Z]{3})/i);
                        if (match) {
                            // Store staffing issues - these affect capacity
                            const facility = match[1];
                            if (!faaAdvisoryData.staffingTriggers) {
                                faaAdvisoryData.staffingTriggers = [];
                            }
                            faaAdvisoryData.staffingTriggers.push(line.trim());
                        }
                    }
                }
                
                const activeCount = Object.keys(faaAdvisoryData.terminalActive).length;
                const constraintCount = Object.keys(faaAdvisoryData.terminalConstraints).length;
                const runwayCount = Object.keys(faaAdvisoryData.runwayClosures).length;
                
                console.log(`FAA Advisory loaded: ${activeCount} active programs, ${constraintCount} constraints, ${runwayCount} runway issues`);
                
            } catch (e) {
                console.error('FAA Advisory fetch failed:', e.message);
            }
        }

        async function fetchTAFs() {
            try {
                const ids = AIRPORTS.join(',');
                const url = `https://aviationweather.gov/api/data/taf?ids=${ids}&format=raw`;
                console.log('Fetching TAFs from:', url);
                const text = await tryFetch(url, 0, 20);
                
                tafData = {};
                
                if (!text || text.length < 30) {
                    console.log('TAF: No data or empty response');
                    return;
                }
                
                console.log('TAF response length:', text.length);
                
                // TAFs can be separated by double newlines or be on single lines
                // Match both US (KXXX) and Canadian (CYXX) airports
                const tafParts = text.split(/(?=TAF\s+(?:K[A-Z]{3}|C[A-Z]{3}))/);
                console.log('TAF parts found:', tafParts.length);
                
                const now = new Date();
                const currentHour = now.getUTCHours();
                const currentDay = now.getUTCDate();
                
                for (const taf of tafParts) {
                    if (!taf.trim()) continue;
                    
                    const icaoMatch = taf.match(/TAF\s+((?:K[A-Z]{3}|C[A-Z]{3}))/);
                    if (!icaoMatch) continue;
                    
                    const icao = icaoMatch[1];
                    const forecasts = [];
                    let conditionChanges = [];
                    let nextFrozenStart = null;
                    let frozenEndsAt = null;
                    let tempForecasts = [];
                    
                    // Parse FM (From) groups - format: FM041200
                    const fmPattern = /FM(\d{2})(\d{2})(\d{2})\s+([^F]+?)(?=FM\d{6}|TEMPO|BECMG|PROB|$)/g;
                    let fmMatches = [...taf.matchAll(fmPattern)];
                    
                    for (const fm of fmMatches) {
                        const day = parseInt(fm[1]);
                        const hour = parseInt(fm[2]);
                        const minute = parseInt(fm[3]);
                        const conditions = fm[4].trim();
                        
                        // Check for frozen precip in this period
                        const hasFrozen = /\b(\+|-)?((SN)|(FZRA)|(FZDZ)|(PL)|(FZFG)|(GS)|(GR)|(IC))\b/.test(conditions);
                        
                        // Extract temperature if present (TX/TN groups or temp remarks)
                        const tempMatch = conditions.match(/\b(TX|TN)(M?\d{2})\/(\d{2})(\d{2})Z\b/);
                        if (tempMatch) {
                            const tempType = tempMatch[1]; // TX = max, TN = min
                            const tempVal = tempMatch[2].startsWith('M') ? -parseInt(tempMatch[2].slice(1)) : parseInt(tempMatch[2]);
                            const tempDay = parseInt(tempMatch[3]);
                            const tempHour = parseInt(tempMatch[4]);
                            tempForecasts.push({
                                type: tempType,
                                temp: tempVal,
                                day: tempDay,
                                hour: tempHour
                            });
                        }
                        
                        conditionChanges.push({
                            type: 'FM',
                            day: day,
                            hour: hour,
                            minute: minute,
                            conditions: conditions,
                            hasFrozen: hasFrozen,
                            timeStr: `${String(hour).padStart(2,'0')}${String(minute).padStart(2,'0')}Z`
                        });
                    }
                    
                    // Parse TEMPO groups - format: TEMPO 0412/0418
                    const tempoPattern = /TEMPO\s+(\d{2})(\d{2})\/(\d{2})(\d{2})\s+([^T\n]+?)(?=TEMPO|FM|BECMG|PROB|$)/g;
                    let tempoMatches = [...taf.matchAll(tempoPattern)];
                    
                    for (const tempo of tempoMatches) {
                        const startDay = parseInt(tempo[1]);
                        const startHour = parseInt(tempo[2]);
                        const endDay = parseInt(tempo[3]);
                        const endHour = parseInt(tempo[4]);
                        const conditions = tempo[5].trim();
                        
                        const hasFrozen = /\b(\+|-)?((SN)|(FZRA)|(FZDZ)|(PL)|(FZFG)|(GS)|(GR)|(IC))\b/.test(conditions);
                        
                        conditionChanges.push({
                            type: 'TEMPO',
                            startDay: startDay,
                            startHour: startHour,
                            endDay: endDay,
                            endHour: endHour,
                            conditions: conditions,
                            hasFrozen: hasFrozen,
                            timeStr: `${String(startHour).padStart(2,'0')}Z-${String(endHour).padStart(2,'0')}Z`
                        });
                    }
                    
                    // Parse BECMG groups - format: BECMG 0412/0414
                    const becmgPattern = /BECMG\s+(\d{2})(\d{2})\/(\d{2})(\d{2})\s+([^B\n]+?)(?=TEMPO|FM|BECMG|PROB|$)/g;
                    let becmgMatches = [...taf.matchAll(becmgPattern)];
                    
                    for (const becmg of becmgMatches) {
                        const startDay = parseInt(becmg[1]);
                        const startHour = parseInt(becmg[2]);
                        const endDay = parseInt(becmg[3]);
                        const endHour = parseInt(becmg[4]);
                        const conditions = becmg[5].trim();
                        
                        const hasFrozen = /\b(\+|-)?((SN)|(FZRA)|(FZDZ)|(PL)|(FZFG)|(GS)|(GR)|(IC))\b/.test(conditions);
                        const hasNSW = /\bNSW\b/.test(conditions); // No Significant Weather
                        
                        conditionChanges.push({
                            type: 'BECMG',
                            startDay: startDay,
                            startHour: startHour,
                            endDay: endDay,
                            endHour: endHour,
                            conditions: conditions,
                            hasFrozen: hasFrozen,
                            hasNSW: hasNSW,
                            timeStr: `${String(startHour).padStart(2,'0')}-${String(endHour).padStart(2,'0')}Z`
                        });
                    }
                    
                    // Find when frozen precip starts and ends
                    let currentlyFrozen = false;
                    for (const change of conditionChanges) {
                        if (change.hasFrozen && !currentlyFrozen) {
                            nextFrozenStart = change;
                            currentlyFrozen = true;
                        } else if (!change.hasFrozen && currentlyFrozen && change.type === 'FM') {
                            frozenEndsAt = change;
                            break;
                        } else if (change.hasNSW && currentlyFrozen) {
                            frozenEndsAt = change;
                            break;
                        }
                    }
                    
                    // Collect frozen precip forecasts for display
                    const frozenPattern = /\b(\+|-)?((SN)|(FZRA)|(FZDZ)|(PL)|(FZFG)|(GS)|(GR)|(IC))\b/g;
                    const matches = taf.matchAll(frozenPattern);
                    
                    for (const match of matches) {
                        const wx = match[0].replace(/^[+-]/, '');
                        const beforeMatch = taf.substring(0, match.index);
                        const timeMatch = beforeMatch.match(/(FM\d{6}|TEMPO\s+\d{4}\/\d{4}|BECMG\s+\d{4}\/\d{4}|\d{4}\/\d{4})\s*[^\n]*$/);
                        
                        forecasts.push({
                            raw: timeMatch ? timeMatch[0].substring(0, 30) + ' ' + match[0] : match[0],
                            wx: wx,
                            intensity: match[1] || ''
                        });
                    }
                    
                    // Deduplicate forecasts
                    const uniqueForecasts = [];
                    const seen = new Set();
                    for (const fc of forecasts) {
                        if (!seen.has(fc.wx)) {
                            seen.add(fc.wx);
                            uniqueForecasts.push(fc);
                        }
                    }
                    
                    if (uniqueForecasts.length > 0 || taf.length > 20) {
                        tafData[icao] = {
                            raw: taf.substring(0, 500),
                            frozenForecasts: uniqueForecasts,
                            conditionChanges: conditionChanges,
                            nextFrozenStart: nextFrozenStart,
                            frozenEndsAt: frozenEndsAt,
                            tempForecasts: tempForecasts,
                            summary: buildTafSummary(conditionChanges, nextFrozenStart, frozenEndsAt)
                        };
                    }
                }
                
                // Count airports with frozen precip forecasts
                let frozenCount = 0;
                for (const icao in tafData) {
                    if (tafData[icao].frozenForecasts.length > 0) frozenCount++;
                }
                console.log('TAFs loaded:', Object.keys(tafData).length, 'airports,', frozenCount, 'with frozen precip');
                
            } catch (e) {
                console.error('TAF fetch failed:', e.message);
                tafData = {};
            }
        }
        
        // Build a human-readable TAF summary for deicing
        function buildTafSummary(changes, frozenStart, frozenEnd) {
            if (!changes || changes.length === 0) return null;
            
            const frozenChanges = changes.filter(c => c.hasFrozen);
            const clearChanges = changes.filter(c => !c.hasFrozen && (c.type === 'FM' || c.hasNSW));
            
            let summary = '';
            
            if (frozenStart) {
                summary = ` ${frozenStart.type} ${frozenStart.timeStr}`;
            }
            
            if (frozenEnd) {
                summary += summary ? ` &#x2192; ` : '';
                summary += `&#x2714; Ends ${frozenEnd.type} ${frozenEnd.timeStr}`;
            }
            
            return summary || null;
        }

        function getFrostRisk(icao, tempC) {
            // Frost risk: below 4 degC during night/early morning hours
            if (tempC === null || tempC > 4) return false;
            
            const localTime = getLocalTime(icao);
            if (!localTime) return false;
            
            const hour = localTime.getHours();
            // High frost risk window: 10pm - 9am when temps are near/below freezing
            return (hour >= 22 || hour < 9) && tempC <= 4;
        }

        // Holdover Time estimation based on FAA HOT guidelines
        // Returns detailed HOT info for Type I, II, and IV fluids
        function estimateHoldoverTime(tempC, weather, weatherIntensity) {
            if (tempC === null) return null;
            
            // Determine precipitation type and intensity
            let precipType = null;
            let intensity = 'moderate';
            
            for (const wx of weather) {
                const baseWx = wx.replace(/^[+-]/, '');
                const wxIntensity = wx.startsWith('+') ? 'heavy' : wx.startsWith('-') ? 'light' : 
                    (weatherIntensity && weatherIntensity[baseWx]) || 'moderate';
                
                if (baseWx.includes('FZRA') || baseWx === 'FZRA') {
                    precipType = 'freezing_rain';
                    intensity = wxIntensity;
                } else if (baseWx.includes('FZDZ') || baseWx === 'FZDZ') {
                    precipType = 'freezing_drizzle';
                    intensity = wxIntensity;
                } else if (baseWx === 'PL' || baseWx.includes('PL')) {
                    precipType = 'ice_pellets';
                    intensity = wxIntensity;
                } else if (baseWx === 'SN' || baseWx.includes('SN')) {
                    precipType = 'snow';
                    intensity = wxIntensity;
                } else if (baseWx === 'SG') {
                    precipType = 'snow_grains';
                    intensity = wxIntensity;
                } else if (baseWx === 'FZFG' || baseWx.includes('FZFG')) {
                    precipType = 'freezing_fog';
                    intensity = 'moderate';
                } else if ((baseWx === 'RA' || baseWx.includes('RA')) && tempC <= 0) {
                    // Rain at/below freezing = potential for ice
                    precipType = 'rain_freezing_surface';
                    intensity = wxIntensity;
                }
            }
            
            if (!precipType) return null;
            
            // FAA HOT Table values (approximate ranges in minutes)
            // Based on FAA Holdover Time Guidelines
            const hotTables = {
                // Type I (heated, diluted) - shortest times, used for deicing
                typeI: {
                    freezing_rain: { light: [5, 9], moderate: [2, 5], heavy: [0, 2] },
                    freezing_drizzle: { light: [9, 15], moderate: [6, 9], heavy: [2, 6] },
                    snow: {
                        // Varies by temp
                        light: tempC >= -3 ? [11, 17] : tempC >= -14 ? [8, 15] : [6, 11],
                        moderate: tempC >= -3 ? [6, 11] : tempC >= -14 ? [5, 9] : [4, 7],
                        heavy: tempC >= -3 ? [0, 6] : tempC >= -14 ? [0, 5] : [0, 4]
                    },
                    snow_grains: { light: [8, 15], moderate: [5, 8], heavy: [2, 5] },
                    ice_pellets: { light: [5, 10], moderate: [2, 5], heavy: [0, 2] },
                    freezing_fog: { light: [15, 25], moderate: [10, 15], heavy: [5, 10] },
                    rain_freezing_surface: { light: [3, 6], moderate: [1, 3], heavy: [0, 1] }
                },
                // Type IV (thickened, longer protection) - longest times
                typeIV: {
                    freezing_rain: { light: [15, 25], moderate: [8, 15], heavy: [3, 8] },
                    freezing_drizzle: { light: [25, 45], moderate: [15, 25], heavy: [8, 15] },
                    snow: {
                        light: tempC >= -3 ? [35, 65] : tempC >= -14 ? [25, 50] : [18, 35],
                        moderate: tempC >= -3 ? [20, 40] : tempC >= -14 ? [15, 30] : [10, 20],
                        heavy: tempC >= -3 ? [10, 20] : tempC >= -14 ? [8, 15] : [5, 10]
                    },
                    snow_grains: { light: [30, 55], moderate: [18, 30], heavy: [10, 18] },
                    ice_pellets: { light: [10, 20], moderate: [5, 10], heavy: [2, 5] },
                    freezing_fog: { light: [45, 75], moderate: [30, 45], heavy: [15, 30] },
                    rain_freezing_surface: { light: [8, 15], moderate: [3, 8], heavy: [0, 3] }
                }
            };
            
            const typeIHot = hotTables.typeI[precipType]?.[intensity] || [0, 5];
            const typeIVHot = hotTables.typeIV[precipType]?.[intensity] || [5, 15];
            
            // Get the range values
            const typeIRange = Array.isArray(typeIHot) ? typeIHot : [typeIHot, typeIHot];
            const typeIVRange = Array.isArray(typeIVHot) ? typeIVHot : [typeIVHot, typeIVHot];
            
            // Determine urgency status
            let status = 'ok';
            if (typeIVRange[1] <= 10) status = 'critical';
            else if (typeIVRange[1] <= 20) status = 'short';
            else if (typeIVRange[1] <= 35) status = 'caution';
            
            // Friendly precip name
            const precipNames = {
                freezing_rain: 'FZRA',
                freezing_drizzle: 'FZDZ',
                snow: 'Snow',
                snow_grains: 'SG',
                ice_pellets: 'PL',
                freezing_fog: 'FZFG',
                rain_freezing_surface: 'RA/Cold'
            };
            
            return {
                precipType: precipType,
                precipName: precipNames[precipType] || precipType,
                intensity: intensity,
                typeI: { min: typeIRange[0], max: typeIRange[1] },
                typeIV: { min: typeIVRange[0], max: typeIVRange[1] },
                status: status,
                recommendation: status === 'critical' ? 'Two-step deice required' :
                               status === 'short' ? 'Use Type IV, minimize taxi time' :
                               status === 'caution' ? 'Type IV recommended' : 'Standard procedures'
            };
        }

        // Extract field condition info from METAR remarks (for braking action)
        function extractFieldConditions(metar) {
            if (!metar) return null;
            
            const result = {
                brakingAction: null,
                ficonReports: []
            };
            
            // Look for FICON (Field Condition) in remarks
            // Formats: FICON 5/5/5, MU45, BRAKING GOOD/FAIR/POOR/NIL
            const muMatch = metar.match(/\bMU(\d{2})/);
            if (muMatch) {
                const mu = parseInt(muMatch[1]);
                if (mu >= 40) result.brakingAction = 'GOOD';
                else if (mu >= 30) result.brakingAction = 'FAIR';
                else if (mu >= 20) result.brakingAction = 'POOR';
                else result.brakingAction = 'NIL';
            }
            
            const brakingMatch = metar.match(/BRAKING\s+(GOOD|FAIR|MEDIUM|POOR|NIL)/i);
            if (brakingMatch) {
                result.brakingAction = brakingMatch[1].toUpperCase();
            }
            
            // Look for FICON reports
            const ficonMatch = metar.match(/FICON[^A-Z].*?(?=\s{2}|$)/i);
            if (ficonMatch) {
                result.ficonReports.push(ficonMatch[0]);
            }
            
            return (result.brakingAction || result.ficonReports.length > 0) ? result : null;
        }

        // Calculate runway availability (simplified - braking action from METAR only)
        function getRunwayStatus(icao, metarRaw) {
            const totalRunways = RUNWAY_COUNT[icao] || 2;
            let brakingAction = null;
            
            // Check METAR for field conditions
            if (metarRaw) {
                const fieldCond = extractFieldConditions(metarRaw);
                if (fieldCond && fieldCond.brakingAction) {
                    brakingAction = fieldCond.brakingAction;
                }
            }
            
            let status = 'good';
            
            // Braking action affects status
            if (brakingAction === 'NIL') {
                status = 'critical';
            } else if (brakingAction === 'POOR') {
                status = 'limited';
            }
            
            return {
                available: totalRunways,
                total: totalRunways,
                status: status,
                brakingAction: brakingAction,
                closedRunways: []
            };
        }

        // Search and filter functions
        // Store searched airports that aren't in the top 100
        let searchedAirports = {};
        
        async function fetchSingleAirport(icao) {
            try {
                // Fetch METAR
                const metarUrl = `https://aviationweather.gov/api/data/metar?ids=${icao}&format=raw&hours=6`;
                const text = await tryFetch(metarUrl);
                const metars = text.trim().split('\n').filter(m => m.length > 10);
                
                if (metars.length === 0) return null;
                
                const parsed = metars.map(parseMetar).filter(p => p !== null);
                if (parsed.length === 0) return null;
                
                // Sort by time (newest first)
                parsed.sort((a, b) => (b.obs_time || 0) - (a.obs_time || 0));
                const history = parsed.slice(0, 6);
                const latest = history[0];
                const recentFrozen = checkRecentFrozen(history);
                
                // Also fetch TAF for this airport
                let tafResult = null;
                try {
                    const tafUrl = `https://aviationweather.gov/api/data/taf?ids=${icao}&format=raw`;
                    const tafText = await tryFetch(tafUrl, 0, 20);
                    if (tafText && tafText.length > 20) {
                        tafResult = parseSingleTaf(icao, tafText);
                    }
                } catch (e) {
                    console.log('TAF fetch failed for', icao, e.message);
                }
                
                return {
                    ...latest,
                    history: history,
                    trend: getTrend(history),
                    had_recent_frozen: recentFrozen.hadFrozen,
                    recent_frozen_types: recentFrozen.frozenTypes,
                    last_frozen_time: recentFrozen.lastFrozenTime,
                    hub_airlines: null,
                    rush_status: null,
                    traffic_programs: null,
                    taf: tafResult,
                    frost_risk: getFrostRisk(icao, latest.temp_c),
                    hot_estimate: estimateHoldoverTime(latest.temp_c, latest.weather, null),
                    runway_status: getRunwayStatus(icao, latest.raw),
                    isSearchResult: true
                };
            } catch (e) {
                console.log('Failed to fetch airport:', icao, e.message);
                return null;
            }
        }
        
        // Parse a single TAF (used for search results)
        function parseSingleTaf(icao, tafText) {
            const forecasts = [];
            
            // Look for frozen precip
            const frozenPattern = /\b(\+|-)?((SN)|(FZRA)|(FZDZ)|(PL)|(FZFG)|(GS)|(GR))\b/g;
            const matches = tafText.matchAll(frozenPattern);
            
            for (const match of matches) {
                const wx = match[0].replace(/^[+-]/, '');
                const beforeMatch = tafText.substring(0, match.index);
                const timeMatch = beforeMatch.match(/(FM\d{6}|TEMPO\s+\d{4}\/\d{4}|BECMG\s+\d{4}\/\d{4}|\d{4}\/\d{4})\s*[^\n]*$/);
                
                forecasts.push({
                    raw: timeMatch ? timeMatch[0].substring(0, 30) + ' ' + wx : wx,
                    wx: wx
                });
            }
            
            // Deduplicate
            const uniqueForecasts = [];
            const seen = new Set();
            for (const fc of forecasts) {
                if (!seen.has(fc.wx)) {
                    seen.add(fc.wx);
                    uniqueForecasts.push(fc);
                }
            }
            
            return {
                raw: tafText.substring(0, 500),
                frozenForecasts: uniqueForecasts
            };
        }
        
        // Debounce timer for search
        let filterTimeout = null;
        function debouncedFilter() {
            if (filterTimeout) clearTimeout(filterTimeout);
            filterTimeout = setTimeout(() => filterAirports(), 300);
        }
        
        async function filterAirports() {
            let searchInput = document.getElementById('searchInput').value.toUpperCase().trim();
            console.log('filterAirports called with:', searchInput);
            
            // Try to resolve IATA to ICAO
            const iataPattern = /^[A-Z]{3}$/;
            const icaoPattern = /^[A-Z]{4}$/;
            let resolvedICAO = null;
            
            if (iataPattern.test(searchInput)) {
                // 3-letter code - try to resolve as IATA
                resolvedICAO = resolveToICAO(searchInput);
                if (resolvedICAO) {
                    console.log(`Resolved IATA ${searchInput} to ICAO ${resolvedICAO}`);
                    searchInput = resolvedICAO;
                } else {
                    console.log(`Could not resolve IATA ${searchInput}, IATA_TO_ICAO has ${Object.keys(IATA_TO_ICAO).length} entries`);
                }
            }
            
            currentSearchTerm = searchInput;
            console.log('currentSearchTerm set to:', currentSearchTerm);
            
            // Check if this looks like an ICAO code not in our list
            if (icaoPattern.test(currentSearchTerm) && !AIRPORTS.includes(currentSearchTerm)) {
                console.log('Fetching non-top-100 airport:', currentSearchTerm);
                // Try to fetch this airport
                const searchStatus = document.getElementById('searchStatus');
                if (!searchStatus) {
                    const searchBox = document.querySelector('.search-box');
                    const statusDiv = document.createElement('div');
                    statusDiv.id = 'searchStatus';
                    statusDiv.style.cssText = 'font-size:11px;color:#4a90d9;margin-top:5px;text-align:center;';
                    searchBox.parentNode.insertBefore(statusDiv, searchBox.nextSibling);
                }
                
                const displayCode = resolvedICAO ? `${document.getElementById('searchInput').value.toUpperCase()} (${currentSearchTerm})` : currentSearchTerm;
                document.getElementById('searchStatus').textContent = `&#x1F50D; Searching for ${displayCode}...`;
                
                const airport = await fetchSingleAirport(currentSearchTerm);
                
                if (airport) {
                    searchedAirports[currentSearchTerm] = airport;
                    document.getElementById('searchStatus').textContent = `&#x2714; Found ${displayCode}`;
                    setTimeout(() => {
                        const el = document.getElementById('searchStatus');
                        if (el) el.textContent = '';
                    }, 3000);
                } else {
                    document.getElementById('searchStatus').textContent = `&#x2717; No data for ${displayCode}`;
                    setTimeout(() => {
                        const el = document.getElementById('searchStatus');
                        if (el) el.textContent = '';
                    }, 3000);
                }
            } else {
                console.log('Filtering top 110 airports for:', currentSearchTerm);
            }
            
            renderFilteredResults();
        }

        function clearSearch() {
            document.getElementById('searchInput').value = '';
            currentSearchTerm = '';
            searchedAirports = {};
            const searchStatus = document.getElementById('searchStatus');
            if (searchStatus) searchStatus.textContent = '';
            renderFilteredResults();
        }

        function setRegionFilter(region) {
            currentRegionFilter = region;
            
            // Update button states
            document.querySelectorAll('.filter-btn').forEach(btn => {
                btn.classList.remove('active');
                if (btn.dataset.region === region) btn.classList.add('active');
            });
            
            renderFilteredResults();
        }

        function airportMatchesFilter(icao) {
            // Check search term
            if (currentSearchTerm) {
                const name = getAirportName(icao);
                const info = getAirportInfo(icao);
                const iata = info?.iata || '';
                const city = info?.city || '';
                
                const searchUpper = currentSearchTerm.toUpperCase();
                if (!icao.includes(searchUpper) && 
                    !name.toUpperCase().includes(searchUpper) &&
                    !iata.toUpperCase().includes(searchUpper) &&
                    !city.toUpperCase().includes(searchUpper)) {
                    return false;
                }
            }
            
            // Check region filter
            if (currentRegionFilter !== 'all') {
                const regionAirports = AIRPORT_REGIONS[currentRegionFilter] || [];
                if (!regionAirports.includes(icao)) {
                    return false;
                }
            }
            
            return true;
        }

        let lastRenderData = null;

        function renderFilteredResults() {
            console.log('renderFilteredResults called');
            console.log('lastRenderData:', !!lastRenderData);
            console.log('searchedAirports count:', Object.keys(searchedAirports).length);
            console.log('currentSearchTerm:', currentSearchTerm);
            
            if (lastRenderData) {
                console.log('Calling renderResults with categories');
                renderResults(lastRenderData.categories, lastRenderData.total);
            } else if (Object.keys(searchedAirports).length > 0) {
                // No main data yet but we have search results - show them
                console.log('No main data, showing search results only');
                const content = document.getElementById('content');
                const searchedAirportsList = Object.values(searchedAirports);
                let html = buildSearchResultsHtml(searchedAirportsList);
                content.innerHTML = html || '<div class="status-msg info">Loading airport data...</div>';
            } else {
                console.log('No data to render');
            }
        }
        
        function buildSearchResultsHtml(searchedAirportsList) {
            if (!searchedAirportsList || searchedAirportsList.length === 0) return '';
            
            let html = `
                <div id="section-search" class="collapsible-section section-search">
                    <div class="section-header" onclick="toggleSection('section-search')" style="background:#1f3d2d;border:1px solid #3a8c5a;border-bottom:none;">
                        <h3 style="color:#3ce78c;">&#x1F50D; Search Results (${searchedAirportsList.length})</h3>
                        <span class="section-toggle">&#x25BC;</span>
                    </div>
                    <div class="section-content" style="background:#1a2d25;border:1px solid #3a8c5a;border-top:none;">
                        <div class="airport-list">
            `;
            
            for (const apt of searchedAirportsList) {
                const cat = categorize(apt);
                const catColors = { active: '#e74c3c', likely: '#f39c12', residual: '#9b59b6', possible: '#f1c40f', none: '#2ecc71', unknown: '#888' };
                const catLabels = { active: '&#x1F534; Active', likely: '&#x1F7E0; Likely', residual: '&#x1F7E3; Residual', possible: '&#x1F7E1; Possible', none: '&#x1F7E2; None', unknown: ' Unknown' };
                const catColor = catColors[cat] || '#888';
                const catLabel = catLabels[cat] || cat;
                
                const name = getAirportName(apt.icao);
                const airportInfo = getAirportInfo(apt.icao);
                const iataCode = airportInfo?.iata || '';
                const elevation = airportInfo?.elevation_ft ? `${airportInfo.elevation_ft}ft` : '';
                const wx = formatWeatherDisplay(apt);
                const frClass = `fr-${apt.flight_rules.toLowerCase()}`;
                const metarUrl = `https://aviationweather.gov/data/metar/?id=${apt.icao}&hours=6`;
                const timeSince = getTimeSince(apt.obs_time);
                const historyId = `history-search-${apt.icao}`;
                
                currentWindData[apt.icao] = {
                    direction: (apt.wind_variable || apt.wind_dir === 'VRB') ? null : apt.wind_dir,
                    speed: apt.wind_speed, gust: apt.wind_gust,
                    variable: apt.wind_variable || apt.wind_dir === 'VRB'
                };
                
                let windHtml = '';
                if (apt.wind_speed !== null) {
                    let windText = apt.wind_variable ? `VRB${apt.wind_speed}kt` : 
                        apt.wind_dir !== null ? `${String(apt.wind_dir).padStart(3, '0')}&deg;/${apt.wind_speed}kt` : `${apt.wind_speed}kt`;
                    if (apt.wind_gust) windText += `G${apt.wind_gust}`;
                    windHtml = `<span class="wind-info"> ${windText}</span>`;
                }
                
                const icaoDisplay = iataCode ? `${apt.icao}/${iataCode}` : apt.icao;
                
                html += `
                    <div class="airport-card" onclick="toggleHistory('${historyId}')" style="border-left:3px solid ${catColor};">
                        <div class="airport-main">
                            <div class="left">
                                <div class="icao" style="background:${catColor}22;">${icaoDisplay}</div>
                                <div>
                                    <div class="name">
                                        <a href="${metarUrl}" target="_blank" onclick="event.stopPropagation();">${name} </a>
                                        <button class="runway-map-btn" onclick="showRunwayMap('${apt.icao}', event)">&#x1F6EB; Map</button>
                                        <span style="margin-left:8px;font-size:10px;color:${catColor};">${catLabel}</span>
                                    </div>
                                    <div class="weather">${wx} <span class="flight-rules ${frClass}">${apt.flight_rules}</span> ${windHtml}</div>
                                    <div class="obs-time ${timeSince.stale ? 'stale' : ''}">${timeSince.zulu} &bull; ${timeSince.text}${elevation ? ` &bull; Elev: ${elevation}` : ''}</div>
                                    ${apt.taf && apt.taf.raw ? `
                                        <div class="taf-forecast" style="cursor:pointer;" onclick="toggleTafInline(document.getElementById('taf-bld-${apt.icao}')); event.stopPropagation();">
                                            &#x1F4CB; TAF: <span style="color:${apt.taf.frozenForecasts && apt.taf.frozenForecasts.length > 0 ? '#9b59b6' : '#4a90d9'};">${apt.taf.frozenForecasts && apt.taf.frozenForecasts.length > 0 ? apt.taf.frozenForecasts[0].wx : 'Available'}</span>
                                            <span style="color:#666;font-size:9px;margin-left:4px;">&#x25BC; expand</span>
                                        </div>
                                        <div class="taf-inline" id="taf-bld-${apt.icao}" onclick="toggleTafInline(this); event.stopPropagation();">${apt.taf.raw}</div>
                                    ` : ''}
                                </div>
                            </div>
                            <div class="right">
                                <div class="trend ${apt.trend.class}" title="${apt.trend.text}">${apt.trend.symbol}</div>
                                <div class="temp">
                                    <div class="temp-value">${tempToF(apt.temp_c)}&deg;F</div>
                                    <div class="temp-f">${apt.temp_c}&deg;C</div>
                                </div>
                            </div>
                        </div>
                        <div class="expand-hint">Tap to see history</div>
                    </div>
                `;
            }
            
            html += `</div></div></div>`;
            return html;
        }

        function tempToF(c) {
            return Math.round(c * 9/5 + 32);
        }

        function getTimeSince(obsTime) {
            if (!obsTime) return { text: 'N/A', stale: false, zulu: '' };
            const now = new Date();
            const diffMs = now - obsTime;
            const diffMins = Math.floor(diffMs / 60000);
            
            // Format Zulu time (e.g., "1852Z")
            const zuluTime = obsTime.getUTCHours().toString().padStart(2, '0') + 
                            obsTime.getUTCMinutes().toString().padStart(2, '0') + 'Z';
            
            if (diffMins < 60) {
                return { text: `${diffMins}m ago`, stale: diffMins > 90, zulu: zuluTime };
            } else {
                const hours = Math.floor(diffMins / 60);
                const mins = diffMins % 60;
                return { text: `${hours}h ${mins}m ago`, stale: hours >= 2, zulu: zuluTime };
            }
        }
        
        // Format time for history rows: "1852Z / 1:52 PM EST"
        function formatObsTime(obsTime) {
            if (!obsTime) return { zulu: 'N/A', local: '', combined: 'N/A' };
            
            const zuluTime = obsTime.getUTCHours().toString().padStart(2, '0') + 
                            obsTime.getUTCMinutes().toString().padStart(2, '0') + 'Z';
            const localTime = obsTime.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit', timeZoneName: 'short'});
            
            return {
                zulu: zuluTime,
                local: localTime,
                combined: `${zuluTime} / ${localTime}`
            };
        }

        function getTrend(history) {
            if (!history || history.length < 2) return { symbol: '&mdash;', class: 'steady', text: 'No trend data' };
            
            // Get temps from oldest to newest (history is newest first, so reverse)
            const temps = history.map(h => h.temp_c).filter(t => t !== null).reverse();
            if (temps.length < 2) return { symbol: '&mdash;', class: 'steady', text: 'No trend data' };
            
            const oldest = temps[0];
            const newest = temps[temps.length - 1];
            const diff = newest - oldest;
            
            if (diff >= 3) return { symbol: '&#x2191;', class: 'warming', text: `+${diff}&deg; over ${temps.length} obs` };
            if (diff <= -3) return { symbol: '', class: 'cooling', text: `${diff}&deg; over ${temps.length} obs` };
            return { symbol: '&#x2192;', class: 'steady', text: 'Steady' };
        }

        async function tryFetch(url, proxyIndex = 0, minLength = 10) {
            if (proxyIndex >= CORS_PROXIES.length) {
                console.warn('All fetch methods failed for:', url.substring(0, 60));
                return ''; // Return empty string instead of throwing
            }
            
            const proxyUrl = CORS_PROXIES[proxyIndex](url);
            
            try {
                const controller = new AbortController();
                const timeout = setTimeout(() => controller.abort(), 20000);
                
                const response = await fetch(proxyUrl, { 
                    signal: controller.signal,
                    headers: { 
                        'Accept': 'text/plain, application/json, */*',
                        'User-Agent': 'AirportDeicingMonitor/1.0'
                    }
                });
                clearTimeout(timeout);
                
                if (!response.ok) {
                    console.log(`Proxy ${proxyIndex} returned HTTP ${response.status} for ${url.substring(0,50)}`);
                    throw new Error(`HTTP ${response.status}`);
                }
                
                const text = await response.text();
                console.log(`Proxy ${proxyIndex} returned ${text.length} bytes for ${url.substring(0,50)}`);
                
                if (!text || text.length < minLength) {
                    throw new Error('Response too short: ' + text.length);
                }
                return text;
            } catch (e) {
                console.log(`Proxy ${proxyIndex} failed for ${url.substring(0,50)}:`, e.message);
                return tryFetch(url, proxyIndex + 1, minLength);
            }
        }

        async function fetchData() {
            const btn = document.getElementById('refreshBtn');
            const content = document.getElementById('content');
            
            btn.disabled = true;
            btn.textContent = 'Loading...';
            
            content.innerHTML = `
                <div class="loading">
                    <div class="spinner"></div>
                    <div>Fetching METAR and TAF data...</div>
                    <div id="loadingStatus" style="font-size: 11px; color: #666; margin-top: 10px;"></div>
                </div>
            `;
            
            const updateStatus = (msg) => {
                const el = document.getElementById('loadingStatus');
                if (el) el.innerHTML += msg + '<br>';
            };

            try {
                // Fetch all data sources in parallel
                const trafficPromise = fetchTrafficManagement();
                const advisoryPromise = fetchFAAAdvisory();
                const tafPromise = fetchTAFs();
                
                let metars = [];
                
                // Try fetching all airports at once first
                const ids = AIRPORTS.join(',');
                const baseUrl = `https://aviationweather.gov/api/data/metar?ids=${ids}&format=raw&hours=6`;
                
                let text = await tryFetch(baseUrl);
                // Match both US (KXXX) and Canadian (CYXX) airports
                metars = text.trim().split('\n').filter(m => m.length > 10 && m.match(/(?:K[A-Z]{3}|C[A-Z]{3})/));
                
                // If main request failed, try fetching in smaller batches
                if (metars.length === 0) {
                    console.log('Main METAR fetch failed, trying smaller batches...');
                    updateStatus('Trying alternative fetch method...');
                    
                    // Try just the top 25 airports
                    const top25 = AIRPORTS.slice(0, 25).join(',');
                    const fallbackUrl = `https://aviationweather.gov/api/data/metar?ids=${top25}&format=raw&hours=2`;
                    text = await tryFetch(fallbackUrl);
                    metars = text.trim().split('\n').filter(m => m.length > 10 && m.match(/(?:K[A-Z]{3}|C[A-Z]{3})/));
                }
                
                // If AWC failed, try UCAR as backup
                if (metars.length === 0) {
                    console.log('AWC METAR fetch failed, trying UCAR backup...');
                    updateStatus('Trying UCAR backup source...');
                    
                    // Try UCAR RAP real-time METAR
                    const ucarUrl = `https://rap.ucar.edu/weather/surface/`;
                    try {
                        text = await tryFetch(ucarUrl);
                        
                        if (text && text.length > 500) {
                            // Parse the HTML page for METAR data
                            const lines = text.split('\n');
                            for (const line of lines) {
                                // Look for METAR lines - they contain station IDs
                                for (const icao of AIRPORTS) {
                                    if (line.includes(icao) && line.match(/\d{6}Z/)) {
                                        // Extract the METAR portion
                                        const metarMatch = line.match(new RegExp(`(${icao}\\s+\\d{6}Z[^<]+)`));
                                        if (metarMatch) {
                                            metars.push(metarMatch[1].trim());
                                        }
                                    }
                                }
                            }
                            console.log('UCAR returned', metars.length, 'METARs');
                            if (metars.length > 0) {
                                updateStatus(`UCAR: ${metars.length} airports &#x2714;`);
                            }
                        }
                    } catch (e) {
                        console.log('UCAR fetch error:', e.message);
                    }
                }
                
                // If still no data, try NOAA direct (fetch top airports individually)
                if (metars.length === 0) {
                    console.log('UCAR failed, trying NOAA direct...');
                    updateStatus('Trying NOAA direct source...');
                    
                    const topAirports = AIRPORTS.slice(0, 20);
                    const noaaPromises = topAirports.map(async (icao) => {
                        try {
                            const noaaUrl = `https://tgftp.nws.noaa.gov/data/observations/metar/stations/${icao}.TXT`;
                            const response = await tryFetch(noaaUrl);
                            if (response && response.length > 20) {
                                // NOAA format has timestamp on first line, METAR on second
                                const lines = response.trim().split('\n');
                                if (lines.length >= 2) {
                                    return lines[1].trim();
                                }
                            }
                        } catch (e) {
                            // Individual station fetch failed
                        }
                        return null;
                    });
                    
                    const noaaResults = await Promise.all(noaaPromises);
                    metars = noaaResults.filter(m => m && m.length > 10);
                    
                    if (metars.length > 0) {
                        console.log('NOAA returned', metars.length, 'METARs');
                        updateStatus(`NOAA: ${metars.length} airports &#x2714;`);
                    }
                }
                
                if (metars.length === 0) {
                    throw new Error('All METAR sources unavailable. Please try again later.');
                }
                
                // Wait for all other data
                await Promise.all([trafficPromise, advisoryPromise, tafPromise]);
                
                // Parse all METARs
                const allParsed = metars.map(parseMetar).filter(p => p !== null);
                
                // Group by airport
                const byAirport = {};
                for (const p of allParsed) {
                    if (!byAirport[p.icao]) byAirport[p.icao] = [];
                    byAirport[p.icao].push(p);
                }
                
                // Sort each airport's METARs by time (newest first) and keep last 6
                for (const icao in byAirport) {
                    byAirport[icao].sort((a, b) => (b.obs_time || 0) - (a.obs_time || 0));
                    byAirport[icao] = byAirport[icao].slice(0, 6);
                }
                
                // Create airport objects with latest data and history
                const airportData = [];
                for (const icao of AIRPORTS) {
                    if (byAirport[icao] && byAirport[icao].length > 0) {
                        const history = byAirport[icao];
                        const latest = history[0];
                        const recentFrozen = checkRecentFrozen(history);
                        airportData.push({
                            ...latest,
                            history: history,
                            trend: getTrend(history),
                            had_recent_frozen: recentFrozen.hadFrozen,
                            recent_frozen_types: recentFrozen.frozenTypes,
                            last_frozen_time: recentFrozen.lastFrozenTime,
                            // New indicators
                            hub_airlines: getHubInfo(icao),
                            rush_status: getRushStatus(icao),
                            traffic_programs: trafficPrograms[icao] || null,
                            // TAF data
                            taf: tafData[icao] || null,
                            frost_risk: getFrostRisk(icao, latest.temp_c),
                            // HOT estimate
                            hot_estimate: estimateHoldoverTime(latest.temp_c, latest.weather, null),
                            // Runway status (pass raw METAR for braking extraction)
                            runway_status: getRunwayStatus(icao, latest.raw)
                        });
                    }
                }
                
                // Categorize
                const categories = { active: [], likely: [], residual: [], possible: [], marginal: [], none: [] };
                for (const apt of airportData) {
                    const cat = categorize(apt);
                    if (categories[cat]) categories[cat].push(apt);
                }

                // Sort by airport rank (busiest first)
                for (const cat in categories) {
                    categories[cat].sort((a, b) => {
                        const rankA = AIRPORTS.indexOf(a.icao);
                        const rankB = AIRPORTS.indexOf(b.icao);
                        return rankA - rankB;
                    });
                }

                renderResults(categories, airportData.length);
                
                const now = new Date();
                document.getElementById('timestamp').textContent = 
                    `Updated: ${now.toLocaleTimeString()} | ${airportData.length} airports reporting`;

            } catch (error) {
                console.error('FetchData error:', error);
                content.innerHTML = `
                    <div class="error">
                        <strong>Unable to load data</strong><br><br>
                        ${error.message}<br><br>
                        <small>This can happen due to:</small>
                        <ul style="text-align: left; margin: 10px 0;">
                            <li>CORS proxy services being temporarily unavailable</li>
                            <li>Aviation Weather Center API issues</li>
                            <li>Network connectivity problems</li>
                            <li>Browser security settings blocking requests</li>
                        </ul>
                        <small>Check browser console (F12) for details.</small>
                        <br>
                        <button onclick="fetchData()">Try Again</button>
                    </div>
                `;
            }

            btn.disabled = false;
            btn.textContent = ' Refresh';
        }

        function renderResults(categories, total) {
            // Store data for filtering
            lastRenderData = { categories, total };
            
            const content = document.getElementById('content');
            
            // Apply filters to categories
            const filteredCategories = {
                active: categories.active.filter(a => airportMatchesFilter(a.icao)),
                residual: categories.residual.filter(a => airportMatchesFilter(a.icao)),
                likely: categories.likely.filter(a => airportMatchesFilter(a.icao)),
                possible: categories.possible.filter(a => airportMatchesFilter(a.icao)),
                marginal: categories.marginal.filter(a => airportMatchesFilter(a.icao)),
                none: categories.none.filter(a => airportMatchesFilter(a.icao))
            };
            
            // Calculate counts for dashboard cards
            const affectedAirportsForCount = Object.keys(trafficPrograms).filter(icao => airportMatchesFilter(icao));
            let atcCount = 0;
            for (const icao of affectedAirportsForCount) {
                const programs = trafficPrograms[icao];
                for (const prog of programs) {
                    if (prog.type !== 'CLOSED' && prog.type !== 'DEICING') atcCount++;
                }
            }
            
            const deicingProgCount = Object.keys(trafficPrograms)
                .filter(icao => airportMatchesFilter(icao) && 
                    trafficPrograms[icao].some(p => p.type === 'DEICING')).length;
            
            const closureCount = Object.keys(faaAdvisoryData.runwayClosures)
                .filter(icao => airportMatchesFilter(icao)).length;
            
            const plannedCount = Object.keys(faaAdvisoryData.terminalPlanned)
                .filter(icao => airportMatchesFilter(icao)).length;
            
            // Count TAF warnings
            let tafCount = 0;
            for (const icao of Object.keys(tafData)) {
                if (!airportMatchesFilter(icao)) continue;
                const taf = tafData[icao];
                if (taf && taf.frozenForecasts && taf.frozenForecasts.length > 0) tafCount++;
            }
            
            // Count frost risk airports
            const allAirportsForFrost = [
                ...filteredCategories.active,
                ...filteredCategories.residual,
                ...filteredCategories.likely,
                ...filteredCategories.possible,
                ...filteredCategories.marginal,
                ...filteredCategories.none
            ];
            const frostCount = allAirportsForFrost.filter(apt => apt.frost_risk).length;
            
            // Count runway alerts
            let runwayAlertCount = 0;
            for (const apt of allAirportsForFrost) {
                const status = apt.runway_status;
                if (status && (status.status === 'critical' || status.brakingAction === 'NIL' || status.brakingAction === 'POOR')) {
                    runwayAlertCount++;
                }
            }
            
            // Update dashboard cards
            updateDashboardCard('active', filteredCategories.active.length);
            updateDashboardCard('residual', filteredCategories.residual.length);
            updateDashboardCard('likely', filteredCategories.likely.length);
            updateDashboardCard('possible', filteredCategories.possible.length);
            updateDashboardCard('atc', atcCount);
            updateDashboardCard('deicing-prog', deicingProgCount);
            updateDashboardCard('runway', runwayAlertCount);
            updateDashboardCard('taf', tafCount);
            updateDashboardCard('frost', frostCount);
            updateDashboardCard('closure', closureCount);
            updateDashboardCard('planned', plannedCount);
            updateDashboardCard('none', filteredCategories.none.length);
            
            // Traffic management summary
            let trafficHtml = '';
            const affectedAirports = Object.keys(trafficPrograms).filter(icao => airportMatchesFilter(icao));
            if (affectedAirports.length > 0) {
                let trafficItems = '';
                let validItemCount = 0;
                for (const icao of affectedAirports) {
                    const programs = trafficPrograms[icao];
                    const name = AIRPORT_NAMES[icao] || icao;
                    for (const prog of programs) {
                        // Skip CLOSED - we only want GDP, GS, AFP, and delays
                        if (prog.type === 'CLOSED') continue;
                        
                        let details = '';
                        // Try to get end time from FAA Advisory
                        const advisoryInfo = faaAdvisoryData.terminalActive[icao];
                        if (prog.type === 'GDP') {
                            if (advisoryInfo && advisoryInfo.length > 0) {
                                details = `Until: ${advisoryInfo[0].endTime}Z (Avg: ${prog.avgDelay})`;
                            } else {
                                details = `Avg delay: ${prog.avgDelay}`;
                            }
                        } else if (prog.type === 'GROUND STOP') {
                            details = `Until: ${prog.endTime}`;
                        } else if (prog.type === 'ARR DELAY' || prog.type === 'DEP DELAY') {
                            details = `${prog.minDelay}-${prog.maxDelay}`;
                        } else if (prog.type === 'DEICING') {
                            details = prog.startTime ? `Started: ${prog.startTime}` : 'Active';
                        }
                        // Format display type for better readability
                        let displayType = prog.type;
                        if (prog.type === 'ARR DELAY') displayType = 'ARRIVAL DELAY';
                        if (prog.type === 'DEP DELAY') displayType = 'DEPARTURE DELAY';
                        // Add constraint reason from FAA Advisory if available
                        const constraint = faaAdvisoryData.terminalConstraints[icao];
                        const reasonText = constraint ? constraint : prog.reason;
                        trafficItems += `
                            <div class="traffic-item">
                                <span class="airport">${icao}</span> ${name} - 
                                <span class="program">${displayType}</span> ${details}
                                <div class="reason">${reasonText}</div>
                            </div>
                        `;
                        validItemCount++;
                    }
                }
                // Only show section if we have valid items (not just closures)
                if (validItemCount > 0) {
                    trafficHtml = `
                        <div id="section-traffic" class="collapsible-section section-traffic ${getSectionClass('section-traffic')}">
                            <div class="section-header" onclick="toggleSection('section-traffic')">
                                <h3>&#x1F6EB; ATC: GDP / GS / AFP (${validItemCount})</h3>
                                <span class="section-toggle">${getSectionToggle('section-traffic')}</span>
                            </div>
                            <div class="section-content ${getSectionContentClass('section-traffic')}">
                                ${trafficItems}
                            </div>
                        </div>
                    `;
                }
            }
            
            // Deicing Programs section - highlight airports with formal deicing
            const deicingAirports = Object.keys(trafficPrograms)
                .filter(icao => airportMatchesFilter(icao) && 
                    trafficPrograms[icao].some(p => p.type === 'DEICING'))
                .sort((a, b) => AIRPORTS.indexOf(a) - AIRPORTS.indexOf(b));
            if (deicingAirports.length > 0) {
                let deicingItems = '';
                for (const icao of deicingAirports) {
                    const name = AIRPORT_NAMES[icao] || icao;
                    const deicingProg = trafficPrograms[icao].find(p => p.type === 'DEICING');
                    const startTime = deicingProg.startTime ? `Started: ${deicingProg.startTime}` : '';
                    deicingItems += `
                        <div class="deicing-item">
                            <span class="airport">${icao}</span> ${name} ${startTime}
                        </div>
                    `;
                }
                trafficHtml += `
                    <div id="section-deicing" class="collapsible-section section-deicing ${getSectionClass('section-deicing')}">
                        <div class="section-header" onclick="toggleSection('section-deicing')">
                            <h3> Active Deicing Programs (${deicingAirports.length})</h3>
                            <span class="section-toggle">${getSectionToggle('section-deicing')}</span>
                        </div>
                        <div class="section-content ${getSectionContentClass('section-deicing')}">
                            ${deicingItems}
                        </div>
                    </div>
                `;
            }
            
            // FAA Advisory - Planned/Possible ground stops
            const plannedAirports = Object.keys(faaAdvisoryData.terminalPlanned)
                .filter(icao => airportMatchesFilter(icao))
                .sort((a, b) => AIRPORTS.indexOf(a) - AIRPORTS.indexOf(b));
            if (plannedAirports.length > 0) {
                let plannedItems = '';
                for (const icao of plannedAirports) {
                    const name = AIRPORT_NAMES[icao] || icao;
                    const programs = faaAdvisoryData.terminalPlanned[icao];
                    for (const prog of programs) {
                        plannedItems += `
                            <div class="planned-item">
                                <span class="airport">${icao}</span> ${name} - ${prog}
                            </div>
                        `;
                    }
                }
                trafficHtml += `
                    <div id="section-planned" class="collapsible-section section-planned ${getSectionClass('section-planned')}">
                        <div class="section-header" onclick="toggleSection('section-planned')">
                            <h3> Possible Ground Stops (${plannedAirports.length})</h3>
                            <span class="section-toggle">${getSectionToggle('section-planned')}</span>
                        </div>
                        <div class="section-content ${getSectionContentClass('section-planned')}">
                            ${plannedItems}
                        </div>
                    </div>
                `;
            }
            
            // FAA Advisory - Runway/Taxiway closures
            const closureAirports = Object.keys(faaAdvisoryData.runwayClosures)
                .filter(icao => airportMatchesFilter(icao))
                .sort((a, b) => AIRPORTS.indexOf(a) - AIRPORTS.indexOf(b));
            if (closureAirports.length > 0) {
                let closureItems = '';
                for (const icao of closureAirports) {
                    const name = AIRPORT_NAMES[icao] || icao;
                    const closures = faaAdvisoryData.runwayClosures[icao];
                    for (const closure of closures) {
                        closureItems += `
                            <div class="closure-item">
                                <span class="airport">${icao}</span> ${name} - ${closure}
                            </div>
                        `;
                    }
                }
                trafficHtml += `
                    <div id="section-closure" class="collapsible-section section-closure ${getSectionClass('section-closure')}">
                        <div class="section-header" onclick="toggleSection('section-closure')">
                            <h3>&#x1F6A7; Runway/Taxiway Closures (${closureAirports.length})</h3>
                            <span class="section-toggle">${getSectionToggle('section-closure')}</span>
                        </div>
                        <div class="section-content ${getSectionContentClass('section-closure')}">
                            ${closureItems}
                        </div>
                    </div>
                `;
            }
            
            // Runway/NOTAM alerts for critical situations
            let runwayAlertHtml = '';
            const criticalRunways = [];
            
            // Collect all airports from all categories
            const allAirports = [
                ...filteredCategories.active,
                ...filteredCategories.residual,
                ...filteredCategories.likely,
                ...filteredCategories.possible,
                ...filteredCategories.marginal,
                ...filteredCategories.none
            ];
            
            for (const apt of allAirports) {
                const status = apt.runway_status;
                if (status && (status.status === 'critical' || status.brakingAction === 'NIL' || status.brakingAction === 'POOR')) {
                    criticalRunways.push({ icao: apt.icao, ...status });
                }
            }
            
            // Sort by airport rank (busiest first)
            criticalRunways.sort((a, b) => AIRPORTS.indexOf(a.icao) - AIRPORTS.indexOf(b.icao));
            
            if (criticalRunways.length > 0) {
                let runwayItems = '';
                for (const rwy of criticalRunways) {
                    const name = AIRPORT_NAMES[rwy.icao] || rwy.icao;
                    let alertMsg = '';
                    if (rwy.message === 'AIRPORT CLOSED') {
                        alertMsg = '<span style="color: #e74c3c;">AIRPORT CLOSED</span>';
                    } else if (rwy.available === 0) {
                        alertMsg = '<span style="color: #e74c3c;">NO RUNWAYS AVAILABLE</span>';
                    } else {
                        alertMsg = `${rwy.available}/${rwy.total} runways open`;
                    }
                    
                    let brakingHtml = '';
                    if (rwy.brakingAction) {
                        const brakingClass = rwy.brakingAction === 'GOOD' ? 'braking-good' : 
                                            rwy.brakingAction === 'MEDIUM' || rwy.brakingAction === 'FAIR' ? 'braking-fair' :
                                            rwy.brakingAction === 'POOR' ? 'braking-poor' : 'braking-nil';
                        brakingHtml = `<span class="braking-action ${brakingClass}">${rwy.brakingAction}</span>`;
                    }
                    
                    runwayItems += `
                        <div class="notam-item">
                            <span class="airport" style="color: #f39c12;">${rwy.icao}</span> ${name} - ${alertMsg} ${brakingHtml}
                            ${rwy.closedRunways.length > 0 ? `<div style="color: #888; font-size: 10px;">Closed: ${rwy.closedRunways.join(', ')}</div>` : ''}
                        </div>
                    `;
                }
                runwayAlertHtml = `
                    <div id="section-runway" class="collapsible-section section-runway ${getSectionClass('section-runway')}">
                        <div class="section-header" onclick="toggleSection('section-runway')">
                            <h3>&#x1F6EC; Runway/Braking Alerts (${criticalRunways.length})</h3>
                            <span class="section-toggle">${getSectionToggle('section-runway')}</span>
                        </div>
                        <div class="section-content ${getSectionContentClass('section-runway')}">
                            ${runwayItems}
                        </div>
                    </div>
                `;
            }
            
            // TAF Forecasts with frozen precip
            let tafHtml = '';
            const tafWarnings = [];
            for (const icao of AIRPORTS) {
                if (!airportMatchesFilter(icao)) continue;
                const taf = tafData[icao];
                if (taf && taf.frozenForecasts && taf.frozenForecasts.length > 0) {
                    const name = AIRPORT_NAMES[icao] || icao;
                    for (const fc of taf.frozenForecasts.slice(0, 1)) {
                        tafWarnings.push({
                            icao: icao,
                            name: name,
                            wx: fc.wx,
                            raw: fc.raw,
                            fullTaf: taf.raw || ''
                        });
                    }
                }
            }
            
            if (tafWarnings.length > 0) {
                const initialShow = 10;
                const hasMore = tafWarnings.length > initialShow;
                
                let tafItems = '';
                // First 10 always visible
                for (let i = 0; i < Math.min(tafWarnings.length, initialShow); i++) {
                    const warn = tafWarnings[i];
                    const tafId = `taf-full-${warn.icao}`;
                    tafItems += `
                        <div class="forecast-note" onclick="toggleTafFull('${tafId}')">
                            <span class="airport">${warn.icao}</span> ${warn.name} - 
                            <span style="color: #9b59b6;">${warn.wx}</span>
                            <span class="taf-expand-icon">&#x25BC; TAF</span>
                            <div class="taf-full" id="${tafId}">${warn.fullTaf}</div>
                        </div>
                    `;
                }
                
                // Remaining airports in expandable section
                if (hasMore) {
                    tafItems += `<div id="tafExpandedList" style="display: none;">`;
                    for (let i = initialShow; i < tafWarnings.length; i++) {
                        const warn = tafWarnings[i];
                        const tafId = `taf-full-${warn.icao}`;
                        tafItems += `
                            <div class="forecast-note" onclick="toggleTafFull('${tafId}')">
                                <span class="airport">${warn.icao}</span> ${warn.name} - 
                                <span style="color: #9b59b6;">${warn.wx}</span>
                                <span class="taf-expand-icon">&#x25BC; TAF</span>
                                <div class="taf-full" id="${tafId}">${warn.fullTaf}</div>
                            </div>
                        `;
                    }
                    tafItems += '</div>';
                    tafItems += `<div style="text-align: center; margin-top: 8px;">
                        <span id="tafToggleIcon" onclick="toggleTafList(); event.stopPropagation();" style="cursor: pointer; color: #4a90d9; font-size: 12px;"> Show all ${tafWarnings.length - initialShow} more</span>
                    </div>`;
                }
                
                tafHtml = `
                    <div id="section-taf" class="collapsible-section section-taf ${getSectionClass('section-taf')}">
                        <div class="section-header" onclick="toggleSection('section-taf')">
                            <h3>&#x1F4CB; TAF: Frozen Precip Forecast (${tafWarnings.length})</h3>
                            <span class="section-toggle">${getSectionToggle('section-taf')}</span>
                        </div>
                        <div class="section-content ${getSectionContentClass('section-taf')}">
                            ${tafItems}
                        </div>
                    </div>
                `;
            }
            
            // Frost Risk section - airports with frost conditions (cold + night/early morning)
            let frostHtml = '';
            const frostAirports = [];
            
            // Reuse allAirportsForFrost from dashboard calculations
            for (const apt of allAirportsForFrost) {
                if (apt.frost_risk) {
                    const name = AIRPORT_NAMES[apt.icao] || apt.icao;
                    const localTime = getLocalTime(apt.icao);
                    const localTimeStr = localTime ? localTime.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'}) : '';
                    frostAirports.push({
                        icao: apt.icao,
                        name: name,
                        temp_c: apt.temp_c,
                        temp_f: tempToF(apt.temp_c),
                        localTime: localTimeStr,
                        dewpoint: apt.dewpoint_c
                    });
                }
            }
            
            // Sort by airport rank (busiest first)
            frostAirports.sort((a, b) => AIRPORTS.indexOf(a.icao) - AIRPORTS.indexOf(b.icao));
            
            if (frostAirports.length > 0) {
                let frostItems = '';
                for (const frost of frostAirports) {
                    const dewSpread = frost.dewpoint !== null ? `Dew spread: ${frost.temp_c - frost.dewpoint}&deg;C` : '';
                    frostItems += `
                        <div class="forecast-note" style="border-color: #2980b9;">
                            <span class="airport">${frost.icao}</span> ${frost.name} - 
                            <span style="color: #3498db;">${frost.temp_f}&deg;F (${frost.temp_c}&deg;C)</span>
                            <span style="color: #888; font-size: 10px; margin-left: 8px;">Local: ${frost.localTime}</span>
                            ${dewSpread ? `<span style="color: #666; font-size: 10px; margin-left: 8px;">${dewSpread}</span>` : ''}
                        </div>
                    `;
                }
                
                frostHtml = `
                    <div id="section-frost" class="collapsible-section section-frost ${getSectionClass('section-frost')}">
                        <div class="section-header" onclick="toggleSection('section-frost')" style="background:#1f2d3d;border:1px solid #2980b9;border-bottom:none;">
                            <h3 style="color:#3498db;">&#x1F319; Frost Risk (${frostAirports.length})</h3>
                            <span class="section-toggle">${getSectionToggle('section-frost')}</span>
                        </div>
                        <div class="section-content ${getSectionContentClass('section-frost')}" style="background:#152535;border:1px solid #2980b9;border-top:none;">
                            <div style="font-size:10px;color:#666;margin-bottom:8px;">Airports below 4&deg;C during night hours (10pm-9am local) - potential for frost/ice formation</div>
                            ${frostItems}
                        </div>
                    </div>
                `;
            }
            
            // Search results section - show ALL matching airports when searching
            let searchResultsHtml = '';
            
            // When there's a search term, combine all matching airports from all categories
            if (currentSearchTerm) {
                // Combine all filtered categories into one list for search display
                const allMatchingAirports = [
                    ...filteredCategories.active,
                    ...filteredCategories.residual,
                    ...filteredCategories.likely,
                    ...filteredCategories.possible,
                    ...filteredCategories.marginal,
                    ...filteredCategories.none,
                    ...Object.values(searchedAirports) // Include non-top-100 searched airports
                ];
                
                if (allMatchingAirports.length > 0) {
                    searchResultsHtml = `
                        <div id="section-search" class="collapsible-section section-search ${getSectionClass('section-search')}">
                            <div class="section-header" onclick="toggleSection('section-search')" style="background:#1f3d2d;border:1px solid #3a8c5a;border-bottom:none;">
                                <h3 style="color:#3ce78c;">&#x1F50D; Search Results (${allMatchingAirports.length})</h3>
                                <span class="section-toggle">${getSectionToggle('section-search')}</span>
                            </div>
                            <div class="section-content ${getSectionContentClass('section-search')}" style="background:#1a2d25;border:1px solid #3a8c5a;border-top:none;">
                                <div class="airport-list">
                    `;
                    
                    for (const apt of allMatchingAirports) {
                        const cat = categorize(apt);
                        const catColors = {
                            active: '#e74c3c',
                            likely: '#f39c12', 
                            residual: '#9b59b6',
                            possible: '#f1c40f',
                            marginal: '#f39c12',
                            none: '#2ecc71',
                            unknown: '#888'
                        };
                        const catLabels = {
                            active: '&#x1F534; Active',
                            likely: '&#x1F7E0; Likely',
                            residual: '&#x1F7E3; Residual', 
                            possible: '&#x1F7E1; Possible',
                            marginal: '&#x1F7E0; Marginal',
                            none: '&#x1F7E2; None',
                            unknown: ' Unknown'
                        };
                        const catColor = catColors[cat] || '#888';
                        const catLabel = catLabels[cat] || cat;
                        
                        const name = getAirportName(apt.icao);
                        const airportInfo = getAirportInfo(apt.icao);
                        const iataCode = airportInfo?.iata || '';
                        const elevation = airportInfo?.elevation_ft ? `${airportInfo.elevation_ft}ft` : '';
                        const wx = formatWeatherDisplay(apt);
                        const frClass = `fr-${apt.flight_rules.toLowerCase()}`;
                        const metarUrl = `https://aviationweather.gov/data/metar/?id=${apt.icao}&hours=6`;
                        const timeSince = getTimeSince(apt.obs_time);
                        const historyId = `history-search-${apt.icao}`;
                        
                        // Store wind data for runway map
                        currentWindData[apt.icao] = {
                            direction: (apt.wind_variable || apt.wind_dir === 'VRB') ? null : apt.wind_dir,
                            speed: apt.wind_speed,
                            gust: apt.wind_gust,
                            variable: apt.wind_variable || apt.wind_dir === 'VRB'
                        };
                        
                        let windHtml = '';
                        if (apt.wind_speed !== null) {
                            let windText = apt.wind_variable ? `VRB${apt.wind_speed}kt` : 
                                apt.wind_dir !== null ? `${String(apt.wind_dir).padStart(3, '0')}&deg;/${apt.wind_speed}kt` : `${apt.wind_speed}kt`;
                            if (apt.wind_gust) windText += `G${apt.wind_gust}`;
                            windHtml = `<span class="wind-info"> ${windText}</span>`;
                        }
                        
                        let historyHtml = '';
                        if (apt.history && apt.history.length > 0) {
                            historyHtml = `<div class="history" id="${historyId}"><div class="history-title">Last ${apt.history.length} observations</div>`;
                            historyHtml += `<div class="history-header"><span class="time">Time (Z/Local)</span><span class="ceiling">Ceil</span><span class="wx">Weather</span><span class="wind">Wind</span><span class="temp">Temp</span></div>`;
                            for (const h of apt.history) {
                                const hTimeData = formatObsTime(h.obs_time);
                                const hTime = hTimeData.combined;
                                const hCeiling = h.ceiling_text || '&mdash;';
                                const hWx = formatHistoryWeather(h);
                                const hWind = h.wind_speed !== null ? 
                                    (h.wind_variable ? `VRB${h.wind_speed}` : `${h.wind_speed}kt`) + (h.wind_gust ? `G${h.wind_gust}` : '') : '&mdash;';
                                const hTemp = h.temp_c !== null ? `${tempToF(h.temp_c)}&deg;F/${h.temp_c}&deg;C` : 'N/A';
                                historyHtml += `<div class="history-row"><span class="time">${hTime}</span><span class="ceiling">${hCeiling}</span><span class="wx">${hWx}</span><span class="wind">${hWind}</span><span class="temp">${hTemp}</span></div>`;
                            }
                            historyHtml += '</div>';
                        }
                        
                        const icaoDisplay = iataCode ? `${apt.icao}/${iataCode}` : apt.icao;
                        
                        searchResultsHtml += `
                            <div class="airport-card" onclick="toggleHistory('${historyId}')" style="border-left:3px solid ${catColor};">
                                <div class="airport-main">
                                    <div class="left">
                                        <div class="icao" style="background:${catColor}22;">${icaoDisplay}</div>
                                        <div>
                                            <div class="name">
                                                <a href="${metarUrl}" target="_blank" onclick="event.stopPropagation();" title="View METARs">${name} </a>
                                                <button class="runway-map-btn" onclick="showRunwayMap('${apt.icao}')" title="View Runway Map">&#x1F6EB; Map</button>
                                            </div>
                                            <div class="weather">${wx} <span class="flight-rules ${frClass}">${apt.flight_rules}</span> ${windHtml}</div>
                                            <div class="obs-time ${timeSince.stale ? 'stale' : ''}">${timeSince.zulu} &bull; ${timeSince.text}</div>
                                            <div style="margin-top:4px;"><span style="color:${catColor};font-size:11px;font-weight:bold;">${catLabel}</span></div>
                                            ${apt.taf && apt.taf.raw ? `
                                                <div class="taf-forecast" style="cursor:pointer;" onclick="toggleTafInline(document.getElementById('taf-search-${apt.icao}')); event.stopPropagation();">
                                                    &#x1F4CB; TAF: <span style="color:${apt.taf.frozenForecasts && apt.taf.frozenForecasts.length > 0 ? '#9b59b6' : '#4a90d9'};">${apt.taf.frozenForecasts && apt.taf.frozenForecasts.length > 0 ? apt.taf.frozenForecasts[0].wx : 'Available'}</span>
                                                    <span style="color:#666;font-size:9px;margin-left:4px;">&#x25BC; expand</span>
                                                </div>
                                                <div class="taf-inline" id="taf-search-${apt.icao}" onclick="toggleTafInline(this); event.stopPropagation();">${apt.taf.raw}</div>
                                            ` : ''}
                                        </div>
                                    </div>
                                    <div class="right">
                                        <div class="trend ${apt.trend?.class || 'steady'}" title="${apt.trend?.text || ''}">${apt.trend?.symbol || '&#x2192;'}</div>
                                        <div class="temp">
                                            <div class="temp-value">${apt.temp_c !== null ? tempToF(apt.temp_c) + '&deg;F' : 'N/A'}</div>
                                            <div class="temp-f">${apt.temp_c !== null ? apt.temp_c + '&deg;C' : ''}</div>
                                        </div>
                                    </div>
                                </div>
                                <div class="expand-hint">Tap to see history</div>
                                ${historyHtml}
                            </div>
                        `;
                    }
                    
                    searchResultsHtml += `
                                </div>
                            </div>
                        </div>
                    `;
                }
            } else {
                // No search term - show non-top-100 searched airports if any (shouldn't happen normally)
                const searchedAirportsList = Object.values(searchedAirports);
                if (searchedAirportsList.length > 0) {
                    searchResultsHtml = buildSearchResultsHtml(searchedAirportsList);
                }
            }
            
            // When searching, show simplified view with just search results
            if (currentSearchTerm) {
                let html = searchResultsHtml;
                
                if (html === '') {
                    html = `<div class="status-msg info">No airports found matching "${currentSearchTerm}"</div>`;
                }
                
                // Data status summary
                const advActive = Object.keys(faaAdvisoryData.terminalActive).length;
                const advClosures = Object.keys(faaAdvisoryData.runwayClosures).length;
                
                html += `
                    <div style="background: #1a1a2e; border: 1px solid #333; border-radius: 8px; padding: 10px; margin-top: 20px; font-size: 11px; color: #666;">
                        <strong style="color: #888;">Data Status:</strong>
                        <span style="margin-left: 10px;">TAFs: ${Object.keys(tafData).length}</span>
                        <span style="margin-left: 10px;">ATCSCC: ${advActive > 0 || advClosures > 0 ? `${advActive} active, ${advClosures} rwys` : ''}</span>
                    </div>
                `;
                
                content.innerHTML = html;
                return; // Exit early - don't show normal view when searching
            }
            
            let html = trafficHtml + runwayAlertHtml + tafHtml + frostHtml;


            if (filteredCategories.active.length > 0) {
                html += renderSection('&#x1F534; Active Deicing', filteredCategories.active, 'section-active');
            }
            if (filteredCategories.residual.length > 0) {
                html += renderSection('&#x1F7E3; Residual (Recent Frozen Precip)', filteredCategories.residual, 'section-residual');
            }
            if (filteredCategories.likely.length > 0) {
                html += renderSection('&#x1F7E0; Likely Deicing', filteredCategories.likely, 'section-likely');
            }
            if (filteredCategories.possible.length > 0) {
                html += renderSection('&#x1F7E1; Possible (Below Freezing)', filteredCategories.possible, 'section-possible');
            }
            
            // Add Clear section (collapsed by default) for airports without deicing conditions
            if (filteredCategories.none.length > 0) {
                html += renderSection('&#x1F7E2; Clear (No Deicing)', filteredCategories.none, 'section-none');
            }

            if (filteredCategories.active.length === 0 && filteredCategories.likely.length === 0 && filteredCategories.residual.length === 0 && filteredCategories.possible.length === 0) {
                if (currentSearchTerm || currentRegionFilter !== 'all') {
                    html += `<div class="status-msg info">No matching airports with deicing conditions</div>`;
                } else {
                    html += `<div class="status-msg info">&#x2705; No airports currently reporting deicing conditions</div>`;
                }
            }
            
            // Data status summary
            const advActive = Object.keys(faaAdvisoryData.terminalActive).length;
            const advClosures = Object.keys(faaAdvisoryData.runwayClosures).length;
            
            html += `
                <div style="background: #1a1a2e; border: 1px solid #333; border-radius: 8px; padding: 10px; margin-top: 20px; font-size: 11px; color: #666;">
                    <strong style="color: #888;">Data Status:</strong>
                    <span style="margin-left: 10px;">TAFs: ${Object.keys(tafData).length}</span>
                    <span style="margin-left: 10px;">ATCSCC: ${advActive > 0 || advClosures > 0 ? `${advActive} active, ${advClosures} rwys` : ''}</span>
                </div>
            `;

            content.innerHTML = html;
        }

        // Collapsible section state management
        const sectionState = JSON.parse(localStorage.getItem('deicingMonitorSections') || '{}');
        
        function toggleSection(sectionId) {
            const section = document.getElementById(sectionId);
            if (!section) return;
            const content = section.querySelector('.section-content');
            const toggle = section.querySelector('.section-toggle');
            
            if (section.classList.contains('collapsed')) {
                section.classList.remove('collapsed');
                if (content) content.classList.remove('collapsed');
                if (toggle) toggle.textContent = '&#x25BC;';
                sectionState[sectionId] = 'expanded';
            } else {
                section.classList.add('collapsed');
                if (content) content.classList.add('collapsed');
                if (toggle) toggle.textContent = '&#x25B6;';
                sectionState[sectionId] = 'collapsed';
            }
            
            localStorage.setItem('deicingMonitorSections', JSON.stringify(sectionState));
        }
        
        function getSectionClass(sectionId) {
            // Default to collapsed unless explicitly expanded
            return sectionState[sectionId] === 'expanded' ? '' : 'collapsed';
        }
        
        function getSectionToggle(sectionId) {
            // Default to collapsed unless explicitly expanded
            return sectionState[sectionId] === 'expanded' ? '&#x25BC;' : '&#x25B6;';
        }
        
        function getSectionContentClass(sectionId) {
            // Default to collapsed unless explicitly expanded
            return sectionState[sectionId] === 'expanded' ? '' : 'collapsed';
        }
        
        function expandAllSections() {
            const sections = ['section-traffic', 'section-deicing', 'section-planned', 
                             'section-closure', 'section-runway', 'section-infogrid', 'section-taf', 'section-frost',
                             'section-active', 'section-residual', 'section-likely', 'section-possible', 'section-none'];
            for (const sectionId of sections) {
                const section = document.getElementById(sectionId);
                if (section) {
                    section.classList.remove('collapsed');
                    const content = section.querySelector('.section-content');
                    const toggle = section.querySelector('.section-toggle');
                    if (content) content.classList.remove('collapsed');
                    if (toggle) toggle.textContent = '&#x25BC;';
                    sectionState[sectionId] = 'expanded';
                }
            }
            localStorage.setItem('deicingMonitorSections', JSON.stringify(sectionState));
        }
        
        function collapseAllSections() {
            const sections = ['section-traffic', 'section-deicing', 'section-planned', 
                             'section-closure', 'section-runway', 'section-infogrid', 'section-taf', 'section-frost',
                             'section-active', 'section-residual', 'section-likely', 'section-possible', 'section-none'];
            for (const sectionId of sections) {
                const section = document.getElementById(sectionId);
                if (section) {
                    section.classList.add('collapsed');
                    const content = section.querySelector('.section-content');
                    const toggle = section.querySelector('.section-toggle');
                    if (content) content.classList.add('collapsed');
                    if (toggle) toggle.textContent = '&#x25B6;';
                    sectionState[sectionId] = 'collapsed';
                }
            }
            localStorage.setItem('deicingMonitorSections', JSON.stringify(sectionState));
        }
        
        function updateDashboardCard(cardType, count) {
            const countEl = document.getElementById(`count-${cardType}`);
            const cardEl = document.getElementById(`card-${cardType}`);
            
            if (countEl) {
                countEl.textContent = count;
            }
            
            if (cardEl) {
                if (count === 0) {
                    cardEl.classList.add('disabled');
                } else {
                    cardEl.classList.remove('disabled');
                }
            }
        }
        
        function scrollToSection(sectionId) {
            const section = document.getElementById(sectionId);
            if (section) {
                // Expand the section if collapsed
                if (section.classList.contains('collapsed')) {
                    section.classList.remove('collapsed');
                    const content = section.querySelector('.section-content');
                    const toggle = section.querySelector('.section-toggle');
                    if (content) content.classList.remove('collapsed');
                    if (toggle) toggle.textContent = '&#x25BC;';
                    sectionState[sectionId] = 'expanded';
                    localStorage.setItem('deicingMonitorSections', JSON.stringify(sectionState));
                }
                // Scroll to section
                section.scrollIntoView({ behavior: 'smooth', block: 'start' });
            }
        }

        function toggleHistory(id) {
            const el = document.getElementById(id);
            if (el) {
                el.classList.toggle('show');
            }
        }

        function toggleTafList() {
            const list = document.getElementById('tafExpandedList');
            const icon = document.getElementById('tafToggleIcon');
            if (list && icon) {
                if (list.style.display === 'none') {
                    list.style.display = 'block';
                    icon.textContent = '^ Show less';
                } else {
                    list.style.display = 'none';
                    icon.textContent = 'v Show all';
                }
            }
        }
        
        function toggleTafFull(tafId) {
            const el = document.getElementById(tafId);
            if (el) {
                el.classList.toggle('show');
                // Update the expand icon
                const parent = el.parentElement;
                const icon = parent.querySelector('.taf-expand-icon');
                if (icon) {
                    icon.textContent = el.classList.contains('show') ? '&#x25B2; TAF' : '&#x25BC; TAF';
                }
            }
            event.stopPropagation();
        }
        
        function toggleTafInline(el) {
            if (!el) return;
            el.classList.toggle('expanded');
            // Update the expand indicator in the parent taf-forecast div
            const parent = el.previousElementSibling;
            if (parent && parent.classList.contains('taf-forecast')) {
                const indicator = parent.querySelector('span:last-child');
                if (indicator) {
                    indicator.textContent = el.classList.contains('expanded') ? '&#x25B2; collapse' : '&#x25BC; expand';
                }
            }
            event.stopPropagation();
        }

        function renderSection(title, airports, sectionId) {
            // Determine section color based on title
            let sectionClass = 'section-deice-default';
            if (title.includes('Active')) sectionClass = 'section-deice-active';
            else if (title.includes('Residual')) sectionClass = 'section-deice-residual';
            else if (title.includes('Likely')) sectionClass = 'section-deice-likely';
            else if (title.includes('Possible')) sectionClass = 'section-deice-possible';
            else if (title.includes('Clear') || title.includes('None')) sectionClass = 'section-deice-none';
            
            let html = `
                <div id="${sectionId}" class="collapsible-section ${sectionClass} ${getSectionClass(sectionId)}">
                    <div class="section-header" onclick="toggleSection('${sectionId}')">
                        <h3>${title} (${airports.length})</h3>
                        <span class="section-toggle">${getSectionToggle(sectionId)}</span>
                    </div>
                    <div class="section-content ${getSectionContentClass(sectionId)}">
                        <div class="airport-list">
            `;

            for (const apt of airports) {
                const name = AIRPORT_NAMES[apt.icao] || apt.icao;
                const wx = formatWeatherDisplay(apt);
                const frClass = `fr-${apt.flight_rules.toLowerCase()}`;
                const rank = AIRPORTS.indexOf(apt.icao) + 1;
                const metarUrl = `https://aviationweather.gov/data/metar/?id=${apt.icao}&hours=6`;
                const notamUrl = `https://notams.aim.faa.gov/notamSearch/`;
                const timeSince = getTimeSince(apt.obs_time);
                const historyId = `history-${apt.icao}`;
                
                // Store wind data globally for runway map
                currentWindData[apt.icao] = {
                    direction: (apt.wind_variable || apt.wind_dir === 'VRB') ? null : apt.wind_dir,
                    speed: apt.wind_speed,
                    gust: apt.wind_gust,
                    variable: apt.wind_variable || apt.wind_dir === 'VRB'
                };
                
                // Format wind info
                let windHtml = '';
                if (apt.wind_speed !== null) {
                    let windClass = '';
                    let windText = '';
                    
                    if (apt.wind_variable) {
                        windText = `VRB${apt.wind_speed}kt`;
                    } else if (apt.wind_dir !== null) {
                        windText = `${String(apt.wind_dir).padStart(3, '0')}&deg;/${apt.wind_speed}kt`;
                    } else {
                        windText = `${apt.wind_speed}kt`;
                    }
                    
                    if (apt.wind_gust) {
                        windText += `G${apt.wind_gust}`;
                        windClass = apt.wind_gust >= 25 ? 'strong' : 'gusty';
                    } else if (apt.wind_speed >= 20) {
                        windClass = 'strong';
                    }
                    
                    windHtml = `<span class="wind-info ${windClass}"> ${windText}</span>`;
                }
                
                // Format visibility
                let visHtml = '';
                if (apt.visibility_text) {
                    let visClass = apt.visibility < 3 ? 'low' : '';
                    visHtml = `<span class="vis-info ${visClass}">&#x1F441; ${apt.visibility_text}</span>`;
                }
                
                // Build badges HTML
                let badgesHtml = '<div class="badges">';
                
                // Traffic program badges (highest priority)
                if (apt.traffic_programs) {
                    for (const prog of apt.traffic_programs) {
                        if (prog.type === 'GROUND STOP') {
                            badgesHtml += `<span class="badge badge-gs" title="${prog.reason}">GS</span>`;
                        } else if (prog.type === 'GDP') {
                            badgesHtml += `<span class="badge badge-gdp" title="${prog.reason}">GDP</span>`;
                        } else if (prog.type === 'DEICING') {
                            badgesHtml += `<span class="badge badge-deicing" title="${prog.reason}"> DEICING</span>`;
                        } else if (prog.type === 'ARR DELAY') {
                            badgesHtml += `<span class="badge badge-delay" title="${prog.reason}">ARR DLY</span>`;
                        } else if (prog.type === 'DEP DELAY') {
                            badgesHtml += `<span class="badge badge-delay" title="${prog.reason}">DEP DLY</span>`;
                        } else if (prog.type !== 'CLOSED') {
                            // Skip CLOSED, show any other type
                            badgesHtml += `<span class="badge badge-delay" title="${prog.reason}">${prog.type}</span>`;
                        }
                    }
                }
                
                // Runway/taxiway closure badge
                const closures = faaAdvisoryData.runwayClosures[apt.icao];
                if (closures && closures.length > 0) {
                    badgesHtml += `<span class="badge badge-closure" title="${closures.join(', ')}">&#x1F6A7; RWY WORK</span>`;
                }
                
                // Planned ground stop badge
                const planned = faaAdvisoryData.terminalPlanned[apt.icao];
                if (planned && planned.length > 0) {
                    badgesHtml += `<span class="badge badge-planned" title="${planned.join(', ')}"> GS POSS</span>`;
                }
                
                // Rush hour badge
                if (apt.rush_status) {
                    badgesHtml += `<span class="badge badge-rush">${apt.rush_status}</span>`;
                }
                
                // Frost risk badge (night + cold)
                if (apt.frost_risk) {
                    badgesHtml += `<span class="badge badge-frost">&#x1F319; FROST RISK</span>`;
                }
                
                // Dewpoint spread badge - fog/icing risk when spread is small
                if (apt.dewpoint_spread !== null && apt.temp_c !== null && apt.temp_c <= 5) {
                    if (apt.dewpoint_spread <= 2) {
                        badgesHtml += `<span class="badge" style="background:#8e44ad;color:white;" title="Temp/Dewpoint spread: ${apt.dewpoint_spread}&deg;C - High fog/ice risk"> DEW ${apt.dewpoint_spread}&deg;</span>`;
                    } else if (apt.dewpoint_spread <= 4) {
                        badgesHtml += `<span class="badge" style="background:#5d6d7e;color:white;" title="Temp/Dewpoint spread: ${apt.dewpoint_spread}&deg;C - Moisture"> DEW ${apt.dewpoint_spread}&deg;</span>`;
                    }
                }
                
                // TAF frozen precip forecast badge with timing
                if (apt.taf && apt.taf.frozenForecasts && apt.taf.frozenForecasts.length > 0) {
                    const fc = apt.taf.frozenForecasts[0];
                    const summary = apt.taf.summary || '';
                    badgesHtml += `<span class="badge badge-taf-sn" title="${fc.raw}\n${summary}">TAF: ${fc.wx}</span>`;
                }
                
                // Hub badge
                if (apt.hub_airlines) {
                    const hubText = apt.hub_airlines.length > 2 
                        ? apt.hub_airlines.slice(0, 2).join('/') + '+' 
                        : apt.hub_airlines.join('/');
                    badgesHtml += `<span class="badge badge-hub" title="${apt.hub_airlines.join(', ')} hub">HUB: ${hubText}</span>`;
                }
                
                badgesHtml += '</div>';
                
                // Recent frozen precip indicator
                let recentFrozenHtml = '';
                if (apt.had_recent_frozen && !apt.frozen_precip) {
                    const frozenAgo = apt.last_frozen_time ? getTimeSince(apt.last_frozen_time).text : 'recently';
                    recentFrozenHtml = `<div class="recent-frozen-note"> ${apt.recent_frozen_types.join(', ')} ended ${frozenAgo}</div>`;
                }
                
                // TAF forecast indicator - expandable
                let tafHtml = '';
                if (apt.taf && apt.taf.raw) {
                    const hasFrozen = apt.taf.frozenForecasts && apt.taf.frozenForecasts.length > 0;
                    const wxSummary = hasFrozen ? apt.taf.frozenForecasts[0].wx : 'Available';
                    const tafCardId = `taf-card-${apt.icao}`;
                    tafHtml = `
                        <div class="taf-forecast" style="cursor:pointer;" onclick="toggleTafInline(document.getElementById('${tafCardId}')); event.stopPropagation();">
                            &#x1F4CB; TAF: <span style="color:${hasFrozen ? '#9b59b6' : '#4a90d9'};">${wxSummary}</span>
                            <span style="color:#666;font-size:9px;margin-left:4px;">&#x25BC; expand</span>
                        </div>
                        <div class="taf-inline" id="${tafCardId}" onclick="toggleTafInline(this); event.stopPropagation();">${apt.taf.raw}</div>
                    `;
                }
                
                // HOT estimate with fluid types
                let hotHtml = '';
                if (apt.hot_estimate) {
                    const hot = apt.hot_estimate;
                    const statusColors = {
                        ok: '#1abc9c',
                        caution: '#f39c12',
                        short: '#e67e22',
                        critical: '#e74c3c'
                    };
                    const statusColor = statusColors[hot.status] || '#888';
                    const statusBg = hot.status === 'critical' ? '#3d1a1a' : 
                                    hot.status === 'short' ? '#3d2a1a' : 
                                    hot.status === 'caution' ? '#3d3d1a' : '#1a3d2d';
                    
                    hotHtml = `
                        <div class="hot-estimate" style="background:${statusBg};color:${statusColor};">
                            <span style="font-weight:bold;"> HOT:</span> 
                            <span title="Type I fluid">I: ${hot.typeI.min}-${hot.typeI.max}m</span> | 
                            <span title="Type IV fluid" style="color:#9b59b6;">IV: ${hot.typeIV.min}-${hot.typeIV.max}m</span>
                            <span style="opacity:0.8;font-size:9px;margin-left:4px;">(${hot.intensity} ${hot.precipName})</span>
                        </div>`;
                }
                
                // Runway status
                let runwayHtml = '';
                if (apt.runway_status) {
                    const rwy = apt.runway_status;
                    if (rwy.status !== 'good' || rwy.brakingAction) {
                        let brakingHtml = '';
                        if (rwy.brakingAction) {
                            const brakingClass = rwy.brakingAction === 'GOOD' ? 'braking-good' : 
                                                rwy.brakingAction === 'MEDIUM' || rwy.brakingAction === 'FAIR' ? 'braking-fair' :
                                                rwy.brakingAction === 'POOR' ? 'braking-poor' : 'braking-nil';
                            brakingHtml = `<span class="braking-action ${brakingClass}">BRAKING: ${rwy.brakingAction}</span>`;
                        }
                        
                        let statusText = rwy.message || `${rwy.available}/${rwy.total} rwys`;
                        runwayHtml = `<div class="runway-status ${rwy.status}">&#x1F6EC; ${statusText} ${brakingHtml}</div>`;
                    }
                }
                
                let historyHtml = '';
                if (apt.history && apt.history.length > 0) {
                    historyHtml = `<div class="history" id="${historyId}"><div class="history-title">Last ${apt.history.length} observations</div>`;
                    historyHtml += `<div class="history-header"><span class="time">Time (Z/Local)</span><span class="ceiling">Ceil</span><span class="wx">Weather</span><span class="wind">Wind</span><span class="temp">Temp</span></div>`;
                    for (const h of apt.history) {
                        const hTimeData = formatObsTime(h.obs_time);
                        const hTime = hTimeData.combined;
                        const hCeiling = h.ceiling_text || '&mdash;';
                        const hWx = formatHistoryWeather(h);
                        const hWind = h.wind_speed !== null ? 
                            (h.wind_variable ? `VRB${h.wind_speed}` : `${h.wind_speed}kt`) + (h.wind_gust ? `G${h.wind_gust}` : '') : '&mdash;';
                        const hTemp = h.temp_c !== null ? `${tempToF(h.temp_c)}&deg;F/${h.temp_c}&deg;C` : 'N/A';
                        // Highlight rows with frozen precip (handle intensity prefixes like -SN, +SN)
                        const hasFrozen = h.weather.some(w => {
                            const stripped = w.replace(/^[-+]/, '');
                            return FROZEN_PRECIP.some(code => stripped === code || stripped.includes(code));
                        });
                        const rowStyle = hasFrozen ? 'background: #3d2850;' : '';
                        historyHtml += `<div class="history-row" style="${rowStyle}"><span class="time">${hTime}</span><span class="ceiling">${hCeiling}</span><span class="wx">${hWx}</span><span class="wind">${hWind}</span><span class="temp">${hTemp}</span></div>`;
                    }
                    historyHtml += '</div>';
                }
                
                html += `
                    <div class="airport-card" onclick="toggleHistory('${historyId}')">
                        <div class="airport-main">
                            <div class="left">
                                <div class="icao">#${rank} ${apt.icao}</div>
                                <div>
                                    <div class="name">
                                        <a href="${metarUrl}" target="_blank" onclick="event.stopPropagation();" title="View METARs">${name} </a>
                                        <a href="${notamUrl}" target="_blank" onclick="event.stopPropagation();" class="notam-link" title="FAA NOTAM Search"></a>
                                        <button class="runway-map-btn" onclick="showRunwayMap('${apt.icao}', event)" title="View Runway Map">&#x1F6EB; Map</button>
                                    </div>
                                    <div class="weather">${wx} <span class="flight-rules ${frClass}">${apt.flight_rules}</span> ${windHtml} ${visHtml}</div>
                                    <div class="obs-time ${timeSince.stale ? 'stale' : ''}">${timeSince.zulu} &bull; ${timeSince.text}</div>
                                    ${recentFrozenHtml}
                                    ${tafHtml}
                                    ${hotHtml}
                                    ${runwayHtml}
                                    ${badgesHtml}
                                </div>
                            </div>
                            <div class="right">
                                <div class="trend ${apt.trend.class}" title="${apt.trend.text}">${apt.trend.symbol}</div>
                                <div class="temp">
                                    <div class="temp-value">${tempToF(apt.temp_c)}&deg;F</div>
                                    <div class="temp-f">${apt.temp_c}&deg;C</div>
                                </div>
                            </div>
                        </div>
                        <div class="expand-hint">Tap to see history</div>
                        ${historyHtml}
                    </div>
                `;
            }

            html += '</div></div></div>';
            return html;
        }

        function setAutoRefresh() {
            const mins = parseInt(document.getElementById('autoRefresh').value);
            if (refreshInterval) clearInterval(refreshInterval);
            if (mins > 0) {
                refreshInterval = setInterval(fetchData, mins * 60 * 1000);
            }
        }

        // Start
        console.log('=== Airport Deicing Monitor v2.3 ===');
        (async function init() {
            console.log('=== INIT STARTING ===');
            console.log('Calling loadRunwayData...');
            await loadRunwayData(); // Load worldwide runway data first
            console.log('loadRunwayData complete, RUNWAY_DATA has', Object.keys(RUNWAY_DATA).length, 'entries');
            console.log('Calling fetchData...');
            fetchData();
        })();
        setAutoRefresh();
        
        // Timezone detection and display
        function detectUserTimezone() {
            const tz = Intl.DateTimeFormat().resolvedOptions().timeZone;
            
            // Map timezone to friendly name
            const tzNames = {
                'America/New_York': 'Eastern',
                'America/Detroit': 'Eastern',
                'America/Indiana/Indianapolis': 'Eastern',
                'America/Kentucky/Louisville': 'Eastern',
                'America/Chicago': 'Central',
                'America/Menominee': 'Central',
                'America/Denver': 'Mountain',
                'America/Phoenix': 'Arizona',
                'America/Boise': 'Mountain',
                'America/Los_Angeles': 'Pacific',
                'America/Anchorage': 'Alaska',
                'Pacific/Honolulu': 'Hawaii',
                'America/Toronto': 'Eastern',
                'America/Vancouver': 'Pacific',
                'America/Edmonton': 'Mountain',
                'America/Winnipeg': 'Central',
                'America/Halifax': 'Atlantic',
                'America/St_Johns': 'Newfoundland',
                'America/Montreal': 'Eastern',
            };
            
            let name = tzNames[tz];
            if (!name) {
                // Try to extract from timezone string
                const parts = tz.split('/');
                name = parts[parts.length - 1].replace(/_/g, ' ');
            }
            
            return { timezone: tz, name: name };
        }
        
        const userTz = detectUserTimezone();
        
        function updateTimezones() {
            const now = new Date();
            
            const formatTime = (tz, includeZ = false) => {
                try {
                    const time = now.toLocaleTimeString('en-US', { 
                        timeZone: tz, 
                        hour: '2-digit', 
                        minute: '2-digit',
                        second: '2-digit',
                        hour12: false 
                    });
                    return includeZ ? time + 'Z' : time;
                } catch (e) {
                    return '--:--:--';
                }
            };
            
            // Zulu/UTC
            const zuluEl = document.getElementById('tz-zulu');
            if (zuluEl) zuluEl.textContent = formatTime('UTC', true);
            
            // Local timezone (user's detected timezone)
            const localEl = document.getElementById('tz-local');
            const localLabel = document.getElementById('tz-local-label');
            if (localEl) localEl.textContent = formatTime(userTz.timezone);
            if (localLabel) localLabel.textContent = userTz.name;
            
            // Expanded timezones (for toggle)
            const eastEl = document.getElementById('tz-eastern');
            if (eastEl) eastEl.textContent = formatTime('America/New_York');
            
            const centEl = document.getElementById('tz-central');
            if (centEl) centEl.textContent = formatTime('America/Chicago');
            
            const mtEl = document.getElementById('tz-mountain');
            if (mtEl) mtEl.textContent = formatTime('America/Denver');
            
            const pacEl = document.getElementById('tz-pacific');
            if (pacEl) pacEl.textContent = formatTime('America/Los_Angeles');
        }
        
        function toggleAllTimezones() {
            const expanded = document.getElementById('timezoneBoxExpanded');
            const toggle = document.getElementById('tzToggle');
            
            if (expanded.style.display === 'none') {
                expanded.style.display = 'flex';
                toggle.classList.add('expanded');
                toggle.textContent = '+';
            } else {
                expanded.style.display = 'none';
                toggle.classList.remove('expanded');
                toggle.textContent = '+';
            }
        }
        
        updateTimezones();
        setInterval(updateTimezones, 1000);
    </script>
</body>
</html>
