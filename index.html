<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Airport Deicing Monitor - Top 100</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a2e;
            color: #eee;
            min-height: 100vh;
            padding: 15px;
        }
        
        .container {
            max-width: 800px;
            margin: 0 auto;
        }
        
        header {
            text-align: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid #333;
        }
        
        h1 {
            font-size: 22px;
            margin-bottom: 8px;
            color: #fff;
        }
        
        .subtitle {
            color: #4a90d9;
            font-size: 13px;
            margin-bottom: 5px;
        }
        
        .timestamp {
            color: #888;
            font-size: 12px;
        }
        
        .timezone-box {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 8px;
            margin: 15px 0;
            padding: 12px;
            background: #252540;
            border-radius: 8px;
        }
        
        .tz-item {
            text-align: center;
            padding: 4px 12px;
            min-width: 70px;
        }
        
        .tz-item .tz-time {
            font-family: 'Courier New', monospace;
            font-size: 18px;
            font-weight: bold;
            color: #fff;
        }
        
        .tz-item .tz-label {
            font-size: 10px;
            color: #888;
            text-transform: uppercase;
            margin-top: 2px;
        }
        
        .tz-item.zulu .tz-time {
            color: #4a90d9;
        }
        
        .tz-item.zulu .tz-label {
            color: #4a90d9;
        }
        
        .controls {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        
        button {
            background: #4a90d9;
            color: white;
            border: none;
            padding: 14px 28px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 500;
            touch-action: manipulation;
        }
        
        button:disabled {
            background: #555;
        }
        
        .auto-refresh {
            display: flex;
            align-items: center;
            gap: 8px;
            color: #888;
            font-size: 14px;
        }
        
        .auto-refresh select {
            background: #252540;
            color: #fff;
            border: 1px solid #444;
            padding: 12px;
            border-radius: 6px;
            font-size: 16px;
        }
        
        .summary {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-bottom: 25px;
        }
        
        .summary-card {
            background: #252540;
            padding: 15px;
            border-radius: 10px;
            text-align: center;
        }
        
        .summary-card .count {
            font-size: 32px;
            font-weight: bold;
            margin-bottom: 3px;
        }
        
        .summary-card .label {
            font-size: 11px;
            color: #888;
            text-transform: uppercase;
        }
        
        .summary-card.active { border-left: 4px solid #e74c3c; }
        .summary-card.active .count { color: #e74c3c; }
        
        .summary-card.likely { border-left: 4px solid #f39c12; }
        .summary-card.likely .count { color: #f39c12; }
        
        .summary-card.possible { border-left: 4px solid #f1c40f; }
        .summary-card.possible .count { color: #f1c40f; }
        
        .summary-card.none { border-left: 4px solid #2ecc71; }
        .summary-card.none .count { color: #2ecc71; }
        
        .summary-card.residual { border-left: 4px solid #9b59b6; }
        .summary-card.residual .count { color: #9b59b6; }
        
        .section {
            margin-bottom: 25px;
        }
        
        .section-header {
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 1px solid #333;
        }
        
        .section-header h2 {
            font-size: 16px;
            font-weight: 600;
        }
        
        .airport-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .airport-card {
            background: #252540;
            padding: 12px 15px;
            border-radius: 8px;
            cursor: pointer;
            transition: background 0.2s;
            text-decoration: none;
            color: inherit;
            display: block;
        }
        
        .airport-card:hover {
            background: #333355;
        }
        
        .airport-main {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .airport-card .left {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .airport-card .icao {
            font-family: 'Courier New', monospace;
            font-weight: bold;
            font-size: 14px;
            background: #1a1a2e;
            padding: 6px 8px;
            border-radius: 4px;
        }
        
        .airport-card .name {
            font-weight: 500;
            font-size: 14px;
        }
        
        .airport-card .name a {
            color: #7db8eb;
            text-decoration: none;
        }
        
        .airport-card .name a:hover {
            text-decoration: underline;
        }
        
        .airport-card .weather {
            font-size: 11px;
            color: #888;
            margin-top: 2px;
        }
        
        .airport-card .right {
            text-align: right;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .airport-card .temp {
            text-align: right;
        }
        
        .airport-card .temp-value {
            font-size: 18px;
            font-weight: bold;
        }
        
        .airport-card .temp-f {
            font-size: 11px;
            color: #888;
        }
        
        .trend {
            font-size: 20px;
            font-weight: bold;
        }
        
        .trend.warming { color: #e74c3c; }
        .trend.cooling { color: #3498db; }
        .trend.steady { color: #888; }
        
        .obs-time {
            font-size: 10px;
            color: #888;
            margin-top: 4px;
        }
        
        .obs-time.stale {
            color: #e74c3c;
        }
        
        .flight-rules {
            font-size: 9px;
            padding: 2px 5px;
            border-radius: 3px;
            display: inline-block;
            margin-top: 3px;
        }
        
        .fr-vfr { background: #2ecc71; color: #000; }
        .fr-mvfr { background: #3498db; color: #fff; }
        .fr-ifr { background: #e74c3c; color: #fff; }
        .fr-lifr { background: #9b59b6; color: #fff; }
        
        .history {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid #333;
            display: none;
        }
        
        .history.show {
            display: block;
        }
        
        .history-title {
            font-size: 11px;
            color: #888;
            margin-bottom: 8px;
            text-transform: uppercase;
        }
        
        .history-row {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            padding: 4px 0;
            border-bottom: 1px solid #1a1a2e;
        }
        
        .history-row .time {
            color: #888;
            min-width: 80px;
        }
        
        .history-row .temp {
            font-weight: bold;
            min-width: 100px;
        }
        
        .history-row .wx {
            color: #aaa;
            flex: 1;
            text-align: right;
        }
        
        .loading, .error {
            text-align: center;
            padding: 40px 20px;
        }
        
        .loading .spinner {
            width: 36px;
            height: 36px;
            border: 3px solid #333;
            border-top-color: #4a90d9;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        .error {
            background: #3d1f1f;
            border-radius: 8px;
            color: #ff6b6b;
        }
        
        .error button {
            margin-top: 15px;
            background: #c0392b;
        }
        
        footer {
            text-align: center;
            margin-top: 30px;
            padding-top: 15px;
            border-top: 1px solid #333;
            color: #555;
            font-size: 11px;
        }
        
        .status-msg {
            text-align: center;
            padding: 10px;
            margin-bottom: 15px;
            border-radius: 6px;
            font-size: 13px;
        }
        
        .status-msg.info { background: #1a3a5c; color: #7db8eb; }

        .expand-hint {
            font-size: 10px;
            color: #666;
            margin-top: 4px;
        }
        
        .residual-badge {
            background: #9b59b6;
            color: white;
            font-size: 9px;
            padding: 2px 6px;
            border-radius: 3px;
            margin-left: 8px;
            display: inline-block;
        }
        
        .recent-frozen-note {
            font-size: 10px;
            color: #9b59b6;
            margin-top: 3px;
        }
        
        .badges {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            margin-top: 4px;
        }
        
        .badge {
            font-size: 9px;
            padding: 2px 6px;
            border-radius: 3px;
            display: inline-block;
        }
        
        .badge-hub {
            background: #2c3e50;
            color: #bdc3c7;
        }
        
        .badge-rush {
            background: #d35400;
            color: white;
        }
        
        .badge-gdp {
            background: #c0392b;
            color: white;
            animation: pulse 2s infinite;
        }
        
        .badge-gs {
            background: #8e44ad;
            color: white;
            animation: pulse 1.5s infinite;
        }
        
        .badge-delay {
            background: #e67e22;
            color: white;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        
        .traffic-section {
            background: #2d1f1f;
            border: 1px solid #5c3a3a;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 20px;
        }
        
        .traffic-section h3 {
            font-size: 14px;
            color: #e74c3c;
            margin-bottom: 10px;
        }
        
        .traffic-item {
            font-size: 12px;
            padding: 6px 0;
            border-bottom: 1px solid #3d2a2a;
        }
        
        .traffic-item:last-child {
            border-bottom: none;
        }
        
        .traffic-item .airport {
            font-weight: bold;
            color: #fff;
        }
        
        .traffic-item .program {
            color: #e74c3c;
        }
        
        .traffic-item .reason {
            color: #888;
            font-size: 11px;
        }
        
        .forecast-section {
            background: #1f2d3d;
            border: 1px solid #3a5068;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 15px;
        }
        
        .forecast-section h3 {
            font-size: 14px;
            color: #4a90d9;
            margin-bottom: 10px;
        }
        
        .forecast-section h3[onclick]:hover {
            color: #7db8eb;
        }
        
        .forecast-note {
            font-size: 11px;
            color: #7db8eb;
            padding: 6px 0;
            border-bottom: 1px solid #2a4058;
        }
        
        .forecast-note:last-child {
            border-bottom: none;
        }
        
        .forecast-note .airport {
            font-weight: bold;
            color: #fff;
        }
        
        .forecast-note .time {
            color: #f39c12;
        }
        
        .pirep-section {
            background: #2d2d1f;
            border: 1px solid #5c5c3a;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 15px;
        }
        
        .pirep-section h3 {
            font-size: 14px;
            color: #f1c40f;
            margin-bottom: 10px;
        }
        
        .pirep-item {
            font-size: 11px;
            color: #ddd;
            padding: 6px 0;
            border-bottom: 1px solid #3d3d2a;
        }
        
        .pirep-item:last-child {
            border-bottom: none;
        }
        
        .pirep-item .intensity {
            font-weight: bold;
            padding: 1px 5px;
            border-radius: 3px;
            margin-right: 5px;
        }
        
        .pirep-item .intensity.light { background: #27ae60; color: #fff; }
        .pirep-item .intensity.moderate { background: #f39c12; color: #000; }
        .pirep-item .intensity.severe { background: #e74c3c; color: #fff; }
        
        .airmet-section {
            background: #2d1f2d;
            border: 1px solid #5c3a5c;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 15px;
        }
        
        .airmet-section h3 {
            font-size: 14px;
            color: #9b59b6;
            margin-bottom: 10px;
        }
        
        .airmet-item {
            font-size: 11px;
            color: #ddd;
            padding: 6px 0;
            border-bottom: 1px solid #3d2a3d;
        }
        
        .airmet-item:last-child {
            border-bottom: none;
        }
        
        .badge-frost {
            background: #2980b9;
            color: white;
        }
        
        .badge-taf-sn {
            background: #8e44ad;
            color: white;
        }
        
        .taf-forecast {
            font-size: 10px;
            color: #9b59b6;
            margin-top: 3px;
        }
        
        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .data-panel {
            background: #252540;
            border-radius: 8px;
            padding: 12px;
        }
        
        .data-panel h3 {
            font-size: 13px;
            margin-bottom: 10px;
            padding-bottom: 8px;
            border-bottom: 1px solid #333;
        }
        
        .data-panel.pireps h3 { color: #f1c40f; }
        .data-panel.airmets h3 { color: #9b59b6; }
        .data-panel.freezing h3 { color: #1abc9c; }
        
        .data-panel h3[onclick]:hover {
            opacity: 0.8;
        }
        
        .compact-list {
            font-size: 11px;
            max-height: 150px;
            overflow-y: auto;
        }
        
        .compact-list .item {
            padding: 4px 0;
            border-bottom: 1px solid #1a1a2e;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>‚úàÔ∏è Airport Deicing Monitor</h1>
            <div class="subtitle">Top 100 US Airports ‚Ä¢ Last 6 METARs</div>
            <div class="timestamp" id="timestamp">Loading...</div>
        </header>
        
        <div class="timezone-box" id="timezoneBox">
            <div class="tz-item zulu">
                <div class="tz-time" id="tz-zulu">--:--</div>
                <div class="tz-label">Zulu</div>
            </div>
            <div class="tz-item">
                <div class="tz-time" id="tz-eastern">--:--</div>
                <div class="tz-label">Eastern</div>
            </div>
            <div class="tz-item">
                <div class="tz-time" id="tz-central">--:--</div>
                <div class="tz-label">Central</div>
            </div>
            <div class="tz-item">
                <div class="tz-time" id="tz-mountain">--:--</div>
                <div class="tz-label">Mountain</div>
            </div>
            <div class="tz-item">
                <div class="tz-time" id="tz-pacific">--:--</div>
                <div class="tz-label">Pacific</div>
            </div>
        </div>
        
        <div class="controls">
            <button id="refreshBtn" onclick="fetchData()">üîÑ Refresh</button>
            <div class="auto-refresh">
                <span>Auto:</span>
                <select id="autoRefresh" onchange="setAutoRefresh()">
                    <option value="0">Off</option>
                    <option value="5">5m</option>
                    <option value="15">15m</option>
                    <option value="30" selected>30m</option>
                </select>
            </div>
        </div>
        
        <div id="content">
            <div class="loading">
                <div class="spinner"></div>
                <div>Fetching METAR data for 100 airports...</div>
            </div>
        </div>
        
        <footer>
            Data: Aviation Weather Center<br>
            Tap airport to see history ‚Ä¢ Tap city name to open full METAR
        </footer>
    </div>

    <script>
        // Top 100 US airports by passenger volume
        const AIRPORTS = [
            // Top 50
            'KATL', 'KLAX', 'KORD', 'KDFW', 'KDEN', 'KJFK', 'KSFO', 'KLAS', 'KMCO', 'KSEA',
            'KMIA', 'KPHX', 'KEWR', 'KIAH', 'KBOS', 'KMSP', 'KDTW', 'KFLL', 'KPHL', 'KLGA',
            'KBWI', 'KSLC', 'KDCA', 'KSAN', 'KTPA', 'KAUS', 'KIAD', 'KMDW', 'KHNL', 'KSTL',
            'KBNA', 'KOAK', 'KSMF', 'KSJC', 'KRDU', 'KMCI', 'KCLE', 'KPIT', 'KCLT', 'KPDX',
            'KIND', 'KCVG', 'KMSY', 'KSAT', 'KMKE', 'KBUF', 'KPBI', 'KABQ', 'KONT', 'KRSW',
            // 51-75
            'KBUR', 'KOMA', 'KRIC', 'KBDL', 'KSNA', 'KJAN', 'KCHS', 'KJAX', 'KORF', 'KANC',
            'KLIT', 'KELP', 'KTUS', 'KOKC', 'KTUL', 'KGRR', 'KDSM', 'KDAY', 'KSYR', 'KPVD',
            'KALB', 'KGSO', 'KPWM', 'KBTV', 'KROC',
            // 76-100
            'KBHM', 'KLEX', 'KSDF', 'KCMH', 'KCOS', 'KBOI', 'KFSD', 'KICT', 'KMSN', 'KLBB',
            'KFAR', 'KBIS', 'KDLH', 'KERI', 'KBGR', 'KAVL', 'KMYR', 'KSAV', 'KPNS', 'KFWA',
            'KLNK', 'KSGF', 'KXNA', 'KCRP', 'KABI'
        ];

        const AIRPORT_NAMES = {
            // Top 50
            'KATL': 'Atlanta', 'KLAX': 'Los Angeles', 'KORD': 'Chicago ORD',
            'KDFW': 'Dallas/Fort Worth', 'KDEN': 'Denver', 'KJFK': 'New York JFK',
            'KSFO': 'San Francisco', 'KLAS': 'Las Vegas', 'KMCO': 'Orlando',
            'KSEA': 'Seattle', 'KMIA': 'Miami', 'KPHX': 'Phoenix', 'KEWR': 'Newark',
            'KIAH': 'Houston IAH', 'KBOS': 'Boston', 'KMSP': 'Minneapolis',
            'KDTW': 'Detroit', 'KFLL': 'Fort Lauderdale', 'KPHL': 'Philadelphia',
            'KLGA': 'New York LGA', 'KBWI': 'Baltimore', 'KSLC': 'Salt Lake City',
            'KDCA': 'Washington DCA', 'KSAN': 'San Diego', 'KTPA': 'Tampa',
            'KAUS': 'Austin', 'KIAD': 'Washington IAD', 'KMDW': 'Chicago MDW',
            'KHNL': 'Honolulu', 'KSTL': 'St. Louis', 'KBNA': 'Nashville',
            'KOAK': 'Oakland', 'KSMF': 'Sacramento', 'KSJC': 'San Jose',
            'KRDU': 'Raleigh-Durham', 'KMCI': 'Kansas City', 'KCLE': 'Cleveland',
            'KPIT': 'Pittsburgh', 'KCLT': 'Charlotte', 'KPDX': 'Portland OR',
            'KIND': 'Indianapolis', 'KCVG': 'Cincinnati', 'KMSY': 'New Orleans',
            'KSAT': 'San Antonio', 'KMKE': 'Milwaukee', 'KBUF': 'Buffalo',
            'KPBI': 'West Palm Beach', 'KABQ': 'Albuquerque', 'KONT': 'Ontario CA',
            'KRSW': 'Fort Myers',
            // 51-75
            'KBUR': 'Burbank', 'KOMA': 'Omaha', 'KRIC': 'Richmond',
            'KBDL': 'Hartford', 'KSNA': 'Orange County', 'KJAN': 'Jackson MS',
            'KCHS': 'Charleston', 'KJAX': 'Jacksonville', 'KORF': 'Norfolk',
            'KANC': 'Anchorage', 'KLIT': 'Little Rock', 'KELP': 'El Paso',
            'KTUS': 'Tucson', 'KOKC': 'Oklahoma City', 'KTUL': 'Tulsa',
            'KGRR': 'Grand Rapids', 'KDSM': 'Des Moines', 'KDAY': 'Dayton',
            'KSYR': 'Syracuse', 'KPVD': 'Providence', 'KALB': 'Albany',
            'KGSO': 'Greensboro', 'KPWM': 'Portland ME', 'KBTV': 'Burlington VT',
            'KROC': 'Rochester',
            // 76-100
            'KBHM': 'Birmingham', 'KLEX': 'Lexington', 'KSDF': 'Louisville',
            'KCMH': 'Columbus OH', 'KCOS': 'Colorado Springs', 'KBOI': 'Boise',
            'KFSD': 'Sioux Falls', 'KICT': 'Wichita', 'KMSN': 'Madison',
            'KLBB': 'Lubbock', 'KFAR': 'Fargo', 'KBIS': 'Bismarck',
            'KDLH': 'Duluth', 'KERI': 'Erie', 'KBGR': 'Bangor',
            'KAVL': 'Asheville', 'KMYR': 'Myrtle Beach', 'KSAV': 'Savannah',
            'KPNS': 'Pensacola', 'KFWA': 'Fort Wayne', 'KLNK': 'Lincoln',
            'KSGF': 'Springfield MO', 'KXNA': 'NW Arkansas', 'KCRP': 'Corpus Christi',
            'KABI': 'Abilene'
        };

        // Timezone offsets from UTC (standard time - will need DST adjustment)
        const AIRPORT_TIMEZONES = {
            // Eastern (-5 standard, -4 DST)
            'KATL': 'America/New_York', 'KJFK': 'America/New_York', 'KMCO': 'America/New_York',
            'KMIA': 'America/New_York', 'KEWR': 'America/New_York', 'KBOS': 'America/New_York',
            'KDTW': 'America/New_York', 'KFLL': 'America/New_York', 'KPHL': 'America/New_York',
            'KLGA': 'America/New_York', 'KBWI': 'America/New_York', 'KDCA': 'America/New_York',
            'KTPA': 'America/New_York', 'KIAD': 'America/New_York', 'KRDU': 'America/New_York',
            'KCLE': 'America/New_York', 'KPIT': 'America/New_York', 'KCLT': 'America/New_York',
            'KIND': 'America/New_York', 'KCVG': 'America/New_York', 'KBUF': 'America/New_York',
            'KPBI': 'America/New_York', 'KRSW': 'America/New_York', 'KRIC': 'America/New_York',
            'KBDL': 'America/New_York', 'KCHS': 'America/New_York', 'KJAX': 'America/New_York',
            'KORF': 'America/New_York', 'KDAY': 'America/New_York', 'KSYR': 'America/New_York',
            'KPVD': 'America/New_York', 'KALB': 'America/New_York', 'KGSO': 'America/New_York',
            'KROC': 'America/New_York', 'KBHM': 'America/New_York', 'KLEX': 'America/New_York',
            'KSDF': 'America/New_York', 'KCMH': 'America/New_York', 'KERI': 'America/New_York',
            'KBGR': 'America/New_York', 'KAVL': 'America/New_York', 'KMYR': 'America/New_York',
            'KSAV': 'America/New_York', 'KPNS': 'America/New_York', 'KFWA': 'America/New_York',
            'KPWM': 'America/New_York', 'KBTV': 'America/New_York',
            // Central (-6 standard, -5 DST)
            'KORD': 'America/Chicago', 'KDFW': 'America/Chicago', 'KIAH': 'America/Chicago',
            'KMSP': 'America/Chicago', 'KMDW': 'America/Chicago', 'KSTL': 'America/Chicago',
            'KBNA': 'America/Chicago', 'KMCI': 'America/Chicago', 'KMSY': 'America/Chicago',
            'KSAT': 'America/Chicago', 'KMKE': 'America/Chicago', 'KAUS': 'America/Chicago',
            'KOMA': 'America/Chicago', 'KJAN': 'America/Chicago', 'KLIT': 'America/Chicago',
            'KELP': 'America/Chicago', 'KOKC': 'America/Chicago', 'KTUL': 'America/Chicago',
            'KGRR': 'America/Chicago', 'KDSM': 'America/Chicago', 'KFSD': 'America/Chicago',
            'KICT': 'America/Chicago', 'KMSN': 'America/Chicago', 'KLBB': 'America/Chicago',
            'KFAR': 'America/Chicago', 'KBIS': 'America/Chicago', 'KDLH': 'America/Chicago',
            'KLNK': 'America/Chicago', 'KSGF': 'America/Chicago', 'KXNA': 'America/Chicago',
            'KCRP': 'America/Chicago', 'KABI': 'America/Chicago',
            // Mountain (-7 standard, -6 DST)
            'KDEN': 'America/Denver', 'KPHX': 'America/Phoenix', 'KSLC': 'America/Denver',
            'KABQ': 'America/Denver', 'KTUS': 'America/Denver', 'KCOS': 'America/Denver',
            'KBOI': 'America/Boise',
            // Pacific (-8 standard, -7 DST)
            'KLAX': 'America/Los_Angeles', 'KSFO': 'America/Los_Angeles', 'KLAS': 'America/Los_Angeles',
            'KSEA': 'America/Los_Angeles', 'KSAN': 'America/Los_Angeles', 'KPDX': 'America/Los_Angeles',
            'KOAK': 'America/Los_Angeles', 'KSMF': 'America/Los_Angeles', 'KSJC': 'America/Los_Angeles',
            'KONT': 'America/Los_Angeles', 'KBUR': 'America/Los_Angeles', 'KSNA': 'America/Los_Angeles',
            // Alaska/Hawaii
            'KANC': 'America/Anchorage', 'KHNL': 'Pacific/Honolulu'
        };

        // Major airline hubs
        const HUB_AIRPORTS = {
            'KATL': ['Delta'],
            'KLAX': ['American', 'Delta', 'United'],
            'KORD': ['American', 'United'],
            'KDFW': ['American'],
            'KDEN': ['United', 'Southwest', 'Frontier'],
            'KJFK': ['JetBlue', 'Delta'],
            'KSFO': ['United'],
            'KLAS': ['Southwest', 'Spirit'],
            'KMCO': ['Southwest', 'JetBlue'],
            'KSEA': ['Alaska', 'Delta'],
            'KMIA': ['American'],
            'KPHX': ['American', 'Southwest'],
            'KEWR': ['United'],
            'KIAH': ['United'],
            'KBOS': ['JetBlue'],
            'KMSP': ['Delta', 'Sun Country'],
            'KDTW': ['Delta'],
            'KCLT': ['American'],
            'KSLC': ['Delta'],
            'KBWI': ['Southwest'],
            'KMDW': ['Southwest'],
            'KBNA': ['Southwest'],
            'KAUS': ['Southwest'],
            'KFLL': ['Spirit', 'JetBlue']
        };

        // Traffic management data
        let trafficPrograms = {};
        
        // Additional aviation data
        let tafData = {};
        let pirepData = [];
        let airmetData = [];
        let freezingLevelData = null;

        const FROZEN_PRECIP = ['SN', 'FZRA', 'FZFG', 'FZDZ', 'PL', 'GR', 'GS', 'IC', 'SG'];
        const ALL_PRECIP = [...FROZEN_PRECIP, 'RA', 'DZ', 'SHRA', 'TSRA', 'SHSN'];

        let refreshInterval = null;

        const CORS_PROXIES = [
            (url) => `https://api.allorigins.win/raw?url=${encodeURIComponent(url)}`,
            (url) => `https://corsproxy.io/?${encodeURIComponent(url)}`,
            (url) => url
        ];

        function parseMetar(metar) {
            if (!metar || metar.length < 10) return null;

            const result = {
                raw: metar,
                icao: null,
                temp_c: null,
                weather: [],
                visibility: 10,
                ceiling: null,
                flight_rules: 'VFR',
                frozen_precip: false,
                has_precip: false,
                has_moisture: false,
                obs_time: null
            };

            const icaoMatch = metar.match(/\b(K[A-Z]{3})\b/);
            if (icaoMatch) result.icao = icaoMatch[1];
            else return null;

            // Extract observation time (format: 031852Z = day 03, 18:52 UTC)
            const timeMatch = metar.match(/\b(\d{2})(\d{2})(\d{2})Z\b/);
            if (timeMatch) {
                const day = parseInt(timeMatch[1]);
                const hour = parseInt(timeMatch[2]);
                const min = parseInt(timeMatch[3]);
                const now = new Date();
                const obsDate = new Date(Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), day, hour, min));
                // Handle month rollover
                if (obsDate > now) {
                    obsDate.setUTCMonth(obsDate.getUTCMonth() - 1);
                }
                result.obs_time = obsDate;
            }

            const tempMatch = metar.match(/\s(M?\d{2})\/(M?\d{2})\s/);
            if (tempMatch) {
                const tempStr = tempMatch[1];
                result.temp_c = tempStr.startsWith('M') ? -parseInt(tempStr.slice(1)) : parseInt(tempStr);
            }

            const visMatch = metar.match(/\s(\d+)\s?SM\s/);
            if (visMatch) result.visibility = parseInt(visMatch[1]);
            else if (metar.match(/\d\/\d+SM/)) result.visibility = 0.5;

            for (const code of ALL_PRECIP) {
                if (metar.includes(code)) {
                    result.weather.push(code);
                    result.has_precip = true;
                    if (FROZEN_PRECIP.includes(code)) result.frozen_precip = true;
                }
            }

            if (metar.match(/\sBR\b/) || metar.match(/\sFG\b/)) {
                result.has_moisture = true;
                if (metar.includes(' BR')) result.weather.push('BR');
                if (metar.includes(' FG')) result.weather.push('FG');
            }

            const cloudMatches = metar.matchAll(/(BKN|OVC)(\d{3})/g);
            for (const match of cloudMatches) {
                const alt = parseInt(match[2]) * 100;
                if (result.ceiling === null || alt < result.ceiling) {
                    result.ceiling = alt;
                }
            }

            const vis = result.visibility;
            const ceil = result.ceiling;
            if ((ceil !== null && ceil < 500) || vis < 1) result.flight_rules = 'LIFR';
            else if ((ceil !== null && ceil < 1000) || vis < 3) result.flight_rules = 'IFR';
            else if ((ceil !== null && ceil < 3000) || vis < 5) result.flight_rules = 'MVFR';

            return result;
        }

        function categorize(parsed) {
            if (parsed.temp_c === null) return 'unknown';
            
            const temp = parsed.temp_c;
            
            if (temp <= 0 && parsed.frozen_precip) return 'active';
            if (parsed.weather.includes('FZRA') || parsed.weather.includes('FZDZ')) return 'active';
            
            // Check for residual - recent frozen precip in history but not current
            if (temp <= 3 && !parsed.frozen_precip && parsed.had_recent_frozen) return 'residual';
            
            if (temp <= 0 && parsed.has_precip) return 'likely';
            if (temp <= 0 && parsed.has_moisture) return 'likely';
            if (temp <= 0) return 'possible';
            if (temp <= 3 && parsed.has_precip) return 'marginal';
            return 'none';
        }
        
        function checkRecentFrozen(history) {
            if (!history || history.length < 2) return { hadFrozen: false, lastFrozenTime: null, frozenTypes: [] };
            
            // Skip the first (current) observation, check the rest
            const pastObs = history.slice(1);
            const frozenTypes = new Set();
            let lastFrozenTime = null;
            
            for (const obs of pastObs) {
                for (const wx of obs.weather) {
                    if (FROZEN_PRECIP.includes(wx)) {
                        frozenTypes.add(wx);
                        if (!lastFrozenTime && obs.obs_time) {
                            lastFrozenTime = obs.obs_time;
                        }
                    }
                }
            }
            
            return {
                hadFrozen: frozenTypes.size > 0,
                lastFrozenTime: lastFrozenTime,
                frozenTypes: Array.from(frozenTypes)
            };
        }

        function getLocalTime(icao) {
            const tz = AIRPORT_TIMEZONES[icao];
            if (!tz) return null;
            
            try {
                const now = new Date();
                const localTime = new Date(now.toLocaleString('en-US', { timeZone: tz }));
                return localTime;
            } catch (e) {
                return null;
            }
        }

        function getRushStatus(icao) {
            const localTime = getLocalTime(icao);
            if (!localTime) return null;
            
            const hour = localTime.getHours();
            const dayOfWeek = localTime.getDay(); // 0 = Sunday
            
            // Weekends have different patterns
            const isWeekend = dayOfWeek === 0 || dayOfWeek === 6;
            
            if (isWeekend) {
                // Weekend patterns are less pronounced
                if (hour >= 7 && hour < 11) return 'AM RUSH';
                if (hour >= 15 && hour < 19) return 'PM RUSH';
            } else {
                // Weekday patterns
                if (hour >= 6 && hour < 9) return 'AM RUSH';
                if (hour >= 16 && hour < 19) return 'PM RUSH';
            }
            
            return null;
        }

        function getHubInfo(icao) {
            return HUB_AIRPORTS[icao] || null;
        }

        async function fetchTrafficManagement() {
            // FAA Airport Status API
            const url = 'https://nasstatus.faa.gov/api/airport-status-information';
            
            try {
                const text = await tryFetch(url);
                const data = JSON.parse(text);
                
                trafficPrograms = {};
                
                if (data && Array.isArray(data)) {
                    for (const item of data) {
                        const icao = 'K' + item.airportId;
                        if (AIRPORTS.includes(icao)) {
                            const programs = [];
                            
                            // Ground Delay Programs
                            if (item.groundDelay && item.groundDelay.status === true) {
                                programs.push({
                                    type: 'GDP',
                                    avgDelay: item.groundDelay.avgDelay || 'N/A',
                                    reason: item.groundDelay.reason || ''
                                });
                            }
                            
                            // Ground Stops
                            if (item.groundStop && item.groundStop.status === true) {
                                programs.push({
                                    type: 'GROUND STOP',
                                    endTime: item.groundStop.endTime || 'TBD',
                                    reason: item.groundStop.reason || ''
                                });
                            }
                            
                            // Arrival/Departure delays
                            if (item.arrivalDelay && item.arrivalDelay.status === true) {
                                programs.push({
                                    type: 'ARR DELAY',
                                    minDelay: item.arrivalDelay.minDelay || '',
                                    maxDelay: item.arrivalDelay.maxDelay || '',
                                    reason: item.arrivalDelay.reason || ''
                                });
                            }
                            
                            if (item.departureDelay && item.departureDelay.status === true) {
                                programs.push({
                                    type: 'DEP DELAY',
                                    minDelay: item.departureDelay.minDelay || '',
                                    maxDelay: item.departureDelay.maxDelay || '',
                                    reason: item.departureDelay.reason || ''
                                });
                            }
                            
                            // Closures
                            if (item.closure && item.closure.status === true) {
                                programs.push({
                                    type: 'CLOSED',
                                    reason: item.closure.reason || ''
                                });
                            }
                            
                            if (programs.length > 0) {
                                trafficPrograms[icao] = programs;
                            }
                        }
                    }
                }
                
                console.log('Traffic programs loaded:', Object.keys(trafficPrograms).length, 'airports affected');
                
            } catch (e) {
                console.log('Traffic management fetch failed:', e.message);
                // Non-fatal - we'll just not show traffic data
            }
        }

        async function fetchTAFs() {
            try {
                const ids = AIRPORTS.join(',');
                const url = `https://aviationweather.gov/api/data/taf?ids=${ids}&format=raw`;
                console.log('Fetching TAFs from:', url);
                const text = await tryFetch(url, 0, 20);
                
                tafData = {};
                
                if (!text || text.length < 30) {
                    console.log('TAF: No data or empty response');
                    return;
                }
                
                console.log('TAF response length:', text.length);
                
                // TAFs can be separated by double newlines or be on single lines
                // Split by TAF keyword to handle both formats
                const tafParts = text.split(/(?=TAF\s+K[A-Z]{3})/);
                console.log('TAF parts found:', tafParts.length);
                
                for (const taf of tafParts) {
                    if (!taf.trim()) continue;
                    
                    const icaoMatch = taf.match(/TAF\s+(K[A-Z]{3})/);
                    if (!icaoMatch) continue;
                    
                    const icao = icaoMatch[1];
                    const forecasts = [];
                    
                    // Look for frozen precip anywhere in the TAF
                    // Match patterns like: SN, -SN, +SN, FZRA, -FZRA, etc.
                    const frozenPattern = /\b(\+|-)?((SN)|(FZRA)|(FZDZ)|(PL)|(FZFG)|(GS)|(GR))\b/g;
                    const matches = taf.matchAll(frozenPattern);
                    
                    for (const match of matches) {
                        const wx = match[0].replace(/^[+-]/, ''); // Remove intensity prefix
                        // Get context around the match (find the time group)
                        const beforeMatch = taf.substring(0, match.index);
                        const timeMatch = beforeMatch.match(/(FM\d{6}|TEMPO\s+\d{4}\/\d{4}|BECMG\s+\d{4}\/\d{4}|\d{4}\/\d{4})\s*[^\n]*$/);
                        
                        forecasts.push({
                            raw: timeMatch ? timeMatch[0].substring(0, 30) + ' ' + wx : wx,
                            wx: wx
                        });
                    }
                    
                    // Deduplicate forecasts
                    const uniqueForecasts = [];
                    const seen = new Set();
                    for (const fc of forecasts) {
                        if (!seen.has(fc.wx)) {
                            seen.add(fc.wx);
                            uniqueForecasts.push(fc);
                        }
                    }
                    
                    if (uniqueForecasts.length > 0 || taf.length > 20) {
                        tafData[icao] = {
                            raw: taf.substring(0, 500),
                            frozenForecasts: uniqueForecasts,
                            warmingTime: null
                        };
                    }
                }
                
                // Count airports with frozen precip forecasts
                let frozenCount = 0;
                for (const icao in tafData) {
                    if (tafData[icao].frozenForecasts.length > 0) frozenCount++;
                }
                console.log('TAFs loaded:', Object.keys(tafData).length, 'airports,', frozenCount, 'with frozen precip');
                
            } catch (e) {
                console.error('TAF fetch failed:', e.message);
                tafData = {};
            }
        }

        async function fetchPIREPs() {
            try {
                // Get all PIREPs from last 2 hours
                const url = `https://aviationweather.gov/api/data/pirep?format=raw&age=2`;
                console.log('Fetching PIREPs from:', url);
                const text = await tryFetch(url, 0, 10);
                
                pirepData = [];
                
                if (!text || text.length < 20) {
                    console.log('PIREP: No data or empty response');
                    return;
                }
                
                console.log('PIREP response length:', text.length, 'First 200 chars:', text.substring(0, 200));
                
                const pireps = text.trim().split('\n');
                console.log('Total PIREP lines:', pireps.length);
                
                let icingCount = 0;
                for (const pirep of pireps) {
                    // Look for icing reports - /IC or ICE or ICING
                    if (!pirep.match(/\/IC|ICE|ICING/i)) continue;
                    icingCount++;
                    
                    // Parse location - can be /OV XXX or just airport code at start
                    const locMatch = pirep.match(/\/OV\s*([A-Z]{3,4})|^([A-Z]{3,4})\s+UA/);
                    // Parse altitude - /FL or /ALT
                    const altMatch = pirep.match(/\/FL\s*(\d{3})|\/ALT\s*(\d{3,5})/);
                    // Parse icing type and intensity
                    const icMatch = pirep.match(/\/IC\s*([A-Z\-\s]+?)(?=\/|$)/);
                    // Parse time
                    const timeMatch = pirep.match(/\/TM\s*(\d{4})/);
                    
                    const location = locMatch ? (locMatch[1] || locMatch[2]) : null;
                    
                    if (location) {
                        let intensity = 'light';
                        const icText = icMatch ? icMatch[1].trim().toUpperCase() : 'ICING';
                        
                        if (icText.match(/MOD|MDT/)) intensity = 'moderate';
                        if (icText.match(/SEV|HVY|HEAVY/)) intensity = 'severe';
                        
                        let altitude = null;
                        if (altMatch) {
                            altitude = altMatch[1] ? parseInt(altMatch[1]) * 100 : parseInt(altMatch[2]);
                        }
                        
                        pirepData.push({
                            location: location,
                            altitude: altitude,
                            intensity: intensity,
                            type: icText.substring(0, 20),
                            time: timeMatch ? timeMatch[1] : null,
                            raw: pirep.substring(0, 100)
                        });
                    }
                }
                
                // Sort by intensity (severe first)
                const intensityOrder = { severe: 0, moderate: 1, light: 2 };
                pirepData.sort((a, b) => intensityOrder[a.intensity] - intensityOrder[b.intensity]);
                
                console.log('PIREPs with icing keyword:', icingCount, '| Parsed successfully:', pirepData.length);
                
            } catch (e) {
                console.error('PIREP fetch failed:', e.message, e);
                pirepData = [];
            }
        }

        async function fetchAIRMETs() {
            try {
                // Get AIRMETs - try without hazard filter first
                const url = `https://aviationweather.gov/api/data/airsigmet?format=raw`;
                console.log('Fetching AIRMETs from:', url);
                const text = await tryFetch(url, 0, 10);
                
                airmetData = [];
                
                if (!text || text.length < 20) {
                    console.log('AIRMET: No data or empty response');
                    return;
                }
                
                console.log('AIRMET response length:', text.length, 'First 300 chars:', text.substring(0, 300));
                
                // Split by double newline or by AIRMET keyword
                const parts = text.split(/\n\n|(?=WA\d+\s)|(?=AIRMET)/);
                console.log('AIRMET parts:', parts.length);
                
                let icingCount = 0;
                for (const part of parts) {
                    const airmet = part.trim();
                    if (!airmet) continue;
                    
                    // Look for icing-related AIRMETs
                    if (!airmet.match(/ICE|ICING|FRZLVL|ZULU|ICG/i)) continue;
                    icingCount++;
                    
                    // Extract validity time
                    const validMatch = airmet.match(/VALID\s*(?:UNTIL\s*)?(\d{6})|(\d{6})Z?-(\d{6})/i);
                    // Extract flight levels
                    const flMatch = airmet.match(/FL(\d{3})/g);
                    // Extract freezing level info
                    const frzlvlMatch = airmet.match(/FRZLVL[^\n\.]+|FREEZING\s+LEVEL[^\n\.]+/i);
                    
                    airmetData.push({
                        raw: airmet.substring(0, 250),
                        validUntil: validMatch ? (validMatch[1] || validMatch[3]) : null,
                        flightLevels: flMatch || [],
                        freezingLevel: frzlvlMatch ? frzlvlMatch[0] : null
                    });
                }
                
                console.log('AIRMETs with icing keywords:', icingCount, '| Parsed:', airmetData.length);
                
            } catch (e) {
                console.error('AIRMET fetch failed:', e.message, e);
                airmetData = [];
            }
        }

        async function fetchFreezingLevel() {
            try {
                // Try to get freezing level from AIRMETs first (most reliable)
                for (const airmet of airmetData) {
                    if (airmet.freezingLevel) {
                        // Parse patterns like "FRZLVL 080-100" or "FRZLVL SFC-040"
                        const lvlMatch = airmet.freezingLevel.match(/(\d{2,3})(?:00)?(?:\s*(?:FT|MSL|AGL))?/);
                        if (lvlMatch) {
                            let level = parseInt(lvlMatch[1]);
                            // If it looks like a flight level (2-3 digits), multiply by 100
                            if (level < 500) level *= 100;
                            
                            freezingLevelData = {
                                level: level,
                                unit: 'ft',
                                source: 'AIRMET',
                                raw: airmet.freezingLevel
                            };
                            console.log('Freezing level from AIRMET:', freezingLevelData);
                            return;
                        }
                    }
                }
                
                // Fallback: estimate from cold airport temperatures
                // Find the coldest airport at ground level and extrapolate
                // (rough estimate: freezing level is where ground temp would be 0¬∞C)
                
                console.log('Freezing level: Using AIRMET data if available');
                
            } catch (e) {
                console.log('Freezing level calculation failed:', e.message);
            }
        }

        function getFrostRisk(icao, tempC) {
            // Frost risk: below 4¬∞C during night/early morning hours
            if (tempC === null || tempC > 4) return false;
            
            const localTime = getLocalTime(icao);
            if (!localTime) return false;
            
            const hour = localTime.getHours();
            // High frost risk window: 10pm - 9am when temps are near/below freezing
            return (hour >= 22 || hour < 9) && tempC <= 4;
        }

        function tempToF(c) {
            return Math.round(c * 9/5 + 32);
        }

        function getTimeSince(obsTime) {
            if (!obsTime) return { text: 'N/A', stale: false };
            const now = new Date();
            const diffMs = now - obsTime;
            const diffMins = Math.floor(diffMs / 60000);
            
            if (diffMins < 60) {
                return { text: `${diffMins}m ago`, stale: diffMins > 90 };
            } else {
                const hours = Math.floor(diffMins / 60);
                const mins = diffMins % 60;
                return { text: `${hours}h ${mins}m ago`, stale: hours >= 2 };
            }
        }

        function getTrend(history) {
            if (!history || history.length < 2) return { symbol: '‚Äî', class: 'steady', text: 'No trend data' };
            
            // Get temps from oldest to newest (history is newest first, so reverse)
            const temps = history.map(h => h.temp_c).filter(t => t !== null).reverse();
            if (temps.length < 2) return { symbol: '‚Äî', class: 'steady', text: 'No trend data' };
            
            const oldest = temps[0];
            const newest = temps[temps.length - 1];
            const diff = newest - oldest;
            
            if (diff >= 3) return { symbol: '‚Üë', class: 'warming', text: `+${diff}¬∞ over ${temps.length} obs` };
            if (diff <= -3) return { symbol: '‚Üì', class: 'cooling', text: `${diff}¬∞ over ${temps.length} obs` };
            return { symbol: '‚Üí', class: 'steady', text: 'Steady' };
        }

        async function tryFetch(url, proxyIndex = 0, minLength = 10) {
            if (proxyIndex >= CORS_PROXIES.length) {
                console.warn('All fetch methods failed for:', url.substring(0, 60));
                return ''; // Return empty string instead of throwing
            }
            
            const proxyUrl = CORS_PROXIES[proxyIndex](url);
            
            try {
                const controller = new AbortController();
                const timeout = setTimeout(() => controller.abort(), 15000);
                
                const response = await fetch(proxyUrl, { 
                    signal: controller.signal,
                    headers: { 'Accept': 'text/plain' }
                });
                clearTimeout(timeout);
                
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                
                const text = await response.text();
                if (!text || text.length < minLength) {
                    throw new Error('Response too short: ' + text.length);
                }
                return text;
            } catch (e) {
                console.log(`Proxy ${proxyIndex} failed for ${url.substring(0,50)}:`, e.message);
                return tryFetch(url, proxyIndex + 1, minLength);
            }
        }

        async function fetchData() {
            const btn = document.getElementById('refreshBtn');
            const content = document.getElementById('content');
            
            btn.disabled = true;
            btn.textContent = '‚è≥ Loading...';
            
            content.innerHTML = `
                <div class="loading">
                    <div class="spinner"></div>
                    <div>Fetching METAR, TAF, PIREP, AIRMET data...</div>
                    <div id="loadingStatus" style="font-size: 11px; color: #666; margin-top: 10px;"></div>
                </div>
            `;
            
            const updateStatus = (msg) => {
                const el = document.getElementById('loadingStatus');
                if (el) el.innerHTML += msg + '<br>';
            };

            try {
                // Fetch all data sources in parallel
                const trafficPromise = fetchTrafficManagement();
                const tafPromise = fetchTAFs();
                const pirepPromise = fetchPIREPs();
                const airmetPromise = fetchAIRMETs();
                
                const ids = AIRPORTS.join(',');
                // Request last 6 hours of METARs
                const baseUrl = `https://aviationweather.gov/api/data/metar?ids=${ids}&format=raw&hours=6`;
                
                const text = await tryFetch(baseUrl);
                const metars = text.trim().split('\n').filter(m => m.length > 10 && m.match(/K[A-Z]{3}/));
                
                if (metars.length === 0) {
                    throw new Error('No valid METAR data received');
                }
                
                // Wait for all other data
                await Promise.all([trafficPromise, tafPromise, pirepPromise, airmetPromise]);
                
                // Fetch freezing level after AIRMETs (uses AIRMET data as fallback)
                await fetchFreezingLevel();
                
                // Parse all METARs
                const allParsed = metars.map(parseMetar).filter(p => p !== null);
                
                // Group by airport
                const byAirport = {};
                for (const p of allParsed) {
                    if (!byAirport[p.icao]) byAirport[p.icao] = [];
                    byAirport[p.icao].push(p);
                }
                
                // Sort each airport's METARs by time (newest first) and keep last 6
                for (const icao in byAirport) {
                    byAirport[icao].sort((a, b) => (b.obs_time || 0) - (a.obs_time || 0));
                    byAirport[icao] = byAirport[icao].slice(0, 6);
                }
                
                // Create airport objects with latest data and history
                const airportData = [];
                for (const icao of AIRPORTS) {
                    if (byAirport[icao] && byAirport[icao].length > 0) {
                        const history = byAirport[icao];
                        const latest = history[0];
                        const recentFrozen = checkRecentFrozen(history);
                        airportData.push({
                            ...latest,
                            history: history,
                            trend: getTrend(history),
                            had_recent_frozen: recentFrozen.hadFrozen,
                            recent_frozen_types: recentFrozen.frozenTypes,
                            last_frozen_time: recentFrozen.lastFrozenTime,
                            // New indicators
                            hub_airlines: getHubInfo(icao),
                            rush_status: getRushStatus(icao),
                            traffic_programs: trafficPrograms[icao] || null,
                            // TAF data
                            taf: tafData[icao] || null,
                            frost_risk: getFrostRisk(icao, latest.temp_c)
                        });
                    }
                }
                
                // Categorize
                const categories = { active: [], likely: [], residual: [], possible: [], marginal: [], none: [] };
                for (const apt of airportData) {
                    const cat = categorize(apt);
                    if (categories[cat]) categories[cat].push(apt);
                }

                // Sort by airport rank (busiest first)
                for (const cat in categories) {
                    categories[cat].sort((a, b) => {
                        const rankA = AIRPORTS.indexOf(a.icao);
                        const rankB = AIRPORTS.indexOf(b.icao);
                        return rankA - rankB;
                    });
                }

                renderResults(categories, airportData.length);
                
                const now = new Date();
                document.getElementById('timestamp').textContent = 
                    `Updated: ${now.toLocaleTimeString()} | ${airportData.length} airports reporting`;

            } catch (error) {
                content.innerHTML = `
                    <div class="error">
                        <strong>Unable to load data</strong><br><br>
                        ${error.message}<br><br>
                        <small>This can happen due to network issues or API availability.</small>
                        <br>
                        <button onclick="fetchData()">Try Again</button>
                    </div>
                `;
            }

            btn.disabled = false;
            btn.textContent = 'üîÑ Refresh';
        }

        function renderResults(categories, total) {
            const content = document.getElementById('content');
            
            // Traffic management summary
            let trafficHtml = '';
            const affectedAirports = Object.keys(trafficPrograms);
            if (affectedAirports.length > 0) {
                trafficHtml = `<div class="traffic-section"><h3>‚ö†Ô∏è Active Traffic Management Programs</h3>`;
                for (const icao of affectedAirports) {
                    const programs = trafficPrograms[icao];
                    const name = AIRPORT_NAMES[icao] || icao;
                    for (const prog of programs) {
                        let details = '';
                        if (prog.type === 'GDP') {
                            details = `Avg delay: ${prog.avgDelay}`;
                        } else if (prog.type === 'GROUND STOP') {
                            details = `Until: ${prog.endTime}`;
                        } else if (prog.type === 'ARR DELAY' || prog.type === 'DEP DELAY') {
                            details = `${prog.minDelay}-${prog.maxDelay}`;
                        }
                        trafficHtml += `
                            <div class="traffic-item">
                                <span class="airport">${icao}</span> ${name} - 
                                <span class="program">${prog.type}</span> ${details}
                                <div class="reason">${prog.reason}</div>
                            </div>
                        `;
                    }
                }
                trafficHtml += '</div>';
            }
            
            // Info grid: PIREPs, AIRMETs, Freezing Level
            let infoGridHtml = '<div class="info-grid">';
            
            // Freezing Level panel
            if (freezingLevelData) {
                infoGridHtml += `
                    <div class="data-panel freezing">
                        <h3>üå°Ô∏è Freezing Level</h3>
                        <div style="text-align: center;">
                            <div style="font-size: 28px; font-weight: bold; color: #1abc9c;">${freezingLevelData.level.toLocaleString()} ft</div>
                            <div style="font-size: 11px; color: #888; margin-top: 4px;">
                                ${freezingLevelData.source ? `Source: ${freezingLevelData.source}` : 'Regional estimate'}
                                ${freezingLevelData.raw ? '<br>' + freezingLevelData.raw : ''}
                            </div>
                        </div>
                    </div>
                `;
            } else {
                infoGridHtml += `
                    <div class="data-panel freezing">
                        <h3>üå°Ô∏è Freezing Level</h3>
                        <div style="text-align: center; color: #666; font-size: 12px;">No data available</div>
                    </div>
                `;
            }
            
            // PIREPs panel
            if (pirepData.length > 0) {
                const pirepInitialShow = 8;
                const hasMorePireps = pirepData.length > pirepInitialShow;
                
                infoGridHtml += `
                    <div class="data-panel pireps">
                        <h3 style="cursor: ${hasMorePireps ? 'pointer' : 'default'};" ${hasMorePireps ? 'onclick="togglePirepList()"' : ''}>
                            üõ©Ô∏è Icing PIREPs (${pirepData.length})
                            ${hasMorePireps ? '<span id="pirepToggleIcon" style="float: right; font-size: 10px;">‚ñº</span>' : ''}
                        </h3>
                        <div class="compact-list">
                `;
                for (const pirep of pirepData.slice(0, pirepInitialShow)) {
                    const alt = pirep.altitude ? `FL${Math.round(pirep.altitude/100).toString().padStart(3,'0')}` : 'N/A';
                    infoGridHtml += `
                        <div class="item">
                            <span class="pirep-item">
                                <span class="intensity ${pirep.intensity}">${pirep.intensity.toUpperCase()}</span>
                                ${pirep.location} @ ${alt} - ${pirep.type}
                            </span>
                        </div>
                    `;
                }
                if (hasMorePireps) {
                    infoGridHtml += `<div id="pirepExpandedList" style="display: none;">`;
                    for (const pirep of pirepData.slice(pirepInitialShow)) {
                        const alt = pirep.altitude ? `FL${Math.round(pirep.altitude/100).toString().padStart(3,'0')}` : 'N/A';
                        infoGridHtml += `
                            <div class="item">
                                <span class="pirep-item">
                                    <span class="intensity ${pirep.intensity}">${pirep.intensity.toUpperCase()}</span>
                                    ${pirep.location} @ ${alt} - ${pirep.type}
                                </span>
                            </div>
                        `;
                    }
                    infoGridHtml += '</div>';
                }
                infoGridHtml += '</div></div>';
            } else {
                infoGridHtml += `
                    <div class="data-panel pireps">
                        <h3>üõ©Ô∏è Icing PIREPs</h3>
                        <div style="color: #666; font-size: 12px;">No icing PIREPs in last 2 hours</div>
                    </div>
                `;
            }
            
            // AIRMETs panel
            if (airmetData.length > 0) {
                const airmetInitialShow = 4;
                const hasMoreAirmets = airmetData.length > airmetInitialShow;
                
                infoGridHtml += `
                    <div class="data-panel airmets">
                        <h3 style="cursor: ${hasMoreAirmets ? 'pointer' : 'default'};" ${hasMoreAirmets ? 'onclick="toggleAirmetList()"' : ''}>
                            ‚ö° Icing AIRMETs (${airmetData.length})
                            ${hasMoreAirmets ? '<span id="airmetToggleIcon" style="float: right; font-size: 10px;">‚ñº</span>' : ''}
                        </h3>
                        <div class="compact-list">
                `;
                for (const airmet of airmetData.slice(0, airmetInitialShow)) {
                    const validText = airmet.validUntil ? `Valid until ${airmet.validUntil}Z` : '';
                    const frzText = airmet.freezingLevel || '';
                    infoGridHtml += `
                        <div class="item">
                            <div style="color: #ddd;">${validText}</div>
                            <div style="color: #9b59b6; font-size: 10px;">${frzText}</div>
                        </div>
                    `;
                }
                if (hasMoreAirmets) {
                    infoGridHtml += `<div id="airmetExpandedList" style="display: none;">`;
                    for (const airmet of airmetData.slice(airmetInitialShow)) {
                        const validText = airmet.validUntil ? `Valid until ${airmet.validUntil}Z` : '';
                        const frzText = airmet.freezingLevel || '';
                        infoGridHtml += `
                            <div class="item">
                                <div style="color: #ddd;">${validText}</div>
                                <div style="color: #9b59b6; font-size: 10px;">${frzText}</div>
                            </div>
                        `;
                    }
                    infoGridHtml += '</div>';
                }
                infoGridHtml += '</div></div>';
            } else {
                infoGridHtml += `
                    <div class="data-panel airmets">
                        <h3>‚ö° Icing AIRMETs</h3>
                        <div style="color: #666; font-size: 12px;">No active icing AIRMETs</div>
                    </div>
                `;
            }
            
            infoGridHtml += '</div>';
            
            // TAF Forecasts with frozen precip
            let tafHtml = '';
            const tafWarnings = [];
            for (const icao of AIRPORTS) {
                const taf = tafData[icao];
                if (taf && taf.frozenForecasts && taf.frozenForecasts.length > 0) {
                    const name = AIRPORT_NAMES[icao] || icao;
                    for (const fc of taf.frozenForecasts.slice(0, 1)) {
                        tafWarnings.push({
                            icao: icao,
                            name: name,
                            wx: fc.wx,
                            raw: fc.raw
                        });
                    }
                }
            }
            
            if (tafWarnings.length > 0) {
                const initialShow = 10;
                const hasMore = tafWarnings.length > initialShow;
                
                tafHtml = `<div class="forecast-section">
                    <h3 style="cursor: ${hasMore ? 'pointer' : 'default'};" ${hasMore ? 'onclick="toggleTafList()"' : ''}>
                        üìã TAF: Frozen Precip Forecast (${tafWarnings.length} airports)
                        ${hasMore ? '<span id="tafToggleIcon" style="float: right; font-size: 12px;">‚ñº Show all</span>' : ''}
                    </h3>`;
                
                // First 10 always visible
                for (const warn of tafWarnings.slice(0, initialShow)) {
                    tafHtml += `
                        <div class="forecast-note">
                            <span class="airport">${warn.icao}</span> ${warn.name} - 
                            <span style="color: #9b59b6;">${warn.wx}</span>
                            <span style="color: #666; font-size: 10px;"> ${warn.raw}</span>
                        </div>
                    `;
                }
                
                // Remaining airports in collapsible section
                if (hasMore) {
                    tafHtml += `<div id="tafExpandedList" style="display: none;">`;
                    for (const warn of tafWarnings.slice(initialShow)) {
                        tafHtml += `
                            <div class="forecast-note">
                                <span class="airport">${warn.icao}</span> ${warn.name} - 
                                <span style="color: #9b59b6;">${warn.wx}</span>
                                <span style="color: #666; font-size: 10px;"> ${warn.raw}</span>
                            </div>
                        `;
                    }
                    tafHtml += '</div>';
                }
                
                tafHtml += '</div>';
            }
            
            let html = trafficHtml + infoGridHtml + tafHtml + `
                <div class="summary">
                    <div class="summary-card active">
                        <div class="count">${categories.active.length}</div>
                        <div class="label">üî¥ Active</div>
                    </div>
                    <div class="summary-card residual">
                        <div class="count">${categories.residual.length}</div>
                        <div class="label">üü£ Residual</div>
                    </div>
                    <div class="summary-card likely">
                        <div class="count">${categories.likely.length}</div>
                        <div class="label">üü† Likely</div>
                    </div>
                    <div class="summary-card possible">
                        <div class="count">${categories.possible.length}</div>
                        <div class="label">üü° Possible</div>
                    </div>
                </div>
            `;

            if (categories.active.length > 0) {
                html += renderSection('üî¥ Active Deicing', categories.active);
            }
            if (categories.residual.length > 0) {
                html += renderSection('üü£ Residual (Recent Frozen Precip)', categories.residual);
            }
            if (categories.likely.length > 0) {
                html += renderSection('üü† Likely Deicing', categories.likely);
            }
            if (categories.possible.length > 0) {
                html += renderSection('üü° Possible (Below Freezing)', categories.possible);
            }

            if (categories.active.length === 0 && categories.likely.length === 0 && categories.residual.length === 0 && categories.possible.length === 0) {
                html += `<div class="status-msg info">‚úÖ No airports currently reporting deicing conditions</div>`;
            }
            
            // Data status summary
            html += `
                <div style="background: #1a1a2e; border: 1px solid #333; border-radius: 8px; padding: 10px; margin-top: 20px; font-size: 11px; color: #666;">
                    <strong style="color: #888;">Data Status:</strong>
                    <span style="margin-left: 10px;">TAFs: ${Object.keys(tafData).length}</span>
                    <span style="margin-left: 10px;">PIREPs: ${pirepData.length}</span>
                    <span style="margin-left: 10px;">AIRMETs: ${airmetData.length}</span>
                    <span style="margin-left: 10px;">FrzLvl: ${freezingLevelData ? '‚úì' : '‚úó'}</span>
                </div>
            `;

            content.innerHTML = html;
        }

        function toggleHistory(id) {
            const el = document.getElementById(id);
            if (el) {
                el.classList.toggle('show');
            }
        }

        function toggleTafList() {
            const list = document.getElementById('tafExpandedList');
            const icon = document.getElementById('tafToggleIcon');
            if (list && icon) {
                if (list.style.display === 'none') {
                    list.style.display = 'block';
                    icon.textContent = '‚ñ≤ Show less';
                } else {
                    list.style.display = 'none';
                    icon.textContent = '‚ñº Show all';
                }
            }
        }

        function togglePirepList() {
            const list = document.getElementById('pirepExpandedList');
            const icon = document.getElementById('pirepToggleIcon');
            if (list && icon) {
                if (list.style.display === 'none') {
                    list.style.display = 'block';
                    icon.textContent = '‚ñ≤';
                } else {
                    list.style.display = 'none';
                    icon.textContent = '‚ñº';
                }
            }
        }

        function toggleAirmetList() {
            const list = document.getElementById('airmetExpandedList');
            const icon = document.getElementById('airmetToggleIcon');
            if (list && icon) {
                if (list.style.display === 'none') {
                    list.style.display = 'block';
                    icon.textContent = '‚ñ≤';
                } else {
                    list.style.display = 'none';
                    icon.textContent = '‚ñº';
                }
            }
        }

        function renderSection(title, airports) {
            let html = `
                <div class="section">
                    <div class="section-header"><h2>${title}</h2></div>
                    <div class="airport-list">
            `;

            for (const apt of airports) {
                const name = AIRPORT_NAMES[apt.icao] || apt.icao;
                const wx = apt.weather.length > 0 ? apt.weather.join(' ') : '‚Äî';
                const frClass = `fr-${apt.flight_rules.toLowerCase()}`;
                const rank = AIRPORTS.indexOf(apt.icao) + 1;
                const metarUrl = `https://aviationweather.gov/data/metar/?id=${apt.icao}`;
                const timeSince = getTimeSince(apt.obs_time);
                const historyId = `history-${apt.icao}`;
                
                // Build badges HTML
                let badgesHtml = '<div class="badges">';
                
                // Traffic program badges (highest priority)
                if (apt.traffic_programs) {
                    for (const prog of apt.traffic_programs) {
                        if (prog.type === 'GROUND STOP') {
                            badgesHtml += `<span class="badge badge-gs" title="${prog.reason}">GS</span>`;
                        } else if (prog.type === 'GDP') {
                            badgesHtml += `<span class="badge badge-gdp" title="${prog.reason}">GDP</span>`;
                        } else if (prog.type === 'CLOSED') {
                            badgesHtml += `<span class="badge badge-gs" title="${prog.reason}">CLOSED</span>`;
                        } else {
                            badgesHtml += `<span class="badge badge-delay" title="${prog.reason}">${prog.type}</span>`;
                        }
                    }
                }
                
                // Rush hour badge
                if (apt.rush_status) {
                    badgesHtml += `<span class="badge badge-rush">${apt.rush_status}</span>`;
                }
                
                // Frost risk badge (night + cold)
                if (apt.frost_risk) {
                    badgesHtml += `<span class="badge badge-frost">üåô FROST RISK</span>`;
                }
                
                // TAF frozen precip forecast badge
                if (apt.taf && apt.taf.frozenForecasts && apt.taf.frozenForecasts.length > 0) {
                    const fc = apt.taf.frozenForecasts[0];
                    badgesHtml += `<span class="badge badge-taf-sn" title="${fc.raw}">TAF: ${fc.wx}</span>`;
                }
                
                // Hub badge
                if (apt.hub_airlines) {
                    const hubText = apt.hub_airlines.length > 2 
                        ? apt.hub_airlines.slice(0, 2).join('/') + '+' 
                        : apt.hub_airlines.join('/');
                    badgesHtml += `<span class="badge badge-hub" title="${apt.hub_airlines.join(', ')} hub">HUB: ${hubText}</span>`;
                }
                
                badgesHtml += '</div>';
                
                // Recent frozen precip indicator
                let recentFrozenHtml = '';
                if (apt.had_recent_frozen && !apt.frozen_precip) {
                    const frozenAgo = apt.last_frozen_time ? getTimeSince(apt.last_frozen_time).text : 'recently';
                    recentFrozenHtml = `<div class="recent-frozen-note">‚ùÑÔ∏è ${apt.recent_frozen_types.join(', ')} ended ${frozenAgo}</div>`;
                }
                
                // TAF forecast indicator
                let tafHtml = '';
                if (apt.taf && apt.taf.frozenForecasts && apt.taf.frozenForecasts.length > 0 && !apt.frozen_precip) {
                    tafHtml = `<div class="taf-forecast">üìã TAF: ${apt.taf.frozenForecasts[0].wx} forecast</div>`;
                }
                
                let historyHtml = '';
                if (apt.history && apt.history.length > 0) {
                    historyHtml = `<div class="history" id="${historyId}"><div class="history-title">Last ${apt.history.length} observations</div>`;
                    for (const h of apt.history) {
                        const hTime = h.obs_time ? h.obs_time.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit', timeZoneName: 'short'}) : 'N/A';
                        const hWx = h.weather.length > 0 ? h.weather.join(' ') : '‚Äî';
                        const hTemp = h.temp_c !== null ? `${h.temp_c}¬∞C / ${tempToF(h.temp_c)}¬∞F` : 'N/A';
                        // Highlight rows with frozen precip
                        const hasFrozen = h.weather.some(w => FROZEN_PRECIP.includes(w));
                        const rowStyle = hasFrozen ? 'background: #3d2850;' : '';
                        historyHtml += `<div class="history-row" style="${rowStyle}"><span class="time">${hTime}</span><span class="temp">${hTemp}</span><span class="wx">${hWx}</span></div>`;
                    }
                    historyHtml += '</div>';
                }
                
                html += `
                    <div class="airport-card" onclick="toggleHistory('${historyId}')">
                        <div class="airport-main">
                            <div class="left">
                                <div class="icao">#${rank} ${apt.icao}</div>
                                <div>
                                    <div class="name"><a href="${metarUrl}" target="_blank" onclick="event.stopPropagation();">${name} ‚Üó</a></div>
                                    <div class="weather">${wx} <span class="flight-rules ${frClass}">${apt.flight_rules}</span></div>
                                    <div class="obs-time ${timeSince.stale ? 'stale' : ''}">${timeSince.text}</div>
                                    ${recentFrozenHtml}
                                    ${tafHtml}
                                    ${badgesHtml}
                                </div>
                            </div>
                            <div class="right">
                                <div class="trend ${apt.trend.class}" title="${apt.trend.text}">${apt.trend.symbol}</div>
                                <div class="temp">
                                    <div class="temp-value">${apt.temp_c}¬∞</div>
                                    <div class="temp-f">${tempToF(apt.temp_c)}¬∞F</div>
                                </div>
                            </div>
                        </div>
                        <div class="expand-hint">Tap to see history</div>
                        ${historyHtml}
                    </div>
                `;
            }

            html += '</div></div>';
            return html;
        }

        function setAutoRefresh() {
            const mins = parseInt(document.getElementById('autoRefresh').value);
            if (refreshInterval) clearInterval(refreshInterval);
            if (mins > 0) {
                refreshInterval = setInterval(fetchData, mins * 60 * 1000);
            }
        }

        // Start
        fetchData();
        setAutoRefresh();
        
        // Timezone clock update
        function updateTimezones() {
            const now = new Date();
            
            const formatTime = (tz) => {
                try {
                    return now.toLocaleTimeString('en-US', { 
                        timeZone: tz, 
                        hour: '2-digit', 
                        minute: '2-digit',
                        hour12: false 
                    });
                } catch (e) {
                    return '--:--';
                }
            };
            
            // Zulu/UTC
            const zuluEl = document.getElementById('tz-zulu');
            if (zuluEl) zuluEl.textContent = formatTime('UTC') + 'Z';
            
            // Eastern
            const eastEl = document.getElementById('tz-eastern');
            if (eastEl) eastEl.textContent = formatTime('America/New_York');
            
            // Central
            const centEl = document.getElementById('tz-central');
            if (centEl) centEl.textContent = formatTime('America/Chicago');
            
            // Mountain
            const mtEl = document.getElementById('tz-mountain');
            if (mtEl) mtEl.textContent = formatTime('America/Denver');
            
            // Pacific
            const pacEl = document.getElementById('tz-pacific');
            if (pacEl) pacEl.textContent = formatTime('America/Los_Angeles');
        }
        
        updateTimezones();
        setInterval(updateTimezones, 1000);
    </script>
</body>
</html>
